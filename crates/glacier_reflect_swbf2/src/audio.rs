use std::mem::offset_of;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_audio_types(registry: &mut TypeRegistry) {
    registry.register_type(SOUNDMASTERENTITY_TYPE_INFO);
    registry.register_type(SOUNDMASTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITY_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITY_TYPE_INFO);
    registry.register_type(SOUNDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITY_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITY_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITY_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBENTITY_TYPE_INFO);
    registry.register_type(IRREVERBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACK_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACK_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYER_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYER_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYER_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITY_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTITY_TYPE_INFO);
    registry.register_type(MIXERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVERESOURCE_TYPE_INFO);
    registry.register_type(NEWWAVERESOURCE_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEREPORTINGASSET_TYPE_INFO);
    registry.register_type(NEWWAVEREPORTINGASSET_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEDEBUGASSET_TYPE_INFO);
    registry.register_type(NEWWAVEDEBUGASSET_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEVARIATIONDEBUGDATA_TYPE_INFO);
    registry.register_type(NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALIZEDWAVEASSET_TYPE_INFO);
    registry.register_type(LOCALIZEDWAVEASSET_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEASSET_TYPE_INFO);
    registry.register_type(NEWWAVEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSET_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSETBASE_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVESTREAMINGMODE_TYPE_INFO);
    registry.register_type(SOUNDWAVESTREAMINGMODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVELOCALIZATIONINFO_TYPE_INFO);
    registry.register_type(SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVERUNTIMEVARIATION_TYPE_INFO);
    registry.register_type(SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATION_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVESUBTITLE_TYPE_INFO);
    registry.register_type(SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSEGMENT_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSELECTION_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSELECTION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVOICEPRIORITY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVOICEPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAASSET_TYPE_INFO);
    registry.register_type(SOUNDDATAASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAPOLICY_TYPE_INFO);
    registry.register_type(SOUNDDATAPOLICY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREADTARGET_TYPE_INFO);
    registry.register_type(SOUNDDATAREADTARGET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATARELEASEBEHAVIOR_TYPE_INFO);
    registry.register_type(SOUNDDATARELEASEBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATACHUNK_TYPE_INFO);
    registry.register_type(SOUNDDATACHUNK_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATASTATE_TYPE_INFO);
    registry.register_type(SOUNDDATASTATE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTRESULT_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTRESULT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAPRIMERESULT_TYPE_INFO);
    registry.register_type(SOUNDDATAPRIMERESULT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREADPRIORITY_TYPE_INFO);
    registry.register_type(SOUNDDATAREADPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSYSTEMASSET_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPTYPE_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(SPATIALSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKEDSOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(LINKEDSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(EVENTSOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUESOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(VALUESOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOSETTINGS_TYPE_INFO);
    registry.register_type(AUDIOSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONASSET_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(SCOPECOLLECTIONASSET_TYPE_INFO);
    registry.register_type(SCOPECOLLECTIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMASSET_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLMAPPING_TYPE_INFO);
    registry.register_type(STREAMPOOLMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLPRESET_TYPE_INFO);
    registry.register_type(STREAMPOOLPRESET_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGESETTING_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGEMAPPING_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHASSET_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDMASTERPATCHASSET_TYPE_INFO);
    registry.register_type(SOUNDMASTERPATCHASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHBASEASSET_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHASSET_TYPE_INFO);
    registry.register_type(SOUNDPATCHASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHDEFAULTEVENT_TYPE_INFO);
    registry.register_type(SOUNDPATCHDEFAULTEVENT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHPUBLICNODE_TYPE_INFO);
    registry.register_type(SOUNDPATCHPUBLICNODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHASSET_TYPE_INFO);
    registry.register_type(SOUNDGRAPHASSET_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOMATERIALDEFINITIONS_TYPE_INFO);
    registry.register_type(AUDIOMATERIALDEFINITIONS_ARRAY_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEASSET_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEASSET_ARRAY_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEBLOCKSIZE_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEBLOCKSIZE_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUP_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPBEHAVIOR_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOL_TYPE_INFO);
    registry.register_type(STREAMPOOL_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLSETUP_TYPE_INFO);
    registry.register_type(STREAMPOOLSETUP_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLPROPERTIES_TYPE_INFO);
    registry.register_type(STREAMPOOLPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(STREAMSTARVEMODE_TYPE_INFO);
    registry.register_type(STREAMSTARVEMODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDASSET_TYPE_INFO);
    registry.register_type(SOUNDASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREFERENCE_TYPE_INFO);
    registry.register_type(SOUNDDATAREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSYSTEMASSET_TYPE_INFO);
    registry.register_type(MIXERSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(MIXERASSET_TYPE_INFO);
    registry.register_type(MIXERASSET_ARRAY_TYPE_INFO);
    registry.register_type(MIXERGRAPHDATA_TYPE_INFO);
    registry.register_type(MIXERGRAPHDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERINPUTINFO_TYPE_INFO);
    registry.register_type(MIXERINPUTINFO_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEACCUMULATEMODE_TYPE_INFO);
    registry.register_type(MIXERVALUEACCUMULATEMODE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERPRESET_TYPE_INFO);
    registry.register_type(MIXERPRESET_ARRAY_TYPE_INFO);
    registry.register_type(MIXERPRESETNODEDATA_TYPE_INFO);
    registry.register_type(MIXERPRESETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERPRESETGROUPDATA_TYPE_INFO);
    registry.register_type(MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYVALUE_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYTYPE_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUP_TYPE_INFO);
    registry.register_type(MIXGROUP_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYPARAMETERS_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPSTATE_TYPE_INFO);
    registry.register_type(MIXGROUPSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUENODEDATA_TYPE_INFO);
    registry.register_type(MIXERVALUENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEUISCALE_TYPE_INFO);
    registry.register_type(MIXERVALUEUISCALE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEUIORIENTATION_TYPE_INFO);
    registry.register_type(MIXERVALUEUIORIENTATION_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEUI_TYPE_INFO);
    registry.register_type(MIXERVALUEUI_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSENDNODECONFIGDATA_TYPE_INFO);
    registry.register_type(MIXERSENDNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODECONFIGDATA_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTRYCONFIG_TYPE_INFO);
    registry.register_type(MIXERENTRYCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSENDNODEDATA_TYPE_INFO);
    registry.register_type(MIXERSENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSENDENTRY_TYPE_INFO);
    registry.register_type(MIXERSENDENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODEDATA_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERRECEIVEENTRY_TYPE_INFO);
    registry.register_type(MIXERRECEIVEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYNODEDATA_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYENTRY_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYNODEDATA_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYENTRY_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSIMPLEPRESETNODEDATA_TYPE_INFO);
    registry.register_type(MIXERSIMPLEPRESETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXEROUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(MIXEROUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXEROUTPUTENTRY_TYPE_INFO);
    registry.register_type(MIXEROUTPUTENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERINPUTNODEDATA_TYPE_INFO);
    registry.register_type(MIXERINPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERINPUTENTRY_TYPE_INFO);
    registry.register_type(MIXERINPUTENTRY_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHVALUEPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHVALUEPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORTGROUP_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORT_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORT_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETER_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETER_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHEVENT_TYPE_INFO);
    registry.register_type(AUDIOGRAPHEVENT_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETER_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(VALUECURVENODEDATA_TYPE_INFO);
    registry.register_type(VALUECURVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUECURVENODEENTRY_TYPE_INFO);
    registry.register_type(VALUECURVENODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLEANDHOLDNODEDATA_TYPE_INFO);
    registry.register_type(SAMPLEANDHOLDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERROUTERNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERROUTERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERROUTERENTRY_TYPE_INFO);
    registry.register_type(PARAMETERROUTERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(KEEPALIVENODEDATA_TYPE_INFO);
    registry.register_type(KEEPALIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEDATA_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCEROUTEVENT_TYPE_INFO);
    registry.register_type(EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERPLAYBACK_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERPLAYBACK_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEVERSION_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(VALUESELECTORNODEDATA_TYPE_INFO);
    registry.register_type(VALUESELECTORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUESELECTORENTRY_TYPE_INFO);
    registry.register_type(VALUESELECTORENTRY_ARRAY_TYPE_INFO);
    registry.register_type(TIMERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(TIMERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(TIMERNODEDATA_TYPE_INFO);
    registry.register_type(TIMERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROGRESSMODE_TYPE_INFO);
    registry.register_type(PROGRESSMODE_ARRAY_TYPE_INFO);
    registry.register_type(TIMERMODE_TYPE_INFO);
    registry.register_type(TIMERMODE_ARRAY_TYPE_INFO);
    registry.register_type(TIMERNODEVERSION_TYPE_INFO);
    registry.register_type(TIMERNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHERNODEDATA_TYPE_INFO);
    registry.register_type(SWITCHERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHERENTRY_TYPE_INFO);
    registry.register_type(SWITCHERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODECONFIGDATA_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODEDATA_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMNODEDATA_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMENTRY_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMNODEDATA_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANGLEUNIT_TYPE_INFO);
    registry.register_type(ANGLEUNIT_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMOPERATION_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMOPERATION_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEGENERATORNODEDATA_TYPE_INFO);
    registry.register_type(SEQUENCEGENERATORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENDNODEDATA_TYPE_INFO);
    registry.register_type(SENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENDENTRY_TYPE_INFO);
    registry.register_type(SENDENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SCALECLAMPNODECONFIGDATA_TYPE_INFO);
    registry.register_type(SCALECLAMPNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCALECLAMPNODEDATA_TYPE_INFO);
    registry.register_type(SCALECLAMPNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTSENDNODEDATA_TYPE_INFO);
    registry.register_type(CONTEXTSENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSENDENTRY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTRECEIVENODEDATA_TYPE_INFO);
    registry.register_type(CONTEXTRECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTRECEIVEENTRY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(RECEIVENODEDATA_TYPE_INFO);
    registry.register_type(RECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECEIVEENTRY_TYPE_INFO);
    registry.register_type(RECEIVEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERCONFIGENTRY_TYPE_INFO);
    registry.register_type(RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODEDATA_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERENTRY_TYPE_INFO);
    registry.register_type(RANGEMAPPERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLINEARNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLINEARNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEVERSION_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEENTRY_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODECONFIGDATA_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEDATA_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORMODE_TYPE_INFO);
    registry.register_type(NUMBERGENERATORMODE_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEVERSION_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERCONFIGGROUP_TYPE_INFO);
    registry.register_type(MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODEDATA_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERGROUP_TYPE_INFO);
    registry.register_type(MULTICROSSFADERGROUP_ARRAY_TYPE_INFO);
    registry.register_type(FADERTYPE_TYPE_INFO);
    registry.register_type(FADERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORNODEDATA_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORENTRY_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MINMAXNODEDATA_TYPE_INFO);
    registry.register_type(MINMAXNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONNODEDATA_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONOPERATOR_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONOPERATOR_ARRAY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONENTRY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDNODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDNODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINEARTRANSFORMNODEDATA_TYPE_INFO);
    registry.register_type(LINEARTRANSFORMNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LFONODEDATA_TYPE_INFO);
    registry.register_type(LFONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWENVELOPENODEDATA_TYPE_INFO);
    registry.register_type(FOLLOWENVELOPENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHERNODEDATA_TYPE_INFO);
    registry.register_type(EVENTSWITCHERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHERENTRY_TYPE_INFO);
    registry.register_type(EVENTSWITCHERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATENODEDATA_TYPE_INFO);
    registry.register_type(EVENTGATENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEDATA_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEENTRY_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(DEMUXNODEDATA_TYPE_INFO);
    registry.register_type(DEMUXNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEMUXOUTPUT_TYPE_INFO);
    registry.register_type(DEMUXOUTPUT_ARRAY_TYPE_INFO);
    registry.register_type(DELTANODEDATA_TYPE_INFO);
    registry.register_type(DELTANODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELTAGROUP_TYPE_INFO);
    registry.register_type(DELTAGROUP_ARRAY_TYPE_INFO);
    registry.register_type(EVENTDEBUGNODEDATA_TYPE_INFO);
    registry.register_type(EVENTDEBUGNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGEVENTINPUT_TYPE_INFO);
    registry.register_type(DEBUGEVENTINPUT_ARRAY_TYPE_INFO);
    registry.register_type(VALUEDEBUGNODEDATA_TYPE_INFO);
    registry.register_type(VALUEDEBUGNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGVALUEINPUT_TYPE_INFO);
    registry.register_type(DEBUGVALUEINPUT_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGRENDERTYPE_TYPE_INFO);
    registry.register_type(DEBUGRENDERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CROSSFADER2NODEDATA_TYPE_INFO);
    registry.register_type(CROSSFADER2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONNODECONFIGDATA_TYPE_INFO);
    registry.register_type(CONDITIONNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONGROUPCONFIG_TYPE_INFO);
    registry.register_type(CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONNODEDATA_TYPE_INFO);
    registry.register_type(CONDITIONNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONGROUP_TYPE_INFO);
    registry.register_type(CONDITIONGROUP_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONTYPE_TYPE_INFO);
    registry.register_type(CONDITIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ADSRNODEDATA_TYPE_INFO);
    registry.register_type(ADSRNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELTOVALUENODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELTOVALUENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERSYSTEMASSET_TYPE_INFO);
    registry.register_type(VOICEOVERSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELARRAY_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATION_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATIONFALLBACK_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_ARRAY_TYPE_INFO);
    registry.register_type(FINALDRAFTMANUSCRIPTASSET_TYPE_INFO);
    registry.register_type(FINALDRAFTMANUSCRIPTASSET_ARRAY_TYPE_INFO);
    registry.register_type(FINALDRAFTLINEINFO_TYPE_INFO);
    registry.register_type(FINALDRAFTLINEINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTASSET_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTASSET_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERWAVENAMETRANSLATION_TYPE_INFO);
    registry.register_type(VOICEOVERWAVENAMETRANSLATION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLANGUAGEROOT_TYPE_INFO);
    registry.register_type(VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICASSET_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICASSET_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGROUP_TYPE_INFO);
    registry.register_type(VOICEOVERGROUP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWCONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOW_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINEROUTPUT_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERPARAMETER_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODE_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINFO_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINTERRUPTMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGGROUP_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGOUTPUTEVENT_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETER_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTRACK_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEMAPPING_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIP_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIPEVENTS_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKE_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERCONDITIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURENODE_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWMODE_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODE_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODE_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELCOMPAREMODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELCOMPAREMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCEMODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCEMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODE_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODE_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODE_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODE_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODE_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVECTORVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVECTORVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTGLOBALVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTGLOBALVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTFLOATVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTFLOATVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTINTEGERVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTINTEGERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTBOOLEANVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTBOOLEANVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODE_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPAREEXPRESSIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODE_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICEXPRESSIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURECONNECTION_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURECONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRELATIONSHIPINPUT_TYPE_INFO);
    registry.register_type(VOICEOVERRELATIONSHIPINPUT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUECONNECTION_TYPE_INFO);
    registry.register_type(VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREXPRESSIONNODE_TYPE_INFO);
    registry.register_type(VOICEOVEREXPRESSIONNODE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYVOICEOVERINFO_TYPE_INFO);
    registry.register_type(ENTITYVOICEOVERINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVAL_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVAL_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABEL_TYPE_INFO);
    registry.register_type(VOICEOVERLABEL_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUEREDIRECT_TYPE_INFO);
    registry.register_type(VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENT_TYPE_INFO);
    registry.register_type(VOICEOVEREVENT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECT_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERNAMEDVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUETYPE_TYPE_INFO);
    registry.register_type(VOICEOVERVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICLAYERENTRY_TYPE_INFO);
    registry.register_type(MUSICLAYERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERENTRY_TYPE_INFO);
    registry.register_type(MUSICPLAYERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDVOICE_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDTARGETPLUGINS_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDPLUGINS_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERPLUGINS_TYPE_INFO);
    registry.register_type(MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(LOADINGMUSICBUNDLEASSET_TYPE_INFO);
    registry.register_type(LOADINGMUSICBUNDLEASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICMARKERTYPE_TYPE_INFO);
    registry.register_type(MUSICMARKERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICFADETYPE_TYPE_INFO);
    registry.register_type(MUSICFADETYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTASSET_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTSELECTOR_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTTYPE_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICASSET_TYPE_INFO);
    registry.register_type(MUSICASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICBASEASSET_TYPE_INFO);
    registry.register_type(MUSICBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICTRANSITION_TYPE_INFO);
    registry.register_type(MUSICTRANSITION_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTORPARAMETER_TYPE_INFO);
    registry.register_type(MUSICSELECTORPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERBOUNDSELECTOR_TYPE_INFO);
    registry.register_type(PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTOR_TYPE_INFO);
    registry.register_type(MUSICSELECTOR_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTORBASE_TYPE_INFO);
    registry.register_type(MUSICSELECTORBASE_ARRAY_TYPE_INFO);
    registry.register_type(OVERLAYCONTROL_TYPE_INFO);
    registry.register_type(OVERLAYCONTROL_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTORTRIGGERTYPE_TYPE_INFO);
    registry.register_type(MUSICSELECTORTRIGGERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICINTERFACEASSET_TYPE_INFO);
    registry.register_type(MUSICINTERFACEASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICOVERLAYDATA_TYPE_INFO);
    registry.register_type(MUSICOVERLAYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICOVERLAYVARIATION_TYPE_INFO);
    registry.register_type(MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPHRASEDATA_TYPE_INFO);
    registry.register_type(MUSICPHRASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSEGMENTDATA_TYPE_INFO);
    registry.register_type(MUSICSEGMENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTITRACKDATA_TYPE_INFO);
    registry.register_type(MULTITRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTITRACKLAYERDATA_TYPE_INFO);
    registry.register_type(MULTITRACKLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SYNCHEDFADEDATA_TYPE_INFO);
    registry.register_type(SYNCHEDFADEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICFADEDATA_TYPE_INFO);
    registry.register_type(BASICFADEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICFADEDATA_TYPE_INFO);
    registry.register_type(MUSICFADEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSYNCTYPE_TYPE_INFO);
    registry.register_type(MUSICSYNCTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSTREAMABLEDATA_TYPE_INFO);
    registry.register_type(MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYABLEDATA_TYPE_INFO);
    registry.register_type(MUSICPLAYABLEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICMETADATACHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(MUSICMETADATABASE_TYPE_INFO);
    registry.register_type(MUSICMETADATABASE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPARAMETERDATA_TYPE_INFO);
    registry.register_type(MUSICPARAMETERDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICEVENTDATA_TYPE_INFO);
    registry.register_type(MUSICEVENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICINPUTDATA_TYPE_INFO);
    registry.register_type(MUSICINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPHRASESELECTIONTYPE_TYPE_INFO);
    registry.register_type(MUSICPHRASESELECTIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTITYDATA_TYPE_INFO);
    registry.register_type(MIXERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITYDATA_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBENTITYDATA_TYPE_INFO);
    registry.register_type(IRREVERBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDMASTERENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDMASTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEASSETOBSERVERENTITYDATA_TYPE_INFO);
    registry.register_type(NEWWAVEASSETOBSERVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEORDER_ARRAY_TYPE_INFO);
    registry.register_type(SCOPESTAGESORTPROPERTY_TYPE_INFO);
    registry.register_type(SCOPESTAGESORTPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(DUPLICATESPAWNSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(DUPLICATESPAWNSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MAXINSTANCESSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(MAXINSTANCESSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYMAPPING_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEINPUTDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPEDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EQUALIZERSETTINGS_TYPE_INFO);
    registry.register_type(EQUALIZERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COMPRESSORSETTINGS_TYPE_INFO);
    registry.register_type(COMPRESSORSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(MASTERUNITSETTINGS_TYPE_INFO);
    registry.register_type(MASTERUNITSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HDRSETTING_TYPE_INFO);
    registry.register_type(HDRSETTING_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHDATA_TYPE_INFO);
    registry.register_type(SOUNDGRAPHDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDBUSDATA_TYPE_INFO);
    registry.register_type(SOUNDBUSDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHINFO_TYPE_INFO);
    registry.register_type(SOUNDGRAPHINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHVOICEINFO_TYPE_INFO);
    registry.register_type(SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHLINKEDPLUGINATTRIBUTE_TYPE_INFO);
    registry.register_type(SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGININFO_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINREF_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONSTRUCTPARAM_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTION_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONTYPE_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONPARAM_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO);
    registry.register_type(FADECURVETYPE_TYPE_INFO);
    registry.register_type(FADECURVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(POINTENVELOPE_TYPE_INFO);
    registry.register_type(POINTENVELOPE_ARRAY_TYPE_INFO);
    registry.register_type(POINTENVELOPEPOINT_TYPE_INFO);
    registry.register_type(POINTENVELOPEPOINT_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGE_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGE_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMSPEAKERSETUP_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMSPEAKERSETUP_ARRAY_TYPE_INFO);
    registry.register_type(BEATDETECTNODEDATA_TYPE_INFO);
    registry.register_type(BEATDETECTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BEATDETECTCAUSALITY_TYPE_INFO);
    registry.register_type(BEATDETECTCAUSALITY_ARRAY_TYPE_INFO);
    registry.register_type(BEATDETECTFRAMESIZE_TYPE_INFO);
    registry.register_type(BEATDETECTFRAMESIZE_ARRAY_TYPE_INFO);
    registry.register_type(MODELREVERBNODEDATA_TYPE_INFO);
    registry.register_type(MODELREVERBNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ACTIVATEMIXERNODEDATA_TYPE_INFO);
    registry.register_type(ACTIVATEMIXERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VUMETERNODEDATA_TYPE_INFO);
    registry.register_type(VUMETERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VUMETERMODE_TYPE_INFO);
    registry.register_type(VUMETERMODE_ARRAY_TYPE_INFO);
    registry.register_type(VIBRATONODEDATA_TYPE_INFO);
    registry.register_type(VIBRATONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODEDATA_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEDATA_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYWAVEASSETREFERENCE_TYPE_INFO);
    registry.register_type(WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRYTYPE_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYCONSTENUM_TYPE_INFO);
    registry.register_type(WAVEQUERYCONSTENUM_ARRAY_TYPE_INFO);
    registry.register_type(VARIATIONSELECTIONOBSERVERNODEDATA_TYPE_INFO);
    registry.register_type(VARIATIONSELECTIONOBSERVERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(USERMUSICCONTROLLERNODEDATA_TYPE_INFO);
    registry.register_type(USERMUSICCONTROLLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(USERMUSICARBITERNODEDATA_TYPE_INFO);
    registry.register_type(USERMUSICARBITERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TIMESTRETCHNODEDATA_TYPE_INFO);
    registry.register_type(TIMESTRETCHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TIMESTRETCHEFFICIENCY_TYPE_INFO);
    registry.register_type(TIMESTRETCHEFFICIENCY_ARRAY_TYPE_INFO);
    registry.register_type(TIMESTRETCHMULTICHANNELMODE_TYPE_INFO);
    registry.register_type(TIMESTRETCHMULTICHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(SAMPLERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODEDATA_TYPE_INFO);
    registry.register_type(SAMPLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODEDEBUGDATA_TYPE_INFO);
    registry.register_type(SAMPLERNODEDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERPOSITIONMODE_TYPE_INFO);
    registry.register_type(SAMPLERPOSITIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLEROFFSETMODE_TYPE_INFO);
    registry.register_type(SAMPLEROFFSETMODE_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERLEADOUT_TYPE_INFO);
    registry.register_type(SAMPLERLEADOUT_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERPLUGINS_TYPE_INFO);
    registry.register_type(SAMPLERPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODEVERSION_TYPE_INFO);
    registry.register_type(SAMPLERNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(ROUTENODEDATA_TYPE_INFO);
    registry.register_type(ROUTENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROUTEENTRY_TYPE_INFO);
    registry.register_type(ROUTEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(ROUTECHANNEL_TYPE_INFO);
    registry.register_type(ROUTECHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBCONTROLLERNODEDATA_TYPE_INFO);
    registry.register_type(IRREVERBCONTROLLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBNODEDATA_TYPE_INFO);
    registry.register_type(IRREVERBNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMFOLDDOWNNODEDATA_TYPE_INFO);
    registry.register_type(PLATFORMFOLDDOWNNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLDDOWNMODE_TYPE_INFO);
    registry.register_type(FOLDDOWNMODE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSNODEDATA_TYPE_INFO);
    registry.register_type(PHYSICSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PAN2DNODEDATA_TYPE_INFO);
    registry.register_type(PAN2DNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PAN2DNODEVERSION_TYPE_INFO);
    registry.register_type(PAN2DNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO);
    registry.register_type(PAN2DOUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSENTRY_TYPE_INFO);
    registry.register_type(PHYSICSENTRY_ARRAY_TYPE_INFO);
    registry.register_type(PEAKINGIIR2NODEDATA_TYPE_INFO);
    registry.register_type(PEAKINGIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEDATA_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEENTRY_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PANSOURCEPOSITIONING_TYPE_INFO);
    registry.register_type(PANSOURCEPOSITIONING_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTREVERBMODE_TYPE_INFO);
    registry.register_type(OUTPUTREVERBMODE_ARRAY_TYPE_INFO);
    registry.register_type(DIRECTOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(DIRECTOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(OUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(OUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTNODEVERSION_TYPE_INFO);
    registry.register_type(OUTPUTNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSFILTERTYPE_TYPE_INFO);
    registry.register_type(LOWPASSFILTERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTTRANSFORMSOURCE_TYPE_INFO);
    registry.register_type(OUTPUTTRANSFORMSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTSNODEDATA_TYPE_INFO);
    registry.register_type(OBJECTSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTNODEDATA_TYPE_INFO);
    registry.register_type(OBJECTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERNODEDATA_TYPE_INFO);
    registry.register_type(MIXERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTRY_TYPE_INFO);
    registry.register_type(MIXERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MATRIXPANNERNODEDATA_TYPE_INFO);
    registry.register_type(MATRIXPANNERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO);
    registry.register_type(MATRIXPANNEROUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO);
    registry.register_type(MASTERUNITNODEDATA_TYPE_INFO);
    registry.register_type(MASTERUNITNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWSHELFIIR2NODEDATA_TYPE_INFO);
    registry.register_type(LOWSHELFIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSIIR2NODEDATA_TYPE_INFO);
    registry.register_type(LOWPASSIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSFIR64NODEDATA_TYPE_INFO);
    registry.register_type(LOWPASSFIR64NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSBUTTERWORTHNODEDATA_TYPE_INFO);
    registry.register_type(LOWPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIMITERNODEDATA_TYPE_INFO);
    registry.register_type(LIMITERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIMITERCHANNELMODE_TYPE_INFO);
    registry.register_type(LIMITERCHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(HIGHSHELFIIR2NODEDATA_TYPE_INFO);
    registry.register_type(HIGHSHELFIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHPASSIIR2NODEDATA_TYPE_INFO);
    registry.register_type(HIGHPASSIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHPASSFIR64NODEDATA_TYPE_INFO);
    registry.register_type(HIGHPASSFIR64NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHPASSBUTTERWORTHNODEDATA_TYPE_INFO);
    registry.register_type(HIGHPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SINEPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(SINEPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAINFADERNODEDATA_TYPE_INFO);
    registry.register_type(GAINFADERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAINFADERFADETYPE_TYPE_INFO);
    registry.register_type(GAINFADERFADETYPE_ARRAY_TYPE_INFO);
    registry.register_type(GAINNODEDATA_TYPE_INFO);
    registry.register_type(GAINNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBNODEDATA_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBFILTER_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBFILTER_ARRAY_TYPE_INFO);
    registry.register_type(FLANGERNODEDATA_TYPE_INFO);
    registry.register_type(FLANGERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENVIRONMENTNODEDATA_TYPE_INFO);
    registry.register_type(ENVIRONMENTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERPLUGINS_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPANDERNODEDATA_TYPE_INFO);
    registry.register_type(EXPANDERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPANDERCHANNELMODE_TYPE_INFO);
    registry.register_type(EXPANDERCHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(DISTORTIONCLIPNODEDATA_TYPE_INFO);
    registry.register_type(DISTORTIONCLIPNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIALOGSAMPLERNODEDATA_TYPE_INFO);
    registry.register_type(DIALOGSAMPLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELAYNODEDATA_TYPE_INFO);
    registry.register_type(DELAYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DACNODEDATA_TYPE_INFO);
    registry.register_type(DACNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CROSSFADERNODEDATA_TYPE_INFO);
    registry.register_type(CROSSFADERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTROLLEROUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(CONTROLLEROUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPRESSORNODEDATA_TYPE_INFO);
    registry.register_type(COMPRESSORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPRESSORCHANNELMODE_TYPE_INFO);
    registry.register_type(COMPRESSORCHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHORUSNODEDATA_TYPE_INFO);
    registry.register_type(CHORUSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUSNODEDATA_TYPE_INFO);
    registry.register_type(BUSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANDPASSIIR2NODEDATA_TYPE_INFO);
    registry.register_type(BANDPASSIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANDPASSFIR64NODEDATA_TYPE_INFO);
    registry.register_type(BANDPASSFIR64NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALLPASSNODEDATA_TYPE_INFO);
    registry.register_type(ALLPASSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFFWRITERNODEDATA_TYPE_INFO);
    registry.register_type(AIFFWRITERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PANNORMALIZATIONMODE_TYPE_INFO);
    registry.register_type(PANNORMALIZATIONMODE_ARRAY_TYPE_INFO);
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundMasterEntity {
}

pub const SOUNDMASTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDMASTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundMasterEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDMASTERENTITY_TYPE_INFO
    }
}


pub const SOUNDMASTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundMasterEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundHdrEntity {
}

pub const SOUNDHDRENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDHDRENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundHdrEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDHDRENTITY_TYPE_INFO
    }
}


pub const SOUNDHDRENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundHdrEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntity {
}

pub const SOUNDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITY_TYPE_INFO
    }
}


pub const SOUNDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundDataEntity {
}

pub const SOUNDDATAENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDDATAENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundDataEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAENTITY_TYPE_INFO
    }
}


pub const SOUNDDATAENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundContextLinkEntity {
}

pub const SOUNDCONTEXTLINKENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTLINKENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundContextLinkEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTLINKENTITY_TYPE_INFO
    }
}


pub const SOUNDCONTEXTLINKENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextLinkEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundContextEntity {
}

pub const SOUNDCONTEXTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundContextEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTENTITY_TYPE_INFO
    }
}


pub const SOUNDCONTEXTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct LoadingMusicEntity {
}

pub const LOADINGMUSICENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(LOADINGMUSICENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LoadingMusicEntity {
    fn type_info() -> &'static TypeInfo {
        LOADINGMUSICENTITY_TYPE_INFO
    }
}


pub const LOADINGMUSICENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LoadingMusicEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct IrReverbEntity {
}

pub const IRREVERBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(IRREVERBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IrReverbEntity {
    fn type_info() -> &'static TypeInfo {
        IRREVERBENTITY_TYPE_INFO
    }
}


pub const IRREVERBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntityTrack {
}

pub const SOUNDENTITYTRACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrack",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TIMELINETRACK_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACK_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrack {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACK_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrack-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrack-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntityTrackParameterLayer {
}

pub const SOUNDENTITYTRACKPARAMETERLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKPARAMETERLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackParameterLayer {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKPARAMETERLAYER_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKPARAMETERLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackParameterLayer-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntityTrackAssetLayer {
}

pub const SOUNDENTITYTRACKASSETLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKASSETLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackAssetLayer {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKASSETLAYER_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKASSETLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackAssetLayer-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntityTrackEventLayer {
}

pub const SOUNDENTITYTRACKEVENTLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKEVENTLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackEventLayer {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKEVENTLAYER_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKEVENTLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackEventLayer-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntityTrackLayer {
}

pub const SOUNDENTITYTRACKLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TIMELINETRACK_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackLayer {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKLAYER_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackLayer-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConversationGroupEntity {
}

pub const VOICEOVERCONVERSATIONGROUPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONGROUPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VoiceOverConversationGroupEntity {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONGROUPENTITY_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONGROUPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationGroupEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeSetupEntity {
}

pub const SOUNDSCOPESETUPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDSCOPESETUPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundScopeSetupEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPESETUPENTITY_TYPE_INFO
    }
}


pub const SOUNDSCOPESETUPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeSetupEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundPauseEntity {
}

pub const SOUNDPAUSEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDPAUSEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundPauseEntity {
    fn type_info() -> &'static TypeInfo {
        SOUNDPAUSEENTITY_TYPE_INFO
    }
}


pub const SOUNDPAUSEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPauseEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MixerEntity {
}

pub const MIXERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITY_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(MIXERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MixerEntity {
    fn type_info() -> &'static TypeInfo {
        MIXERENTITY_TYPE_INFO
    }
}


pub const MIXERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntity-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NewWaveResource {
}

pub const NEWWAVERESOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveResource",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        fields: &[
        ],
    }),
    array_type: Some(NEWWAVERESOURCE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for NewWaveResource {
    fn type_info() -> &'static TypeInfo {
        NEWWAVERESOURCE_TYPE_INFO
    }
}


pub const NEWWAVERESOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveResource-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveResource-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NewWaveReportingAsset {
    pub new_wave_debug_asset_uri: String,
}

pub const NEWWAVEREPORTINGASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveReportingAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "NewWaveDebugAssetUri",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(NewWaveReportingAsset, new_wave_debug_asset_uri),
            },
        ],
    }),
    array_type: Some(NEWWAVEREPORTINGASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveReportingAsset {
    fn type_info() -> &'static TypeInfo {
        NEWWAVEREPORTINGASSET_TYPE_INFO
    }
}


pub const NEWWAVEREPORTINGASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveReportingAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveReportingAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NewWaveDebugAsset {
    pub variations: Vec<NewWaveVariationDebugData>,
}

pub const NEWWAVEDEBUGASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveDebugAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Variations",
                flags: MemberInfoFlags::new(144),
                field_type: NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(NewWaveDebugAsset, variations),
            },
        ],
    }),
    array_type: Some(NEWWAVEDEBUGASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveDebugAsset {
    fn type_info() -> &'static TypeInfo {
        NEWWAVEDEBUGASSET_TYPE_INFO
    }
}


pub const NEWWAVEDEBUGASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveDebugAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveDebugAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NewWaveVariationDebugData {
    pub id: u32,
    pub partition_guid: super::core::Guid,
    pub instance_guid: super::core::Guid,
}

pub const NEWWAVEVARIATIONDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveVariationDebugData",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(NewWaveVariationDebugData, id),
            },
            FieldInfoData {
                name: "PartitionGuid",
                flags: MemberInfoFlags::new(0),
                field_type: GUID_TYPE_INFO,
                rust_offset: offset_of!(NewWaveVariationDebugData, partition_guid),
            },
            FieldInfoData {
                name: "InstanceGuid",
                flags: MemberInfoFlags::new(0),
                field_type: GUID_TYPE_INFO,
                rust_offset: offset_of!(NewWaveVariationDebugData, instance_guid),
            },
        ],
    }),
    array_type: Some(NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NewWaveVariationDebugData {
    fn type_info() -> &'static TypeInfo {
        NEWWAVEVARIATIONDEBUGDATA_TYPE_INFO
    }
}


pub const NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveVariationDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveVariationDebugData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LocalizedWaveAsset {
}

pub const LOCALIZEDWAVEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalizedWaveAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(NEWWAVEASSET_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(LOCALIZEDWAVEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalizedWaveAsset {
    fn type_info() -> &'static TypeInfo {
        LOCALIZEDWAVEASSET_TYPE_INFO
    }
}


pub const LOCALIZEDWAVEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalizedWaveAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LocalizedWaveAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct NewWaveAsset {
    pub default_selection_group: NewWaveSelectionGroup,
    pub is_seekable: bool,
    pub selection_parameter_count: u8,
    pub control_parameter_count: u8,
}

pub const NEWWAVEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDWAVEASSETBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DefaultSelectionGroup",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVESELECTIONGROUP_TYPE_INFO,
                rust_offset: offset_of!(NewWaveAsset, default_selection_group),
            },
            FieldInfoData {
                name: "IsSeekable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(NewWaveAsset, is_seekable),
            },
            FieldInfoData {
                name: "SelectionParameterCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(NewWaveAsset, selection_parameter_count),
            },
            FieldInfoData {
                name: "ControlParameterCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(NewWaveAsset, control_parameter_count),
            },
        ],
    }),
    array_type: Some(NEWWAVEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveAsset {
    fn type_info() -> &'static TypeInfo {
        NEWWAVEASSET_TYPE_INFO
    }
}


pub const NEWWAVEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundWaveAsset {
    pub runtime_variations: Vec<SoundWaveRuntimeVariation>,
    pub localization: Vec<SoundWaveLocalizationInfo>,
    pub subtitle_string_ids: Vec<String>,
    pub subtitles: Vec<SoundWaveSubtitle>,
    pub selection: SoundWaveVariationSelection,
    pub seekable: bool,
    pub variation_history_count: u8,
    pub persistent_variation_count: u8,
    pub additional_subtitle_info_type: i32,
    pub segments: Vec<SoundWaveVariationSegment>,
}

pub const SOUNDWAVEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDWAVEASSETBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RuntimeVariations",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, runtime_variations),
            },
            FieldInfoData {
                name: "Localization",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, localization),
            },
            FieldInfoData {
                name: "SubtitleStringIds",
                flags: MemberInfoFlags::new(144),
                field_type: CSTRING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, subtitle_string_ids),
            },
            FieldInfoData {
                name: "Subtitles",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, subtitles),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEVARIATIONSELECTION_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, selection),
            },
            FieldInfoData {
                name: "Seekable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, seekable),
            },
            FieldInfoData {
                name: "VariationHistoryCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, variation_history_count),
            },
            FieldInfoData {
                name: "PersistentVariationCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, persistent_variation_count),
            },
            FieldInfoData {
                name: "AdditionalSubtitleInfoType",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, additional_subtitle_info_type),
            },
            FieldInfoData {
                name: "Segments",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAsset, segments),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVEASSET_TYPE_INFO
    }
}


pub const SOUNDWAVEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundWaveAssetBase {
    pub stream_pool: StreamPool,
    pub prefer_available_variations: bool,
    pub streaming_mode: u8,
    pub voice_priority: u8,
    pub channel_count: u8,
}

pub const SOUNDWAVEASSETBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAssetBase",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDDATAASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "StreamPool",
                flags: MemberInfoFlags::new(0),
                field_type: STREAMPOOL_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAssetBase, stream_pool),
            },
            FieldInfoData {
                name: "PreferAvailableVariations",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAssetBase, prefer_available_variations),
            },
            FieldInfoData {
                name: "StreamingMode",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAssetBase, streaming_mode),
            },
            FieldInfoData {
                name: "VoicePriority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAssetBase, voice_priority),
            },
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveAssetBase, channel_count),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveAssetBase {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVEASSETBASE_TYPE_INFO
    }
}


pub const SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAssetBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveAssetBase-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundWaveStreamingMode {
    #[default]
    SoundWaveStreamingMode_Normal = 0,
    SoundWaveStreamingMode_ZeroLatency = 1,
    SoundWaveStreamingMode_LowLatency = 2,
}

pub const SOUNDWAVESTREAMINGMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveStreamingMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDWAVESTREAMINGMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundWaveStreamingMode {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVESTREAMINGMODE_TYPE_INFO
    }
}


pub const SOUNDWAVESTREAMINGMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveStreamingMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveStreamingMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundWaveLocalizationInfo {
    pub language: AudioLanguage,
    pub first_variation_index: u16,
    pub variation_count: u16,
}

pub const SOUNDWAVELOCALIZATIONINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveLocalizationInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Language",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveLocalizationInfo, language),
            },
            FieldInfoData {
                name: "FirstVariationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveLocalizationInfo, first_variation_index),
            },
            FieldInfoData {
                name: "VariationCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveLocalizationInfo, variation_count),
            },
        ],
    }),
    array_type: Some(SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveLocalizationInfo {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVELOCALIZATIONINFO_TYPE_INFO
    }
}


pub const SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveLocalizationInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveLocalizationInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundWaveRuntimeVariation {
    pub persistent_data_size: u32,
    pub first_subtitle_index: u8,
    pub subtitle_count: u8,
    pub first_segment_index: u16,
    pub segment_count: u8,
    pub chunk_index: u8,
    pub first_loop_segment_index: u8,
    pub last_loop_segment_index: u8,
    pub weight: u8,
}

pub const SOUNDWAVERUNTIMEVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveRuntimeVariation",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "PersistentDataSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, persistent_data_size),
            },
            FieldInfoData {
                name: "FirstSubtitleIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, first_subtitle_index),
            },
            FieldInfoData {
                name: "SubtitleCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, subtitle_count),
            },
            FieldInfoData {
                name: "FirstSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, first_segment_index),
            },
            FieldInfoData {
                name: "SegmentCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, segment_count),
            },
            FieldInfoData {
                name: "ChunkIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, chunk_index),
            },
            FieldInfoData {
                name: "FirstLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, first_loop_segment_index),
            },
            FieldInfoData {
                name: "LastLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, last_loop_segment_index),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveRuntimeVariation, weight),
            },
        ],
    }),
    array_type: Some(SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundWaveRuntimeVariation {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVERUNTIMEVARIATION_TYPE_INFO
    }
}


pub const SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveRuntimeVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveRuntimeVariation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundWaveVariation {
    pub subtitles: Vec<SoundWaveSubtitle>,
    pub weight: u8,
    pub segments: Vec<SoundWaveVariationSegment>,
    pub persistent_data_size: u32,
    pub chunk_index: u8,
    pub first_loop_segment_index: u8,
    pub last_loop_segment_index: u8,
}

pub const SOUNDWAVEVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariation",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Subtitles",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, subtitles),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, weight),
            },
            FieldInfoData {
                name: "Segments",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, segments),
            },
            FieldInfoData {
                name: "PersistentDataSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, persistent_data_size),
            },
            FieldInfoData {
                name: "ChunkIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, chunk_index),
            },
            FieldInfoData {
                name: "FirstLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, first_loop_segment_index),
            },
            FieldInfoData {
                name: "LastLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariation, last_loop_segment_index),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveVariation {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVEVARIATION_TYPE_INFO
    }
}


pub const SOUNDWAVEVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVariation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundWaveSubtitle {
    pub string_index: u8,
    pub time: f32,
    pub additional_subtitle_info_type: i32,
}

pub const SOUNDWAVESUBTITLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveSubtitle",
    flags: MemberInfoFlags::new(32841),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "StringIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveSubtitle, string_index),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveSubtitle, time),
            },
            FieldInfoData {
                name: "AdditionalSubtitleInfoType",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveSubtitle, additional_subtitle_info_type),
            },
        ],
    }),
    array_type: Some(SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundWaveSubtitle {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVESUBTITLE_TYPE_INFO
    }
}


pub const SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveSubtitle-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveSubtitle-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundWaveVariationSegment {
    pub samples_offset: u32,
    pub seek_table_offset: u32,
    pub segment_length: f32,
}

pub const SOUNDWAVEVARIATIONSEGMENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSegment",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SamplesOffset",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariationSegment, samples_offset),
            },
            FieldInfoData {
                name: "SeekTableOffset",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariationSegment, seek_table_offset),
            },
            FieldInfoData {
                name: "SegmentLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundWaveVariationSegment, segment_length),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundWaveVariationSegment {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVEVARIATIONSEGMENT_TYPE_INFO
    }
}


pub const SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSegment-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVariationSegment-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundWaveVariationSelection {
    #[default]
    SoundWaveVariationSelection_Sequential = 0,
    SoundWaveVariationSelection_Random = 1,
    SoundWaveVariationSelection_Shuffle = 2,
    SoundWaveVariationSelection_WeightedShuffle = 3,
    SoundWaveVariationSelection_WeightedRandom = 4,
}

pub const SOUNDWAVEVARIATIONSELECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSelection",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDWAVEVARIATIONSELECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundWaveVariationSelection {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVEVARIATIONSELECTION_TYPE_INFO
    }
}


pub const SOUNDWAVEVARIATIONSELECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSelection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVariationSelection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundWaveVoicePriority {
    #[default]
    SoundWaveVoicePriority_Low = 0,
    SoundWaveVoicePriority_Medium = 1,
    SoundWaveVoicePriority_Normal = 2,
    SoundWaveVoicePriority_High = 3,
    SoundWaveVoicePriority_Permanent = 4,
}

pub const SOUNDWAVEVOICEPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVoicePriority",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDWAVEVOICEPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundWaveVoicePriority {
    fn type_info() -> &'static TypeInfo {
        SOUNDWAVEVOICEPRIORITY_TYPE_INFO
    }
}


pub const SOUNDWAVEVOICEPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVoicePriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVoicePriority-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundDataAsset {
    pub chunks: Vec<SoundDataChunk>,
    pub policy: SoundDataPolicy,
    pub prime_priority: u8,
    pub request_priority: u8,
}

pub const SOUNDDATAASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Chunks",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDDATACHUNK_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundDataAsset, chunks),
            },
            FieldInfoData {
                name: "Policy",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDDATAPOLICY_TYPE_INFO,
                rust_offset: offset_of!(SoundDataAsset, policy),
            },
            FieldInfoData {
                name: "PrimePriority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundDataAsset, prime_priority),
            },
            FieldInfoData {
                name: "RequestPriority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundDataAsset, request_priority),
            },
        ],
    }),
    array_type: Some(SOUNDDATAASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAASSET_TYPE_INFO
    }
}


pub const SOUNDDATAASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundDataPolicy {
    pub name: String,
    pub request_behavior: SoundDataRequestBehavior,
    pub release_behavior: SoundDataReleaseBehavior,
    pub prime_target: SoundDataReadTarget,
    pub request_target: SoundDataReadTarget,
}

pub const SOUNDDATAPOLICY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPolicy",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundDataPolicy, name),
            },
            FieldInfoData {
                name: "RequestBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(SoundDataPolicy, request_behavior),
            },
            FieldInfoData {
                name: "ReleaseBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDDATARELEASEBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(SoundDataPolicy, release_behavior),
            },
            FieldInfoData {
                name: "PrimeTarget",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDDATAREADTARGET_TYPE_INFO,
                rust_offset: offset_of!(SoundDataPolicy, prime_target),
            },
            FieldInfoData {
                name: "RequestTarget",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDDATAREADTARGET_TYPE_INFO,
                rust_offset: offset_of!(SoundDataPolicy, request_target),
            },
        ],
    }),
    array_type: Some(SOUNDDATAPOLICY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataPolicy {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAPOLICY_TYPE_INFO
    }
}


pub const SOUNDDATAPOLICY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPolicy-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataPolicy-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataReadTarget {
    #[default]
    SoundDataReadTarget_Primary = 0,
    SoundDataReadTarget_Secondary = 1,
}

pub const SOUNDDATAREADTARGET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadTarget",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREADTARGET_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataReadTarget {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAREADTARGET_TYPE_INFO
    }
}


pub const SOUNDDATAREADTARGET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadTarget-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReadTarget-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataReleaseBehavior {
    #[default]
    SoundDataReleaseBehavior_Explicit = 0,
    SoundDataReleaseBehavior_Bundle = 1,
    SoundDataReleaseBehavior_Inactive = 2,
}

pub const SOUNDDATARELEASEBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReleaseBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATARELEASEBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataReleaseBehavior {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATARELEASEBEHAVIOR_TYPE_INFO
    }
}


pub const SOUNDDATARELEASEBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReleaseBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReleaseBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataRequestBehavior {
    #[default]
    SoundDataRequestBehavior_Explicit = 0,
    SoundDataRequestBehavior_Bundle = 1,
}

pub const SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREQUESTBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataRequestBehavior {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO
    }
}


pub const SOUNDDATAREQUESTBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataRequestBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundDataChunk {
    pub chunk_id: super::core::Guid,
    pub chunk_size: u32,
}

pub const SOUNDDATACHUNK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataChunk",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "ChunkId",
                flags: MemberInfoFlags::new(0),
                field_type: GUID_TYPE_INFO,
                rust_offset: offset_of!(SoundDataChunk, chunk_id),
            },
            FieldInfoData {
                name: "ChunkSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundDataChunk, chunk_size),
            },
        ],
    }),
    array_type: Some(SOUNDDATACHUNK_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundDataChunk {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATACHUNK_TYPE_INFO
    }
}


pub const SOUNDDATACHUNK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataChunk-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataChunk-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataState {
    #[default]
    SoundDataState_Unavailable = 0,
    SoundDataState_Pending = 1,
    SoundDataState_Cancelled = 2,
    SoundDataState_Lost = 3,
    SoundDataState_Valid = 4,
}

pub const SOUNDDATASTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataState",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATASTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataState {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATASTATE_TYPE_INFO
    }
}


pub const SOUNDDATASTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataState-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataRequestResult {
    #[default]
    SoundDataRequestResult_NotRequested = 0,
    SoundDataRequestResult_Requested = 1,
    SoundDataRequestResult_Available = 2,
}

pub const SOUNDDATAREQUESTRESULT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestResult",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREQUESTRESULT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataRequestResult {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAREQUESTRESULT_TYPE_INFO
    }
}


pub const SOUNDDATAREQUESTRESULT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestResult-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataRequestResult-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataPrimeResult {
    #[default]
    SoundDataPrimeResult_Failed = 0,
    SoundDataPrimeResult_NoData = 1,
    SoundDataPrimeResult_Requested = 2,
    SoundDataPrimeResult_Available = 3,
}

pub const SOUNDDATAPRIMERESULT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPrimeResult",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAPRIMERESULT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataPrimeResult {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAPRIMERESULT_TYPE_INFO
    }
}


pub const SOUNDDATAPRIMERESULT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPrimeResult-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataPrimeResult-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundDataReadPriority {
    #[default]
    SoundDataReadPriority_Low = 0,
    SoundDataReadPriority_Medium = 1,
    SoundDataReadPriority_Normal = 2,
    SoundDataReadPriority_High = 3,
}

pub const SOUNDDATAREADPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadPriority",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREADPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataReadPriority {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAREADPRIORITY_TYPE_INFO
    }
}


pub const SOUNDDATAREADPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadPriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReadPriority-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundContextSystemAsset {
    pub contexts: Vec<SoundContextData>,
    pub context_groups: Vec<SoundContextGroupData>,
}

pub const SOUNDCONTEXTSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Contexts",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDCONTEXTDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundContextSystemAsset, contexts),
            },
            FieldInfoData {
                name: "ContextGroups",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundContextSystemAsset, context_groups),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextSystemAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTSYSTEMASSET_TYPE_INFO
    }
}


pub const SOUNDCONTEXTSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextSystemAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundContextGroupData {
    pub name: String,
    pub interactions: Vec<SoundContextInteractionData>,
    pub group_type: SoundContextGroupType,
    pub geometry_id: Vec<u32>,
    pub radius: f32,
    pub render_debug: bool,
}

pub const SOUNDCONTEXTGROUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundContextGroupData, name),
            },
            FieldInfoData {
                name: "Interactions",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundContextGroupData, interactions),
            },
            FieldInfoData {
                name: "GroupType",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTGROUPTYPE_TYPE_INFO,
                rust_offset: offset_of!(SoundContextGroupData, group_type),
            },
            FieldInfoData {
                name: "GeometryId",
                flags: MemberInfoFlags::new(144),
                field_type: UINT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundContextGroupData, geometry_id),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundContextGroupData, radius),
            },
            FieldInfoData {
                name: "RenderDebug",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundContextGroupData, render_debug),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextGroupData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTGROUPDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextGroupData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundContextGroupType {
    #[default]
    SoundContextGroupType_Global = 0,
    SoundContextGroupType_Point = 1,
    SoundContextGroupType_Simple = 2,
    SoundContextGroupType_Geometric = 3,
    SoundContextGroupType_Count = 4,
}

pub const SOUNDCONTEXTGROUPTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDCONTEXTGROUPTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundContextGroupType {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTGROUPTYPE_TYPE_INFO
    }
}


pub const SOUNDCONTEXTGROUPTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextGroupType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundContextInteractionData {
    pub context: SoundContextData,
    pub interaction_mode: SoundContextInteractionMode,
    pub accumulation: SoundContextAccumulationData,
    pub bindings: Vec<SoundContextBindingData>,
    pub execute_all_bindings: bool,
    pub relevance_decay: f32,
    pub priority: u32,
    pub keep_last_value: bool,
}

pub const SOUNDCONTEXTINTERACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, context),
            },
            FieldInfoData {
                name: "InteractionMode",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, interaction_mode),
            },
            FieldInfoData {
                name: "Accumulation",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, accumulation),
            },
            FieldInfoData {
                name: "Bindings",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, bindings),
            },
            FieldInfoData {
                name: "ExecuteAllBindings",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, execute_all_bindings),
            },
            FieldInfoData {
                name: "RelevanceDecay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, relevance_decay),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, priority),
            },
            FieldInfoData {
                name: "KeepLastValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundContextInteractionData, keep_last_value),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextInteractionData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTINTERACTIONDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextInteractionData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundContextInteractionMode {
    #[default]
    SoundContextInteractionMode_Import = 0,
    SoundContextInteractionMode_Export = 1,
    SoundContextInteractionMode_Dynamic = 2,
}

pub const SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDCONTEXTINTERACTIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundContextInteractionMode {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO
    }
}


pub const SOUNDCONTEXTINTERACTIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextInteractionMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct PrioritySoundContextAccumulationData {
    pub mode: PrioritySoundContextAccumulationMode,
}

pub const PRIORITYSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO,
                rust_offset: offset_of!(PrioritySoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(PRIORITYSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PrioritySoundContextAccumulationData {
    fn type_info() -> &'static TypeInfo {
        PRIORITYSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
}


pub const PRIORITYSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PrioritySoundContextAccumulationData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum PrioritySoundContextAccumulationMode {
    #[default]
    PrioritySoundContextAccumulationMode_Highest = 0,
    PrioritySoundContextAccumulationMode_Lowest = 1,
}

pub const PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PRIORITYSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PrioritySoundContextAccumulationMode {
    fn type_info() -> &'static TypeInfo {
        PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
}


pub const PRIORITYSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PrioritySoundContextAccumulationMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct LogicSoundContextAccumulationData {
    pub mode: LogicSoundContextAccumulationMode,
}

pub const LOGICSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO,
                rust_offset: offset_of!(LogicSoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(LOGICSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicSoundContextAccumulationData {
    fn type_info() -> &'static TypeInfo {
        LOGICSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
}


pub const LOGICSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicSoundContextAccumulationData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum LogicSoundContextAccumulationMode {
    #[default]
    LogicSoundContextAccumulationMode_Or = 0,
    LogicSoundContextAccumulationMode_And = 1,
}

pub const LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LOGICSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LogicSoundContextAccumulationMode {
    fn type_info() -> &'static TypeInfo {
        LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
}


pub const LOGICSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicSoundContextAccumulationMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct OrderSoundContextAccumulationData {
    pub mode: OrderSoundContextAccumulationMode,
}

pub const ORDERSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO,
                rust_offset: offset_of!(OrderSoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(ORDERSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrderSoundContextAccumulationData {
    fn type_info() -> &'static TypeInfo {
        ORDERSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
}


pub const ORDERSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrderSoundContextAccumulationData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum OrderSoundContextAccumulationMode {
    #[default]
    OrderSoundContextAccumulationMode_Newest = 0,
    OrderSoundContextAccumulationMode_Oldest = 1,
}

pub const ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(ORDERSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OrderSoundContextAccumulationMode {
    fn type_info() -> &'static TypeInfo {
        ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
}


pub const ORDERSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrderSoundContextAccumulationMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MathSoundContextAccumulationData {
    pub mode: MathSoundContextAccumulationMode,
}

pub const MATHSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO,
                rust_offset: offset_of!(MathSoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(MATHSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathSoundContextAccumulationData {
    fn type_info() -> &'static TypeInfo {
        MATHSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
}


pub const MATHSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MathSoundContextAccumulationData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MathSoundContextAccumulationMode {
    #[default]
    MathSoundContextAccumulationMode_Multiply = 0,
    MathSoundContextAccumulationMode_Add = 1,
    MathSoundContextAccumulationMode_Min = 2,
    MathSoundContextAccumulationMode_Max = 3,
}

pub const MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MATHSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathSoundContextAccumulationMode {
    fn type_info() -> &'static TypeInfo {
        MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
}


pub const MATHSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MathSoundContextAccumulationMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundContextAccumulationData {
}

pub const SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextAccumulationData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextAccumulationData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ObstructionSoundContextBindingData {
}

pub const OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObstructionSoundContextBindingData {
    fn type_info() -> &'static TypeInfo {
        OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
}


pub const OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObstructionSoundContextBindingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SpatialSoundContextBindingData {
    pub must_encapsulate: bool,
}

pub const SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialSoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTBINDINGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MustEncapsulate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SpatialSoundContextBindingData, must_encapsulate),
            },
        ],
    }),
    array_type: Some(SPATIALSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpatialSoundContextBindingData {
    fn type_info() -> &'static TypeInfo {
        SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
}


pub const SPATIALSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialSoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SpatialSoundContextBindingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct LinkedSoundContextBindingData {
}

pub const LINKEDSOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedSoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTBINDINGDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(LINKEDSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkedSoundContextBindingData {
    fn type_info() -> &'static TypeInfo {
        LINKEDSOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
}


pub const LINKEDSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedSoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkedSoundContextBindingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundContextBindingData {
}

pub const SOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextBindingData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextBindingData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ObstructionSoundContextData {
}

pub const OBSTRUCTIONSOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(OBSTRUCTIONSOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObstructionSoundContextData {
    fn type_info() -> &'static TypeInfo {
        OBSTRUCTIONSOUNDCONTEXTDATA_TYPE_INFO
    }
}


pub const OBSTRUCTIONSOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObstructionSoundContextData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct EventSoundContextData {
}

pub const EVENTSOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(EVENTSOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSoundContextData {
    fn type_info() -> &'static TypeInfo {
        EVENTSOUNDCONTEXTDATA_TYPE_INFO
    }
}


pub const EVENTSOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSoundContextData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ValueSoundContextData {
    pub default_value: f32,
}

pub const VALUESOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ValueSoundContextData, default_value),
            },
        ],
    }),
    array_type: Some(VALUESOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueSoundContextData {
    fn type_info() -> &'static TypeInfo {
        VALUESOUNDCONTEXTDATA_TYPE_INFO
    }
}


pub const VALUESOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueSoundContextData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundContextData {
    pub name: String,
}

pub const SOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundContextData, name),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioSettings {
    pub enable: bool,
    pub data_manager_cache_size: u32,
    pub data_manager_cache_rsx_size: u32,
    pub data_manager_max_read_issue_count: u32,
    pub data_manager_max_read_active_count: u32,
    pub data_manager_max_trim_size: u32,
    pub data_manager_allow_chunk_loads_while_load_screen_active: bool,
    pub data_manager_allow_chunk_loads_while_loading_bundles: bool,
    pub audio_core_cpu_load_limit: f32,
    pub audio_core_cpu_load_recovery: f32,
    pub audio_core_thread: i32,
    pub audio_core_thread_priority: i32,
    pub audio_core_mix_job_thread_count: i32,
    pub audio_core_max_mix_job_thread_count: i32,
    pub audio_core_multiple_mix_jobs_enabled: bool,
    pub audio_core_min_proc_stage_voices_to_go_wide: i32,
    pub audio_core_apu_heap_size_cached: u32,
    pub audio_core_apu_heap_size_non_cached: u32,
    pub audio_core_minium_mix_ahead: f32,
    pub audio_core_target_mix_ahead: f32,
    pub audio_core_max_channel_count: u32,
    pub delay_line_alloc_size: u32,
    pub reverb_alloc_size: u32,
    pub hdr_suspension_threshold: f32,
    pub hdr_zombie_threshold: f32,
    pub hdr_enable_suspension_threshold: f32,
    pub sound_speed: f32,
    pub sound_doppler_factor: f32,
    pub sound_pitch_smooth_factor: f32,
    pub pan_distance_clamp: bool,
    pub pan_distance_clamp_value: f32,
    pub music_request_buffer_time: f32,
    pub dac_delay: u32,
    pub dac_amplitude: f32,
    pub max_expected_wave_asset_count: u32,
}

pub const AUDIOSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, enable),
            },
            FieldInfoData {
                name: "DataManagerCacheSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_cache_size),
            },
            FieldInfoData {
                name: "DataManagerCacheRsxSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_cache_rsx_size),
            },
            FieldInfoData {
                name: "DataManagerMaxReadIssueCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_max_read_issue_count),
            },
            FieldInfoData {
                name: "DataManagerMaxReadActiveCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_max_read_active_count),
            },
            FieldInfoData {
                name: "DataManagerMaxTrimSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_max_trim_size),
            },
            FieldInfoData {
                name: "DataManagerAllowChunkLoadsWhileLoadScreenActive",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_allow_chunk_loads_while_load_screen_active),
            },
            FieldInfoData {
                name: "DataManagerAllowChunkLoadsWhileLoadingBundles",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, data_manager_allow_chunk_loads_while_loading_bundles),
            },
            FieldInfoData {
                name: "AudioCoreCpuLoadLimit",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_cpu_load_limit),
            },
            FieldInfoData {
                name: "AudioCoreCpuLoadRecovery",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_cpu_load_recovery),
            },
            FieldInfoData {
                name: "AudioCoreThread",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_thread),
            },
            FieldInfoData {
                name: "AudioCoreThreadPriority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_thread_priority),
            },
            FieldInfoData {
                name: "AudioCoreMixJobThreadCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_mix_job_thread_count),
            },
            FieldInfoData {
                name: "AudioCoreMaxMixJobThreadCount",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_max_mix_job_thread_count),
            },
            FieldInfoData {
                name: "AudioCoreMultipleMixJobsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_multiple_mix_jobs_enabled),
            },
            FieldInfoData {
                name: "AudioCoreMinProcStageVoicesToGoWide",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_min_proc_stage_voices_to_go_wide),
            },
            FieldInfoData {
                name: "AudioCoreApuHeapSizeCached",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_apu_heap_size_cached),
            },
            FieldInfoData {
                name: "AudioCoreApuHeapSizeNonCached",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_apu_heap_size_non_cached),
            },
            FieldInfoData {
                name: "AudioCoreMiniumMixAhead",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_minium_mix_ahead),
            },
            FieldInfoData {
                name: "AudioCoreTargetMixAhead",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_target_mix_ahead),
            },
            FieldInfoData {
                name: "AudioCoreMaxChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, audio_core_max_channel_count),
            },
            FieldInfoData {
                name: "DelayLineAllocSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, delay_line_alloc_size),
            },
            FieldInfoData {
                name: "ReverbAllocSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, reverb_alloc_size),
            },
            FieldInfoData {
                name: "HdrSuspensionThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, hdr_suspension_threshold),
            },
            FieldInfoData {
                name: "HdrZombieThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, hdr_zombie_threshold),
            },
            FieldInfoData {
                name: "HdrEnableSuspensionThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, hdr_enable_suspension_threshold),
            },
            FieldInfoData {
                name: "SoundSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, sound_speed),
            },
            FieldInfoData {
                name: "SoundDopplerFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, sound_doppler_factor),
            },
            FieldInfoData {
                name: "SoundPitchSmoothFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, sound_pitch_smooth_factor),
            },
            FieldInfoData {
                name: "PanDistanceClamp",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, pan_distance_clamp),
            },
            FieldInfoData {
                name: "PanDistanceClampValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, pan_distance_clamp_value),
            },
            FieldInfoData {
                name: "MusicRequestBufferTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, music_request_buffer_time),
            },
            FieldInfoData {
                name: "DacDelay",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, dac_delay),
            },
            FieldInfoData {
                name: "DacAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, dac_amplitude),
            },
            FieldInfoData {
                name: "MaxExpectedWaveAssetCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSettings, max_expected_wave_asset_count),
            },
        ],
    }),
    array_type: Some(AUDIOSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioSettings {
    fn type_info() -> &'static TypeInfo {
        AUDIOSETTINGS_TYPE_INFO
    }
}


pub const AUDIOSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundPatchConfigurationDebugData {
    pub solo_output_nodes: Vec<AudioGraphNodeData>,
}

pub const SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationDebugData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SoloOutputNodes",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationDebugData, solo_output_nodes),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHCONFIGURATIONDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchConfigurationDebugData {
    fn type_info() -> &'static TypeInfo {
        SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO
    }
}


pub const SOUNDPATCHCONFIGURATIONDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchConfigurationDebugData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundPatchConfigurationAsset {
    pub sound: SoundPatchAsset,
    pub loudness: f32,
    pub scope: SoundScopeData,
    pub radius: f32,
    pub doppler_factor: f32,
    pub master_pitch: f32,
    pub mixer: MixerAsset,
    pub node_configs: Vec<AudioGraphNodeConfigData>,
    pub parameter_configs: Vec<AudioGraphParameterConfigData>,
    pub debug_data: SoundPatchConfigurationDebugData,
    pub is_loudness_configured: bool,
    pub is_scope_configured: bool,
    pub is_radius_configured: bool,
    pub is_doppler_factor_configured: bool,
    pub is_master_pitch_configured: bool,
    pub is_mixer_configured: bool,
}

pub const SOUNDPATCHCONFIGURATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDPATCHASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, sound),
            },
            FieldInfoData {
                name: "Loudness",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, loudness),
            },
            FieldInfoData {
                name: "Scope",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPEDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, scope),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, radius),
            },
            FieldInfoData {
                name: "DopplerFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, doppler_factor),
            },
            FieldInfoData {
                name: "MasterPitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, master_pitch),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, mixer),
            },
            FieldInfoData {
                name: "NodeConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, node_configs),
            },
            FieldInfoData {
                name: "ParameterConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, parameter_configs),
            },
            FieldInfoData {
                name: "DebugData",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, debug_data),
            },
            FieldInfoData {
                name: "IsLoudnessConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_loudness_configured),
            },
            FieldInfoData {
                name: "IsScopeConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_scope_configured),
            },
            FieldInfoData {
                name: "IsRadiusConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_radius_configured),
            },
            FieldInfoData {
                name: "IsDopplerFactorConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_doppler_factor_configured),
            },
            FieldInfoData {
                name: "IsMasterPitchConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_master_pitch_configured),
            },
            FieldInfoData {
                name: "IsMixerConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_mixer_configured),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHCONFIGURATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchConfigurationAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDPATCHCONFIGURATIONASSET_TYPE_INFO
    }
}


pub const SOUNDPATCHCONFIGURATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchConfigurationAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ScopeCollectionAsset {
    pub scopes: Vec<SoundScopeData>,
    pub aggregates: Vec<SoundScopeAggregateData>,
    pub scope_strategies: Vec<SoundScopeStrategyData>,
    pub scope_setups: Vec<SoundScopeSetupData>,
}

pub const SCOPECOLLECTIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeCollectionAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Scopes",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ScopeCollectionAsset, scopes),
            },
            FieldInfoData {
                name: "Aggregates",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ScopeCollectionAsset, aggregates),
            },
            FieldInfoData {
                name: "ScopeStrategies",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ScopeCollectionAsset, scope_strategies),
            },
            FieldInfoData {
                name: "ScopeSetups",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ScopeCollectionAsset, scope_setups),
            },
        ],
    }),
    array_type: Some(SCOPECOLLECTIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScopeCollectionAsset {
    fn type_info() -> &'static TypeInfo {
        SCOPECOLLECTIONASSET_TYPE_INFO
    }
}


pub const SCOPECOLLECTIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeCollectionAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScopeCollectionAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioSystemAsset {
    pub master_patch: SoundMasterPatchAsset,
    pub stream_pools: Vec<StreamPool>,
    pub global_stream_pools: Vec<StreamPoolMapping>,
    pub stream_pool_presets: Vec<StreamPoolPreset>,
    pub default_stream_pool_preset: StreamPoolPreset,
    pub data_policies: Vec<SoundDataPolicy>,
    pub sample_rate: u32,
    pub mixer_system: MixerSystemAsset,
    pub languages: Vec<AudioLanguage>,
    pub language_settings: Vec<AudioLanguageSetting>,
    pub default_language: AudioLanguage,
    pub scope_collection: ScopeCollectionAsset,
    pub hdr_settings: Vec<HdrSetting>,
    pub default_hdr_setting: HdrSetting,
    pub selection_group_categories: Vec<NewWaveSelectionGroupCategory>,
    pub selection_groups: Vec<NewWaveSelectionGroup>,
    pub sound_context_system: SoundContextSystemAsset,
}

pub const AUDIOSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MasterPatch",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDMASTERPATCHASSET_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, master_patch),
            },
            FieldInfoData {
                name: "StreamPools",
                flags: MemberInfoFlags::new(144),
                field_type: STREAMPOOL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, stream_pools),
            },
            FieldInfoData {
                name: "GlobalStreamPools",
                flags: MemberInfoFlags::new(144),
                field_type: STREAMPOOLMAPPING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, global_stream_pools),
            },
            FieldInfoData {
                name: "StreamPoolPresets",
                flags: MemberInfoFlags::new(144),
                field_type: STREAMPOOLPRESET_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, stream_pool_presets),
            },
            FieldInfoData {
                name: "DefaultStreamPoolPreset",
                flags: MemberInfoFlags::new(0),
                field_type: STREAMPOOLPRESET_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, default_stream_pool_preset),
            },
            FieldInfoData {
                name: "DataPolicies",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDDATAPOLICY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, data_policies),
            },
            FieldInfoData {
                name: "SampleRate",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, sample_rate),
            },
            FieldInfoData {
                name: "MixerSystem",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERSYSTEMASSET_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, mixer_system),
            },
            FieldInfoData {
                name: "Languages",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOLANGUAGE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, languages),
            },
            FieldInfoData {
                name: "LanguageSettings",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, language_settings),
            },
            FieldInfoData {
                name: "DefaultLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, default_language),
            },
            FieldInfoData {
                name: "ScopeCollection",
                flags: MemberInfoFlags::new(0),
                field_type: SCOPECOLLECTIONASSET_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, scope_collection),
            },
            FieldInfoData {
                name: "HdrSettings",
                flags: MemberInfoFlags::new(144),
                field_type: HDRSETTING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, hdr_settings),
            },
            FieldInfoData {
                name: "DefaultHdrSetting",
                flags: MemberInfoFlags::new(0),
                field_type: HDRSETTING_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, default_hdr_setting),
            },
            FieldInfoData {
                name: "SelectionGroupCategories",
                flags: MemberInfoFlags::new(144),
                field_type: NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, selection_group_categories),
            },
            FieldInfoData {
                name: "SelectionGroups",
                flags: MemberInfoFlags::new(144),
                field_type: NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, selection_groups),
            },
            FieldInfoData {
                name: "SoundContextSystem",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTSYSTEMASSET_TYPE_INFO,
                rust_offset: offset_of!(AudioSystemAsset, sound_context_system),
            },
        ],
    }),
    array_type: Some(AUDIOSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioSystemAsset {
    fn type_info() -> &'static TypeInfo {
        AUDIOSYSTEMASSET_TYPE_INFO
    }
}


pub const AUDIOSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioSystemAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct StreamPoolMapping {
    pub stream_pool: StreamPool,
    pub stream_pool_setup: StreamPoolSetup,
}

pub const STREAMPOOLMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolMapping",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "StreamPool",
                flags: MemberInfoFlags::new(0),
                field_type: STREAMPOOL_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolMapping, stream_pool),
            },
            FieldInfoData {
                name: "StreamPoolSetup",
                flags: MemberInfoFlags::new(0),
                field_type: STREAMPOOLSETUP_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolMapping, stream_pool_setup),
            },
        ],
    }),
    array_type: Some(STREAMPOOLMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPoolMapping {
    fn type_info() -> &'static TypeInfo {
        STREAMPOOLMAPPING_TYPE_INFO
    }
}


pub const STREAMPOOLMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolMapping-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct StreamPoolPreset {
    pub mappings: Vec<StreamPoolMapping>,
}

pub const STREAMPOOLPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolPreset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mappings",
                flags: MemberInfoFlags::new(144),
                field_type: STREAMPOOLMAPPING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolPreset, mappings),
            },
        ],
    }),
    array_type: Some(STREAMPOOLPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPoolPreset {
    fn type_info() -> &'static TypeInfo {
        STREAMPOOLPRESET_TYPE_INFO
    }
}


pub const STREAMPOOLPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolPreset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolPreset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioLanguageSetting {
    pub name: String,
    pub name_hash: u32,
    pub display_name: String,
    pub is_default: bool,
    pub mappings: Vec<AudioLanguageMapping>,
}

pub const AUDIOLANGUAGESETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageSetting",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageSetting, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageSetting, name_hash),
            },
            FieldInfoData {
                name: "DisplayName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageSetting, display_name),
            },
            FieldInfoData {
                name: "IsDefault",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageSetting, is_default),
            },
            FieldInfoData {
                name: "Mappings",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageSetting, mappings),
            },
        ],
    }),
    array_type: Some(AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioLanguageSetting {
    fn type_info() -> &'static TypeInfo {
        AUDIOLANGUAGESETTING_TYPE_INFO
    }
}


pub const AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioLanguageSetting-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioLanguageMapping {
    pub source: AudioLanguage,
    pub target: AudioLanguage,
}

pub const AUDIOLANGUAGEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageMapping",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageMapping, source),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguageMapping, target),
            },
        ],
    }),
    array_type: Some(AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioLanguageMapping {
    fn type_info() -> &'static TypeInfo {
        AUDIOLANGUAGEMAPPING_TYPE_INFO
    }
}


pub const AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioLanguageMapping-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundBusPatchAsset {
    pub output_nodes: Vec<AudioGraphNodeData>,
}

pub const SOUNDBUSPATCHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDBUSPATCHBASEASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OutputNodes",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundBusPatchAsset, output_nodes),
            },
        ],
    }),
    array_type: Some(SOUNDBUSPATCHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundBusPatchAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDBUSPATCHASSET_TYPE_INFO
    }
}


pub const SOUNDBUSPATCHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundBusPatchAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundMasterPatchAsset {
    pub rw_movie_bus: SoundBusData,
}

pub const SOUNDMASTERPATCHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterPatchAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDBUSPATCHBASEASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RwMovieBus",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundMasterPatchAsset, rw_movie_bus),
            },
        ],
    }),
    array_type: Some(SOUNDMASTERPATCHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundMasterPatchAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDMASTERPATCHASSET_TYPE_INFO
    }
}


pub const SOUNDMASTERPATCHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterPatchAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundMasterPatchAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundBusPatchBaseAsset {
    pub graph: SoundGraphData,
    pub busses: Vec<SoundBusData>,
}

pub const SOUNDBUSPATCHBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchBaseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Graph",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundBusPatchBaseAsset, graph),
            },
            FieldInfoData {
                name: "Busses",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDBUSDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundBusPatchBaseAsset, busses),
            },
        ],
    }),
    array_type: Some(SOUNDBUSPATCHBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundBusPatchBaseAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDBUSPATCHBASEASSET_TYPE_INFO
    }
}


pub const SOUNDBUSPATCHBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchBaseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundBusPatchBaseAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundPatchAsset {
    pub output_nodes: Vec<AudioGraphNodeData>,
    pub loudness: f32,
    pub scope: SoundScopeData,
    pub radius: f32,
    pub obstruction_outer_distance_multiplier: f32,
    pub doppler_factor: f32,
    pub master_pitch: f32,
    pub is_looping: bool,
    pub is_persistent: bool,
    pub default_start_event: AudioGraphEvent,
    pub default_stop_event: AudioGraphEvent,
    pub default_enter_scope_event: AudioGraphEvent,
    pub default_force_init_event: AudioGraphEvent,
    pub context_group: SoundContextGroupData,
}

pub const SOUNDPATCHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDGRAPHASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OutputNodes",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, output_nodes),
            },
            FieldInfoData {
                name: "Loudness",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, loudness),
            },
            FieldInfoData {
                name: "Scope",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPEDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, scope),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, radius),
            },
            FieldInfoData {
                name: "ObstructionOuterDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, obstruction_outer_distance_multiplier),
            },
            FieldInfoData {
                name: "DopplerFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, doppler_factor),
            },
            FieldInfoData {
                name: "MasterPitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, master_pitch),
            },
            FieldInfoData {
                name: "IsLooping",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, is_looping),
            },
            FieldInfoData {
                name: "IsPersistent",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, is_persistent),
            },
            FieldInfoData {
                name: "DefaultStartEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, default_start_event),
            },
            FieldInfoData {
                name: "DefaultStopEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, default_stop_event),
            },
            FieldInfoData {
                name: "DefaultEnterScopeEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, default_enter_scope_event),
            },
            FieldInfoData {
                name: "DefaultForceInitEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, default_force_init_event),
            },
            FieldInfoData {
                name: "ContextGroup",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTGROUPDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchAsset, context_group),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDPATCHASSET_TYPE_INFO
    }
}


pub const SOUNDPATCHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundPatchDefaultEvent {
    #[default]
    SoundPatchDefaultEvent_Start = 0,
    SoundPatchDefaultEvent_Stop = 1,
    SoundPatchDefaultEvent_EnterScope = 2,
    SoundPatchDefaultEvent_ForceInit = 3,
}

pub const SOUNDPATCHDEFAULTEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchDefaultEvent",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDPATCHDEFAULTEVENT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundPatchDefaultEvent {
    fn type_info() -> &'static TypeInfo {
        SOUNDPATCHDEFAULTEVENT_TYPE_INFO
    }
}


pub const SOUNDPATCHDEFAULTEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchDefaultEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchDefaultEvent-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundPatchPublicNode {
    pub node: AudioGraphNodeData,
    pub id: u32,
}

pub const SOUNDPATCHPUBLICNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchPublicNode",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchPublicNode, node),
            },
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundPatchPublicNode, id),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHPUBLICNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchPublicNode {
    fn type_info() -> &'static TypeInfo {
        SOUNDPATCHPUBLICNODE_TYPE_INFO
    }
}


pub const SOUNDPATCHPUBLICNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchPublicNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchPublicNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundGraphAsset {
    pub graph: SoundGraphData,
    pub mixer: MixerAsset,
}

pub const SOUNDGRAPHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Graph",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphAsset, graph),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphAsset, mixer),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHASSET_TYPE_INFO
    }
}


pub const SOUNDGRAPHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioMaterialDefinitions {
}

pub const AUDIOMATERIALDEFINITIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioMaterialDefinitions",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AUDIOMATERIALDEFINITIONS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioMaterialDefinitions {
    fn type_info() -> &'static TypeInfo {
        AUDIOMATERIALDEFINITIONS_TYPE_INFO
    }
}


pub const AUDIOMATERIALDEFINITIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioMaterialDefinitions-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioMaterialDefinitions-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct ImpulseResponseAsset {
}

pub const IMPULSERESPONSEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDDATAASSET_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(IMPULSERESPONSEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ImpulseResponseAsset {
    fn type_info() -> &'static TypeInfo {
        IMPULSERESPONSEASSET_TYPE_INFO
    }
}


pub const IMPULSERESPONSEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ImpulseResponseAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ImpulseResponseBlockSize {
    #[default]
    ImpulseResponseBlockSize_256 = 256,
    ImpulseResponseBlockSize_512 = 512,
    ImpulseResponseBlockSize_768 = 768,
    ImpulseResponseBlockSize_1024 = 1024,
    ImpulseResponseBlockSize_1280 = 1280,
    ImpulseResponseBlockSize_1536 = 1536,
    ImpulseResponseBlockSize_1792 = 1792,
    ImpulseResponseBlockSize_2048 = 2048,
    ImpulseResponseBlockSize_2304 = 2304,
    ImpulseResponseBlockSize_2560 = 2560,
    ImpulseResponseBlockSize_2816 = 2816,
    ImpulseResponseBlockSize_3072 = 3072,
    ImpulseResponseBlockSize_3328 = 3328,
    ImpulseResponseBlockSize_3584 = 3584,
    ImpulseResponseBlockSize_3840 = 3840,
    ImpulseResponseBlockSize_4096 = 4096,
    ImpulseResponseBlockSize_4352 = 4352,
    ImpulseResponseBlockSize_4608 = 4608,
    ImpulseResponseBlockSize_4864 = 4864,
    ImpulseResponseBlockSize_5120 = 5120,
    ImpulseResponseBlockSize_5376 = 5376,
    ImpulseResponseBlockSize_5632 = 5632,
    ImpulseResponseBlockSize_5888 = 5888,
    ImpulseResponseBlockSize_6144 = 6144,
    ImpulseResponseBlockSize_6400 = 6400,
    ImpulseResponseBlockSize_6656 = 6656,
    ImpulseResponseBlockSize_6912 = 6912,
    ImpulseResponseBlockSize_7168 = 7168,
    ImpulseResponseBlockSize_7424 = 7424,
    ImpulseResponseBlockSize_7680 = 7680,
    ImpulseResponseBlockSize_7936 = 7936,
    ImpulseResponseBlockSize_8192 = 8192,
}

pub const IMPULSERESPONSEBLOCKSIZE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseBlockSize",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(IMPULSERESPONSEBLOCKSIZE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImpulseResponseBlockSize {
    fn type_info() -> &'static TypeInfo {
        IMPULSERESPONSEBLOCKSIZE_TYPE_INFO
    }
}


pub const IMPULSERESPONSEBLOCKSIZE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseBlockSize-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ImpulseResponseBlockSize-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct NewWaveSelectionGroup {
    pub entry_count: u32,
    pub entry_timeout: f32,
    pub name_hash: u32,
    pub should_serialize: bool,
    pub behavior: u8,
    pub category: NewWaveSelectionGroupCategory,
}

pub const NEWWAVESELECTIONGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EntryCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(NewWaveSelectionGroup, entry_count),
            },
            FieldInfoData {
                name: "EntryTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(NewWaveSelectionGroup, entry_timeout),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(NewWaveSelectionGroup, name_hash),
            },
            FieldInfoData {
                name: "ShouldSerialize",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(NewWaveSelectionGroup, should_serialize),
            },
            FieldInfoData {
                name: "Behavior",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(NewWaveSelectionGroup, behavior),
            },
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO,
                rust_offset: offset_of!(NewWaveSelectionGroup, category),
            },
        ],
    }),
    array_type: Some(NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveSelectionGroup {
    fn type_info() -> &'static TypeInfo {
        NEWWAVESELECTIONGROUP_TYPE_INFO
    }
}


pub const NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveSelectionGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum NewWaveSelectionGroupBehavior {
    #[default]
    NewWaveSelectionGroupBehavior_Shuffle = 1,
    NewWaveSelectionGroupBehavior_Timed = 2,
    NewWaveSelectionGroupBehavior_Once = 3,
    NewWaveSelectionGroupBehavior_Timeout = 4,
}

pub const NEWWAVESELECTIONGROUPBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(NEWWAVESELECTIONGROUPBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for NewWaveSelectionGroupBehavior {
    fn type_info() -> &'static TypeInfo {
        NEWWAVESELECTIONGROUPBEHAVIOR_TYPE_INFO
    }
}


pub const NEWWAVESELECTIONGROUPBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveSelectionGroupBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct NewWaveSelectionGroupCategory {
}

pub const NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupCategory",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveSelectionGroupCategory {
    fn type_info() -> &'static TypeInfo {
        NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO
    }
}


pub const NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupCategory-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveSelectionGroupCategory-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct StreamPool {
    pub name: String,
    pub stream_pool_id: u32,
    pub setups: Vec<StreamPoolSetup>,
}

pub const STREAMPOOL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPool",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(StreamPool, name),
            },
            FieldInfoData {
                name: "StreamPoolId",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(StreamPool, stream_pool_id),
            },
            FieldInfoData {
                name: "Setups",
                flags: MemberInfoFlags::new(144),
                field_type: STREAMPOOLSETUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(StreamPool, setups),
            },
        ],
    }),
    array_type: Some(STREAMPOOL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPool {
    fn type_info() -> &'static TypeInfo {
        STREAMPOOL_TYPE_INFO
    }
}


pub const STREAMPOOL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPool-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPool-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct StreamPoolSetup {
    pub properties: StreamPoolProperties,
    pub stream_starve_mode: StreamStarveMode,
}

pub const STREAMPOOLSETUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolSetup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(0),
                field_type: STREAMPOOLPROPERTIES_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolSetup, properties),
            },
            FieldInfoData {
                name: "StreamStarveMode",
                flags: MemberInfoFlags::new(0),
                field_type: STREAMSTARVEMODE_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolSetup, stream_starve_mode),
            },
        ],
    }),
    array_type: Some(STREAMPOOLSETUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPoolSetup {
    fn type_info() -> &'static TypeInfo {
        STREAMPOOLSETUP_TYPE_INFO
    }
}


pub const STREAMPOOLSETUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolSetup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolSetup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct StreamPoolProperties {
    pub buffer_size: u32,
    pub count: u32,
    pub read_block_size: u32,
    pub starvation_threshold: u32,
    pub max_requests: u32,
}

pub const STREAMPOOLPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolProperties",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "BufferSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolProperties, buffer_size),
            },
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolProperties, count),
            },
            FieldInfoData {
                name: "ReadBlockSize",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolProperties, read_block_size),
            },
            FieldInfoData {
                name: "StarvationThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolProperties, starvation_threshold),
            },
            FieldInfoData {
                name: "MaxRequests",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(StreamPoolProperties, max_requests),
            },
        ],
    }),
    array_type: Some(STREAMPOOLPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for StreamPoolProperties {
    fn type_info() -> &'static TypeInfo {
        STREAMPOOLPROPERTIES_TYPE_INFO
    }
}


pub const STREAMPOOLPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolProperties-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolProperties-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum StreamStarveMode {
    #[default]
    StreamStarveMode_Off = 0,
    StreamStarveMode_On = 1,
    StreamStarveMode_Dynamic = 2,
}

pub const STREAMSTARVEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamStarveMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(STREAMSTARVEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StreamStarveMode {
    fn type_info() -> &'static TypeInfo {
        STREAMSTARVEMODE_TYPE_INFO
    }
}


pub const STREAMSTARVEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamStarveMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamStarveMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundAsset {
    pub referenced_data: Vec<SoundDataReference>,
}

pub const SOUNDASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ReferencedData",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDDATAREFERENCE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundAsset, referenced_data),
            },
        ],
    }),
    array_type: Some(SOUNDASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundAsset {
    fn type_info() -> &'static TypeInfo {
        SOUNDASSET_TYPE_INFO
    }
}


pub const SOUNDASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundDataReference {
    pub data_owner: super::core::DataContainer,
    pub sound_data: SoundDataAsset,
}

pub const SOUNDDATAREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReference",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "DataOwner",
                flags: MemberInfoFlags::new(0),
                field_type: DATACONTAINER_TYPE_INFO,
                rust_offset: offset_of!(SoundDataReference, data_owner),
            },
            FieldInfoData {
                name: "SoundData",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDDATAASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundDataReference, sound_data),
            },
        ],
    }),
    array_type: Some(SOUNDDATAREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataReference {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAREFERENCE_TYPE_INFO
    }
}


pub const SOUNDDATAREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReference-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSystemAsset {
    pub exponential_gain_interpolation: bool,
    pub octave_frequency_interpolation_lpf: bool,
    pub groups: Vec<MixGroup>,
}

pub const MIXERSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ExponentialGainInterpolation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerSystemAsset, exponential_gain_interpolation),
            },
            FieldInfoData {
                name: "OctaveFrequencyInterpolationLpf",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerSystemAsset, octave_frequency_interpolation_lpf),
            },
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: MIXGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerSystemAsset, groups),
            },
        ],
    }),
    array_type: Some(MIXERSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSystemAsset {
    fn type_info() -> &'static TypeInfo {
        MIXERSYSTEMASSET_TYPE_INFO
    }
}


pub const MIXERSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSystemAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerAsset {
    pub bypass: bool,
    pub graph: MixerGraphData,
    pub presets: Vec<MixerPreset>,
    pub default_preset: MixerPreset,
}

pub const MIXERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Bypass",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerAsset, bypass),
            },
            FieldInfoData {
                name: "Graph",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERGRAPHDATA_TYPE_INFO,
                rust_offset: offset_of!(MixerAsset, graph),
            },
            FieldInfoData {
                name: "Presets",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERPRESET_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerAsset, presets),
            },
            FieldInfoData {
                name: "DefaultPreset",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERPRESET_TYPE_INFO,
                rust_offset: offset_of!(MixerAsset, default_preset),
            },
        ],
    }),
    array_type: Some(MIXERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerAsset {
    fn type_info() -> &'static TypeInfo {
        MIXERASSET_TYPE_INFO
    }
}


pub const MIXERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerGraphData {
    pub inputs: Vec<AudioGraphParameter>,
    pub mixer_input_infos: Vec<MixerInputInfo>,
    pub outputs: Vec<AudioGraphParameter>,
}

pub const MIXERGRAPHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGraphData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerGraphData, inputs),
            },
            FieldInfoData {
                name: "MixerInputInfos",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERINPUTINFO_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerGraphData, mixer_input_infos),
            },
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerGraphData, outputs),
            },
        ],
    }),
    array_type: Some(MIXERGRAPHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerGraphData {
    fn type_info() -> &'static TypeInfo {
        MIXERGRAPHDATA_TYPE_INFO
    }
}


pub const MIXERGRAPHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGraphData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerGraphData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MixerInputInfo {
    pub mode: MixerValueAccumulateMode,
    pub keep_value: bool,
}

pub const MIXERINPUTINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputInfo",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERVALUEACCUMULATEMODE_TYPE_INFO,
                rust_offset: offset_of!(MixerInputInfo, mode),
            },
            FieldInfoData {
                name: "KeepValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerInputInfo, keep_value),
            },
        ],
    }),
    array_type: Some(MIXERINPUTINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MixerInputInfo {
    fn type_info() -> &'static TypeInfo {
        MIXERINPUTINFO_TYPE_INFO
    }
}


pub const MIXERINPUTINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerInputInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MixerValueAccumulateMode {
    #[default]
    MixerValueAccumulateMode_None = 0,
    MixerValueAccumulateMode_Min = 1,
    MixerValueAccumulateMode_Max = 2,
}

pub const MIXERVALUEACCUMULATEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueAccumulateMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEACCUMULATEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueAccumulateMode {
    fn type_info() -> &'static TypeInfo {
        MIXERVALUEACCUMULATEMODE_TYPE_INFO
    }
}


pub const MIXERVALUEACCUMULATEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueAccumulateMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueAccumulateMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerPreset {
    pub name_hash: u32,
    pub groups: Vec<MixerPresetGroupData>,
    pub nodes: Vec<MixerPresetNodeData>,
}

pub const MIXERPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPreset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MixerPreset, name_hash),
            },
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerPreset, groups),
            },
            FieldInfoData {
                name: "Nodes",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERPRESETNODEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerPreset, nodes),
            },
        ],
    }),
    array_type: Some(MIXERPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerPreset {
    fn type_info() -> &'static TypeInfo {
        MIXERPRESET_TYPE_INFO
    }
}


pub const MIXERPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPreset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerPreset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerPresetNodeData {
    pub node: AudioGraphNodeData,
    pub value: f32,
}

pub const MIXERPRESETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetNodeData",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetNodeData, node),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetNodeData, value),
            },
        ],
    }),
    array_type: Some(MIXERPRESETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerPresetNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERPRESETNODEDATA_TYPE_INFO
    }
}


pub const MIXERPRESETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerPresetNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerPresetGroupData {
    pub group: MixGroup,
    pub state: MixGroupState,
    pub attack_time: f32,
    pub release_time: f32,
    pub is_dominant: bool,
    pub is_additive: bool,
    pub priority: i32,
    pub properties: Vec<MixGroupPropertyValue>,
}

pub const MIXERPRESETGROUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetGroupData",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: MIXGROUP_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, group),
            },
            FieldInfoData {
                name: "State",
                flags: MemberInfoFlags::new(0),
                field_type: MIXGROUPSTATE_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, state),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, release_time),
            },
            FieldInfoData {
                name: "IsDominant",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, is_dominant),
            },
            FieldInfoData {
                name: "IsAdditive",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, is_additive),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, priority),
            },
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerPresetGroupData, properties),
            },
        ],
    }),
    array_type: Some(MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerPresetGroupData {
    fn type_info() -> &'static TypeInfo {
        MIXERPRESETGROUPDATA_TYPE_INFO
    }
}


pub const MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetGroupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerPresetGroupData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixGroupPropertyValue {
    pub property: u32,
    pub value: f32,
    pub controlled: bool,
}

pub const MIXGROUPPROPERTYVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyValue",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyValue, property),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyValue, value),
            },
            FieldInfoData {
                name: "Controlled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyValue, controlled),
            },
        ],
    }),
    array_type: Some(MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MixGroupPropertyValue {
    fn type_info() -> &'static TypeInfo {
        MIXGROUPPROPERTYVALUE_TYPE_INFO
    }
}


pub const MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupPropertyValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MixGroupPropertyType {
    #[default]
    MixGroupPropertyType_Gain = 0,
    MixGroupPropertyType_Pitch = 1,
    MixGroupPropertyType_Lfe = 2,
    MixGroupPropertyType_Reverb = 3,
    MixGroupPropertyType_Lpf = 4,
    MixGroupPropertyType_CurveFactor = 5,
    MixGroupPropertyTypeCount = 6,
}

pub const MIXGROUPPROPERTYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXGROUPPROPERTYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixGroupPropertyType {
    fn type_info() -> &'static TypeInfo {
        MIXGROUPPROPERTYTYPE_TYPE_INFO
    }
}


pub const MIXGROUPPROPERTYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupPropertyType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixGroup {
    pub name: String,
    pub group_index: u16,
    pub parent_group_index: u16,
    pub parameters: Vec<MixGroupPropertyParameters>,
}

pub const MIXGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(MixGroup, name),
            },
            FieldInfoData {
                name: "GroupIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(MixGroup, group_index),
            },
            FieldInfoData {
                name: "ParentGroupIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(MixGroup, parent_group_index),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixGroup, parameters),
            },
        ],
    }),
    array_type: Some(MIXGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixGroup {
    fn type_info() -> &'static TypeInfo {
        MIXGROUP_TYPE_INFO
    }
}


pub const MIXGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixGroupPropertyParameters {
    pub property: u32,
    pub enable_offset_min_max: bool,
    pub min_offset: f32,
    pub max_offset: f32,
    pub override_default_value: bool,
    pub default_value: f32,
}

pub const MIXGROUPPROPERTYPARAMETERS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyParameters",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyParameters, property),
            },
            FieldInfoData {
                name: "EnableOffsetMinMax",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyParameters, enable_offset_min_max),
            },
            FieldInfoData {
                name: "MinOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyParameters, min_offset),
            },
            FieldInfoData {
                name: "MaxOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyParameters, max_offset),
            },
            FieldInfoData {
                name: "OverrideDefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyParameters, override_default_value),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixGroupPropertyParameters, default_value),
            },
        ],
    }),
    array_type: Some(MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MixGroupPropertyParameters {
    fn type_info() -> &'static TypeInfo {
        MIXGROUPPROPERTYPARAMETERS_TYPE_INFO
    }
}


pub const MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyParameters-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupPropertyParameters-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MixGroupState {
    #[default]
    MixGroupState_Normal = 0,
    MixGroupState_Mute = 1,
    MixGroupState_Solo = 2,
    MixGroupStateBitCount = 4,
}

pub const MIXGROUPSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupState",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXGROUPSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixGroupState {
    fn type_info() -> &'static TypeInfo {
        MIXGROUPSTATE_TYPE_INFO
    }
}


pub const MIXGROUPSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupState-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupState-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerValueNodeData {
    pub out: AudioGraphNodePort,
    pub default_value: f32,
}

pub const MIXERVALUENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerValueNodeData, out),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixerValueNodeData, default_value),
            },
        ],
    }),
    array_type: Some(MIXERVALUENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerValueNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERVALUENODEDATA_TYPE_INFO
    }
}


pub const MIXERVALUENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MixerValueUIScale {
    #[default]
    MixerValueUIScale_Linear = 0,
    MixerValueUIScale_Logarithmic = 1,
}

pub const MIXERVALUEUISCALE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIScale",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEUISCALE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueUIScale {
    fn type_info() -> &'static TypeInfo {
        MIXERVALUEUISCALE_TYPE_INFO
    }
}


pub const MIXERVALUEUISCALE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIScale-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueUIScale-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MixerValueUIOrientation {
    #[default]
    MixerValueUIOrientation_Horizontal = 0,
    MixerValueUIOrientation_Vertical = 1,
}

pub const MIXERVALUEUIORIENTATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIOrientation",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEUIORIENTATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueUIOrientation {
    fn type_info() -> &'static TypeInfo {
        MIXERVALUEUIORIENTATION_TYPE_INFO
    }
}


pub const MIXERVALUEUIORIENTATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIOrientation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueUIOrientation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MixerValueUI {
    #[default]
    MixerValueUI_None = 0,
    MixerValueUI_Fader = 1,
    MixerValueUI_Knob = 2,
    MixerValueUI_EditBox = 3,
}

pub const MIXERVALUEUI_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUI",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEUI_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueUI {
    fn type_info() -> &'static TypeInfo {
        MIXERVALUEUI_TYPE_INFO
    }
}


pub const MIXERVALUEUI_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUI-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueUI-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSendNodeConfigData {
    pub entry_configs: Vec<MixerEntryConfig>,
}

pub const MIXERSENDNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EntryConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERENTRYCONFIG_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerSendNodeConfigData, entry_configs),
            },
        ],
    }),
    array_type: Some(MIXERSENDNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSendNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        MIXERSENDNODECONFIGDATA_TYPE_INFO
    }
}


pub const MIXERSENDNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSendNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerReceiveNodeConfigData {
    pub entry_configs: Vec<MixerEntryConfig>,
}

pub const MIXERRECEIVENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EntryConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERENTRYCONFIG_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerReceiveNodeConfigData, entry_configs),
            },
        ],
    }),
    array_type: Some(MIXERRECEIVENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerReceiveNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        MIXERRECEIVENODECONFIGDATA_TYPE_INFO
    }
}


pub const MIXERRECEIVENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerReceiveNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerEntryConfig {
    pub graph_parameter: AudioGraphParameter,
    pub mixer: MixerAsset,
}

pub const MIXERENTRYCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntryConfig",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "GraphParameter",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(MixerEntryConfig, graph_parameter),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(MixerEntryConfig, mixer),
            },
        ],
    }),
    array_type: Some(MIXERENTRYCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerEntryConfig {
    fn type_info() -> &'static TypeInfo {
        MIXERENTRYCONFIG_TYPE_INFO
    }
}


pub const MIXERENTRYCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntryConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntryConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSendNodeData {
    pub entries: Vec<MixerSendEntry>,
}

pub const MIXERSENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERSENDENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerSendNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERSENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSendNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERSENDNODEDATA_TYPE_INFO
    }
}


pub const MIXERSENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSendNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSendEntry {
    pub r#in: AudioGraphNodePort,
    pub target: AudioGraphParameter,
    pub mixer: MixerAsset,
}

pub const MIXERSENDENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerSendEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(MixerSendEntry, target),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(MixerSendEntry, mixer),
            },
        ],
    }),
    array_type: Some(MIXERSENDENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSendEntry {
    fn type_info() -> &'static TypeInfo {
        MIXERSENDENTRY_TYPE_INFO
    }
}


pub const MIXERSENDENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSendEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerReceiveNodeData {
    pub entries: Vec<MixerReceiveEntry>,
}

pub const MIXERRECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERRECEIVEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERRECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerReceiveNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERRECEIVENODEDATA_TYPE_INFO
    }
}


pub const MIXERRECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerReceiveNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerReceiveEntry {
    pub out: AudioGraphNodePort,
    pub source: AudioGraphParameter,
    pub mixer: MixerAsset,
}

pub const MIXERRECEIVEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerReceiveEntry, out),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(MixerReceiveEntry, source),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(MixerReceiveEntry, mixer),
            },
        ],
    }),
    array_type: Some(MIXERRECEIVEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerReceiveEntry {
    fn type_info() -> &'static TypeInfo {
        MIXERRECEIVEENTRY_TYPE_INFO
    }
}


pub const MIXERRECEIVEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerReceiveEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerGetPropertyNodeData {
    pub entries: Vec<MixerGetPropertyEntry>,
}

pub const MIXERGETPROPERTYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerGetPropertyNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERGETPROPERTYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerGetPropertyNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERGETPROPERTYNODEDATA_TYPE_INFO
    }
}


pub const MIXERGETPROPERTYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerGetPropertyNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerGetPropertyEntry {
    pub out: AudioGraphNodePort,
    pub property: u32,
    pub group: MixGroup,
}

pub const MIXERGETPROPERTYENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerGetPropertyEntry, out),
            },
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MixerGetPropertyEntry, property),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: MIXGROUP_TYPE_INFO,
                rust_offset: offset_of!(MixerGetPropertyEntry, group),
            },
        ],
    }),
    array_type: Some(MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerGetPropertyEntry {
    fn type_info() -> &'static TypeInfo {
        MIXERGETPROPERTYENTRY_TYPE_INFO
    }
}


pub const MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerGetPropertyEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSetPropertyNodeData {
    pub entries: Vec<MixerSetPropertyEntry>,
}

pub const MIXERSETPROPERTYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerSetPropertyNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERSETPROPERTYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSetPropertyNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERSETPROPERTYNODEDATA_TYPE_INFO
    }
}


pub const MIXERSETPROPERTYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSetPropertyNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSetPropertyEntry {
    pub r#in: AudioGraphNodePort,
    pub target: u32,
    pub group: MixGroup,
    pub attack_time: f32,
    pub release_time: f32,
}

pub const MIXERSETPROPERTYENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerSetPropertyEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MixerSetPropertyEntry, target),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: MIXGROUP_TYPE_INFO,
                rust_offset: offset_of!(MixerSetPropertyEntry, group),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixerSetPropertyEntry, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MixerSetPropertyEntry, release_time),
            },
        ],
    }),
    array_type: Some(MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSetPropertyEntry {
    fn type_info() -> &'static TypeInfo {
        MIXERSETPROPERTYENTRY_TYPE_INFO
    }
}


pub const MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSetPropertyEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerSimplePresetNodeData {
    pub index: AudioGraphNodePort,
    pub presets: Vec<MixerPreset>,
}

pub const MIXERSIMPLEPRESETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSimplePresetNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerSimplePresetNodeData, index),
            },
            FieldInfoData {
                name: "Presets",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERPRESET_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerSimplePresetNodeData, presets),
            },
        ],
    }),
    array_type: Some(MIXERSIMPLEPRESETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSimplePresetNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERSIMPLEPRESETNODEDATA_TYPE_INFO
    }
}


pub const MIXERSIMPLEPRESETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSimplePresetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSimplePresetNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerOutputNodeData {
    pub entries: Vec<MixerOutputEntry>,
}

pub const MIXEROUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXEROUTPUTENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerOutputNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXEROUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerOutputNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXEROUTPUTNODEDATA_TYPE_INFO
    }
}


pub const MIXEROUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerOutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerOutputEntry {
    pub r#in: AudioGraphNodePort,
    pub target: AudioGraphParameter,
}

pub const MIXEROUTPUTENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerOutputEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(MixerOutputEntry, target),
            },
        ],
    }),
    array_type: Some(MIXEROUTPUTENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerOutputEntry {
    fn type_info() -> &'static TypeInfo {
        MIXEROUTPUTENTRY_TYPE_INFO
    }
}


pub const MIXEROUTPUTENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerOutputEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerInputNodeData {
    pub entries: Vec<MixerInputEntry>,
}

pub const MIXERINPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERINPUTENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerInputNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERINPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerInputNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERINPUTNODEDATA_TYPE_INFO
    }
}


pub const MIXERINPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerInputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerInputEntry {
    pub out: AudioGraphNodePort,
    pub source: AudioGraphParameter,
    pub accumulate_mode: MixerValueAccumulateMode,
    pub keep_value: bool,
}

pub const MIXERINPUTENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerInputEntry, out),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(MixerInputEntry, source),
            },
            FieldInfoData {
                name: "AccumulateMode",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERVALUEACCUMULATEMODE_TYPE_INFO,
                rust_offset: offset_of!(MixerInputEntry, accumulate_mode),
            },
            FieldInfoData {
                name: "KeepValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerInputEntry, keep_value),
            },
        ],
    }),
    array_type: Some(MIXERINPUTENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerInputEntry {
    fn type_info() -> &'static TypeInfo {
        MIXERINPUTENTRY_TYPE_INFO
    }
}


pub const MIXERINPUTENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerInputEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphEnumerationParameterConfigData {
    pub value: f32,
}

pub const AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphEnumerationParameterConfigData, value),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphEnumerationParameterConfigData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphEnumerationParameterConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphValueParameterConfigData {
    pub value: f32,
}

pub const AUDIOGRAPHVALUEPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphValueParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphValueParameterConfigData, value),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHVALUEPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphValueParameterConfigData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHVALUEPARAMETERCONFIGDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHVALUEPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphValueParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphValueParameterConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioGraphAssetParameterConfigData {
    pub asset: super::core::Asset,
}

pub const AUDIOGRAPHASSETPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: ASSET_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphAssetParameterConfigData, asset),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHASSETPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphAssetParameterConfigData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHASSETPARAMETERCONFIGDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHASSETPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphAssetParameterConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioGraphParameterConfigData {
    pub name_hash: u32,
}

pub const AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphParameterConfigData, name_hash),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphParameterConfigData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphParameterConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioGraphNodeConfigData {
    pub node: AudioGraphNodeData,
    pub configured_property_flags: u64,
}

pub const AUDIOGRAPHNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphNodeConfigData, node),
            },
            FieldInfoData {
                name: "ConfiguredPropertyFlags",
                flags: MemberInfoFlags::new(0),
                field_type: UINT64_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphNodeConfigData, configured_property_flags),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHNODECONFIGDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphData {
    pub nodes: Vec<AudioGraphNodeData>,
    pub public_parameters: Vec<AudioGraphParameter>,
    pub public_events: Vec<AudioGraphEvent>,
    pub public_asset_parameters: Vec<AudioGraphAssetParameter>,
    pub public_value_count: u16,
    pub value_count: u16,
}

pub const AUDIOGRAPHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Nodes",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphData, nodes),
            },
            FieldInfoData {
                name: "PublicParameters",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphData, public_parameters),
            },
            FieldInfoData {
                name: "PublicEvents",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHEVENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphData, public_events),
            },
            FieldInfoData {
                name: "PublicAssetParameters",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphData, public_asset_parameters),
            },
            FieldInfoData {
                name: "PublicValueCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphData, public_value_count),
            },
            FieldInfoData {
                name: "ValueCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphData, value_count),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioGraphNodeData {
}

pub const AUDIOGRAPHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphNodeData {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHNODEDATA_TYPE_INFO
    }
}


pub const AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioGraphNodePortGroup {
}

pub const AUDIOGRAPHNODEPORTGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePortGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHNODEPORTGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphNodePortGroup {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHNODEPORTGROUP_TYPE_INFO
    }
}


pub const AUDIOGRAPHNODEPORTGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePortGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodePortGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphNodePort {
    pub unconnected_value: f32,
    pub value_index: u16,
    pub is_connected: bool,
}

pub const AUDIOGRAPHNODEPORT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePort",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "UnconnectedValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphNodePort, unconnected_value),
            },
            FieldInfoData {
                name: "ValueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphNodePort, value_index),
            },
            FieldInfoData {
                name: "IsConnected",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphNodePort, is_connected),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHNODEPORT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AudioGraphNodePort {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHNODEPORT_TYPE_INFO
    }
}


pub const AUDIOGRAPHNODEPORT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePort-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodePort-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphEnumerationParameter {
}

pub const AUDIOGRAPHENUMERATIONPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHENUMERATIONPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphEnumerationParameter {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHENUMERATIONPARAMETER_TYPE_INFO
    }
}


pub const AUDIOGRAPHENUMERATIONPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphEnumerationParameter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphAssetParameter {
}

pub const AUDIOGRAPHASSETPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphAssetParameter {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHASSETPARAMETER_TYPE_INFO
    }
}


pub const AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphAssetParameter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphEvent {
}

pub const AUDIOGRAPHEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEvent",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHEVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphEvent {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHEVENT_TYPE_INFO
    }
}


pub const AUDIOGRAPHEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphEvent-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AudioGraphParameter {
    pub default_value: f32,
    pub name_hash: u32,
    pub value_index: u16,
}

pub const AUDIOGRAPHPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphParameter, default_value),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphParameter, name_hash),
            },
            FieldInfoData {
                name: "ValueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(AudioGraphParameter, value_index),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphParameter {
    fn type_info() -> &'static TypeInfo {
        AUDIOGRAPHPARAMETER_TYPE_INFO
    }
}


pub const AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphParameter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ValueCurveNodeData {
    pub curves: Vec<ValueCurveNodeEntry>,
    pub r#in: AudioGraphNodePort,
}

pub const VALUECURVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Curves",
                flags: MemberInfoFlags::new(144),
                field_type: VALUECURVENODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ValueCurveNodeData, curves),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ValueCurveNodeData, r#in),
            },
        ],
    }),
    array_type: Some(VALUECURVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueCurveNodeData {
    fn type_info() -> &'static TypeInfo {
        VALUECURVENODEDATA_TYPE_INFO
    }
}


pub const VALUECURVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueCurveNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ValueCurveNodeEntry {
    pub curve: super::core::FloatCurve,
    pub out: AudioGraphNodePort,
}

pub const VALUECURVENODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(ValueCurveNodeEntry, curve),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ValueCurveNodeEntry, out),
            },
        ],
    }),
    array_type: Some(VALUECURVENODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueCurveNodeEntry {
    fn type_info() -> &'static TypeInfo {
        VALUECURVENODEENTRY_TYPE_INFO
    }
}


pub const VALUECURVENODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueCurveNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SampleAndHoldNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub hold: AudioGraphNodePort,
    pub release: AudioGraphNodePort,
}

pub const SAMPLEANDHOLDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SampleAndHoldNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SampleAndHoldNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SampleAndHoldNodeData, out),
            },
            FieldInfoData {
                name: "Hold",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SampleAndHoldNodeData, hold),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SampleAndHoldNodeData, release),
            },
        ],
    }),
    array_type: Some(SAMPLEANDHOLDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SampleAndHoldNodeData {
    fn type_info() -> &'static TypeInfo {
        SAMPLEANDHOLDNODEDATA_TYPE_INFO
    }
}


pub const SAMPLEANDHOLDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SampleAndHoldNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SampleAndHoldNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterRouterNodeData {
    pub route_in: AudioGraphNodePort,
    pub route_out: AudioGraphNodePort,
    pub default_out: AudioGraphNodePort,
    pub parameter_router_entries: Vec<ParameterRouterEntry>,
}

pub const PARAMETERROUTERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RouteIn",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterRouterNodeData, route_in),
            },
            FieldInfoData {
                name: "RouteOut",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterRouterNodeData, route_out),
            },
            FieldInfoData {
                name: "DefaultOut",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterRouterNodeData, default_out),
            },
            FieldInfoData {
                name: "ParameterRouterEntries",
                flags: MemberInfoFlags::new(144),
                field_type: PARAMETERROUTERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ParameterRouterNodeData, parameter_router_entries),
            },
        ],
    }),
    array_type: Some(PARAMETERROUTERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterRouterNodeData {
    fn type_info() -> &'static TypeInfo {
        PARAMETERROUTERNODEDATA_TYPE_INFO
    }
}


pub const PARAMETERROUTERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterRouterNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterRouterEntry {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub const PARAMETERROUTERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterRouterEntry, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterRouterEntry, out),
            },
        ],
    }),
    array_type: Some(PARAMETERROUTERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterRouterEntry {
    fn type_info() -> &'static TypeInfo {
        PARAMETERROUTERENTRY_TYPE_INFO
    }
}


pub const PARAMETERROUTERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterRouterEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct KeepAliveNodeData {
    pub keep_alive: AudioGraphNodePort,
}

pub const KEEPALIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KeepAliveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "KeepAlive",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(KeepAliveNodeData, keep_alive),
            },
        ],
    }),
    array_type: Some(KEEPALIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KeepAliveNodeData {
    fn type_info() -> &'static TypeInfo {
        KEEPALIVENODEDATA_TYPE_INFO
    }
}


pub const KEEPALIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KeepAliveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("KeepAliveNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventSequencerNodeData {
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub interval: AudioGraphNodePort,
    pub interval_variation: AudioGraphNodePort,
    pub repeat: AudioGraphNodePort,
    pub repeat_variation: AudioGraphNodePort,
    pub out_events: Vec<EventSequencerOutEvent>,
    pub playback: EventSequencerPlayback,
    pub ignore_first_interval: bool,
    pub version: EventSequencerNodeVersion,
}

pub const EVENTSEQUENCERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, stop),
            },
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, interval),
            },
            FieldInfoData {
                name: "IntervalVariation",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, interval_variation),
            },
            FieldInfoData {
                name: "Repeat",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, repeat),
            },
            FieldInfoData {
                name: "RepeatVariation",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, repeat_variation),
            },
            FieldInfoData {
                name: "OutEvents",
                flags: MemberInfoFlags::new(144),
                field_type: EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, out_events),
            },
            FieldInfoData {
                name: "Playback",
                flags: MemberInfoFlags::new(0),
                field_type: EVENTSEQUENCERPLAYBACK_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, playback),
            },
            FieldInfoData {
                name: "IgnoreFirstInterval",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, ignore_first_interval),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: EVENTSEQUENCERNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerNodeData, version),
            },
        ],
    }),
    array_type: Some(EVENTSEQUENCERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSequencerNodeData {
    fn type_info() -> &'static TypeInfo {
        EVENTSEQUENCERNODEDATA_TYPE_INFO
    }
}


pub const EVENTSEQUENCERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventSequencerOutEvent {
    pub out: AudioGraphNodePort,
}

pub const EVENTSEQUENCEROUTEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerOutEvent",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSequencerOutEvent, out),
            },
        ],
    }),
    array_type: Some(EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSequencerOutEvent {
    fn type_info() -> &'static TypeInfo {
        EVENTSEQUENCEROUTEVENT_TYPE_INFO
    }
}


pub const EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerOutEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerOutEvent-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum EventSequencerPlayback {
    #[default]
    EventSequencerPlayback_Sequential = 0,
    EventSequencerPlayback_Simultaneous = 1,
    EventSequencerPlayback_Random = 2,
}

pub const EVENTSEQUENCERPLAYBACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerPlayback",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTSEQUENCERPLAYBACK_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventSequencerPlayback {
    fn type_info() -> &'static TypeInfo {
        EVENTSEQUENCERPLAYBACK_TYPE_INFO
    }
}


pub const EVENTSEQUENCERPLAYBACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerPlayback-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerPlayback-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum EventSequencerNodeVersion {
    #[default]
    EventSequencerNodeVersion_2012_2 = 0,
    EventSequencerNodeVersion_2014_5 = 1,
    EventSequencerNodeVersion_2015_1 = 2,
}

pub const EVENTSEQUENCERNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTSEQUENCERNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventSequencerNodeVersion {
    fn type_info() -> &'static TypeInfo {
        EVENTSEQUENCERNODEVERSION_TYPE_INFO
    }
}


pub const EVENTSEQUENCERNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ValueSelectorNodeData {
    pub inputs: Vec<ValueSelectorEntry>,
    pub value: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub default_case_value: f32,
}

pub const VALUESELECTORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: VALUESELECTORENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ValueSelectorNodeData, inputs),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ValueSelectorNodeData, value),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ValueSelectorNodeData, out),
            },
            FieldInfoData {
                name: "DefaultCaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ValueSelectorNodeData, default_case_value),
            },
        ],
    }),
    array_type: Some(VALUESELECTORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueSelectorNodeData {
    fn type_info() -> &'static TypeInfo {
        VALUESELECTORNODEDATA_TYPE_INFO
    }
}


pub const VALUESELECTORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueSelectorNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ValueSelectorEntry {
    pub input: AudioGraphNodePort,
    pub case_value: f32,
}

pub const VALUESELECTORENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ValueSelectorEntry, input),
            },
            FieldInfoData {
                name: "CaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ValueSelectorEntry, case_value),
            },
        ],
    }),
    array_type: Some(VALUESELECTORENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueSelectorEntry {
    fn type_info() -> &'static TypeInfo {
        VALUESELECTORENTRY_TYPE_INFO
    }
}


pub const VALUESELECTORENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueSelectorEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TimerNodeConfigData {
    pub period: f32,
    pub mode: TimerMode,
    pub progress_output: ProgressMode,
}

pub const TIMERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Period",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeConfigData, period),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: TIMERMODE_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeConfigData, mode),
            },
            FieldInfoData {
                name: "ProgressOutput",
                flags: MemberInfoFlags::new(0),
                field_type: PROGRESSMODE_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeConfigData, progress_output),
            },
        ],
    }),
    array_type: Some(TIMERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TimerNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        TIMERNODECONFIGDATA_TYPE_INFO
    }
}


pub const TIMERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TimerNodeData {
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub period: AudioGraphNodePort,
    pub tick: AudioGraphNodePort,
    pub progress: AudioGraphNodePort,
    pub mode: TimerMode,
    pub progress_output: ProgressMode,
    pub version: TimerNodeVersion,
}

pub const TIMERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, stop),
            },
            FieldInfoData {
                name: "Period",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, period),
            },
            FieldInfoData {
                name: "Tick",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, tick),
            },
            FieldInfoData {
                name: "Progress",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, progress),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: TIMERMODE_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, mode),
            },
            FieldInfoData {
                name: "ProgressOutput",
                flags: MemberInfoFlags::new(0),
                field_type: PROGRESSMODE_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, progress_output),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: TIMERNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(TimerNodeData, version),
            },
        ],
    }),
    array_type: Some(TIMERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TimerNodeData {
    fn type_info() -> &'static TypeInfo {
        TIMERNODEDATA_TYPE_INFO
    }
}


pub const TIMERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ProgressMode {
    #[default]
    ProgressMode_Normalized = 0,
    ProgressMode_Time = 1,
}

pub const PROGRESSMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProgressMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PROGRESSMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ProgressMode {
    fn type_info() -> &'static TypeInfo {
        PROGRESSMODE_TYPE_INFO
    }
}


pub const PROGRESSMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProgressMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ProgressMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TimerMode {
    #[default]
    TimerMode_Repeating = 0,
    TimerMode_SingleShot = 1,
}

pub const TIMERMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMERMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimerMode {
    fn type_info() -> &'static TypeInfo {
        TIMERMODE_TYPE_INFO
    }
}


pub const TIMERMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TimerNodeVersion {
    #[default]
    TimerNodeVersion_2012_4 = 0,
    TimerNodeVersion_2015_3 = 1,
    TimerNodeVersion_2016_4 = 2,
}

pub const TIMERNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMERNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimerNodeVersion {
    fn type_info() -> &'static TypeInfo {
        TIMERNODEVERSION_TYPE_INFO
    }
}


pub const TIMERNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SwitcherNodeData {
    pub outputs: Vec<SwitcherEntry>,
    pub trigger: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub default_case_value: f32,
}

pub const SWITCHERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: SWITCHERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SwitcherNodeData, outputs),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SwitcherNodeData, trigger),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SwitcherNodeData, value),
            },
            FieldInfoData {
                name: "DefaultCaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SwitcherNodeData, default_case_value),
            },
        ],
    }),
    array_type: Some(SWITCHERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitcherNodeData {
    fn type_info() -> &'static TypeInfo {
        SWITCHERNODEDATA_TYPE_INFO
    }
}


pub const SWITCHERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SwitcherNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SwitcherEntry {
    pub case_trigger: AudioGraphNodePort,
    pub case_value: f32,
}

pub const SWITCHERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CaseTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SwitcherEntry, case_trigger),
            },
            FieldInfoData {
                name: "CaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SwitcherEntry, case_value),
            },
        ],
    }),
    array_type: Some(SWITCHERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitcherEntry {
    fn type_info() -> &'static TypeInfo {
        SWITCHERENTRY_TYPE_INFO
    }
}


pub const SWITCHERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SwitcherEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SimpleValueSelectorNodeConfigData {
    pub out_values: Vec<f32>,
}

pub const SIMPLEVALUESELECTORNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OutValues",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SimpleValueSelectorNodeConfigData, out_values),
            },
        ],
    }),
    array_type: Some(SIMPLEVALUESELECTORNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleValueSelectorNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        SIMPLEVALUESELECTORNODECONFIGDATA_TYPE_INFO
    }
}


pub const SIMPLEVALUESELECTORNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleValueSelectorNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SimpleValueSelectorNodeData {
    pub out_values: Vec<f32>,
    pub index: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub const SIMPLEVALUESELECTORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OutValues",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SimpleValueSelectorNodeData, out_values),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SimpleValueSelectorNodeData, index),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SimpleValueSelectorNodeData, out),
            },
        ],
    }),
    array_type: Some(SIMPLEVALUESELECTORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleValueSelectorNodeData {
    fn type_info() -> &'static TypeInfo {
        SIMPLEVALUESELECTORNODEDATA_TYPE_INFO
    }
}


pub const SIMPLEVALUESELECTORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleValueSelectorNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultipleTransformNodeData {
    pub x: AudioGraphNodePort,
    pub transforms: Vec<MultipleTransformEntry>,
    pub result: AudioGraphNodePort,
}

pub const MULTIPLETRANSFORMNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformNodeData, x),
            },
            FieldInfoData {
                name: "Transforms",
                flags: MemberInfoFlags::new(144),
                field_type: MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformNodeData, transforms),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformNodeData, result),
            },
        ],
    }),
    array_type: Some(MULTIPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultipleTransformNodeData {
    fn type_info() -> &'static TypeInfo {
        MULTIPLETRANSFORMNODEDATA_TYPE_INFO
    }
}


pub const MULTIPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultipleTransformNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultipleTransformEntry {
    pub y: AudioGraphNodePort,
    pub z: AudioGraphNodePort,
    pub operation: SimpleTransformOperation,
    pub angle_unit: AngleUnit,
}

pub const MULTIPLETRANSFORMENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformEntry, y),
            },
            FieldInfoData {
                name: "Z",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformEntry, z),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: SIMPLETRANSFORMOPERATION_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformEntry, operation),
            },
            FieldInfoData {
                name: "AngleUnit",
                flags: MemberInfoFlags::new(0),
                field_type: ANGLEUNIT_TYPE_INFO,
                rust_offset: offset_of!(MultipleTransformEntry, angle_unit),
            },
        ],
    }),
    array_type: Some(MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultipleTransformEntry {
    fn type_info() -> &'static TypeInfo {
        MULTIPLETRANSFORMENTRY_TYPE_INFO
    }
}


pub const MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultipleTransformEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SimpleTransformNodeData {
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub z: AudioGraphNodePort,
    pub operation: SimpleTransformOperation,
    pub angle_unit: AngleUnit,
}

pub const SIMPLETRANSFORMNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SimpleTransformNodeData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SimpleTransformNodeData, y),
            },
            FieldInfoData {
                name: "Z",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SimpleTransformNodeData, z),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: SIMPLETRANSFORMOPERATION_TYPE_INFO,
                rust_offset: offset_of!(SimpleTransformNodeData, operation),
            },
            FieldInfoData {
                name: "AngleUnit",
                flags: MemberInfoFlags::new(0),
                field_type: ANGLEUNIT_TYPE_INFO,
                rust_offset: offset_of!(SimpleTransformNodeData, angle_unit),
            },
        ],
    }),
    array_type: Some(SIMPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleTransformNodeData {
    fn type_info() -> &'static TypeInfo {
        SIMPLETRANSFORMNODEDATA_TYPE_INFO
    }
}


pub const SIMPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleTransformNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AngleUnit {
    #[default]
    AngleUnit_Radians = 0,
    AngleUnit_Degrees = 1,
}

pub const ANGLEUNIT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleUnit",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(ANGLEUNIT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AngleUnit {
    fn type_info() -> &'static TypeInfo {
        ANGLEUNIT_TYPE_INFO
    }
}


pub const ANGLEUNIT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleUnit-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AngleUnit-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SimpleTransformOperation {
    #[default]
    SimpleTransformOperation_Add = 0,
    SimpleTransformOperation_Subtract = 1,
    SimpleTransformOperation_Multiply = 2,
    SimpleTransformOperation_Divide = 3,
    SimpleTransformOperation_Sine = 4,
    SimpleTransformOperation_Cosine = 5,
    SimpleTransformOperation_ArcSine = 6,
    SimpleTransformOperation_ArcCosine = 7,
    SimpleTransformOperation_Modulus = 8,
    SimpleTransformOperation_Round = 9,
    SimpleTransformOperation_Floor = 10,
    SimpleTransformOperation_Ceiling = 11,
    SimpleTransformOperation_Power = 12,
    SimpleTransformOperation_SquareRoot = 13,
    SimpleTransformOperation_Absolute = 14,
    SimpleTransformOperation_Exp = 15,
    SimpleTransformOperation_Log = 16,
    SimpleTransformOperation_Log10 = 17,
    SimpleTransformOperation_Tangent = 18,
    SimpleTransformOperation_ArcTangent = 19,
    SimpleTransformOperation_LinearToDb = 20,
    SimpleTransformOperation_DbToLinear = 21,
}

pub const SIMPLETRANSFORMOPERATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformOperation",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SIMPLETRANSFORMOPERATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SimpleTransformOperation {
    fn type_info() -> &'static TypeInfo {
        SIMPLETRANSFORMOPERATION_TYPE_INFO
    }
}


pub const SIMPLETRANSFORMOPERATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformOperation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleTransformOperation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SequenceGeneratorNodeData {
    pub trigger: AudioGraphNodePort,
    pub reset: AudioGraphNodePort,
    pub min: AudioGraphNodePort,
    pub max: AudioGraphNodePort,
    pub step: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub update_value_on_events: bool,
}

pub const SEQUENCEGENERATORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceGeneratorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, trigger),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, reset),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, max),
            },
            FieldInfoData {
                name: "Step",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, step),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, value),
            },
            FieldInfoData {
                name: "UpdateValueOnEvents",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SequenceGeneratorNodeData, update_value_on_events),
            },
        ],
    }),
    array_type: Some(SEQUENCEGENERATORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SequenceGeneratorNodeData {
    fn type_info() -> &'static TypeInfo {
        SEQUENCEGENERATORNODEDATA_TYPE_INFO
    }
}


pub const SEQUENCEGENERATORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceGeneratorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SequenceGeneratorNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SendNodeData {
    pub entries: Vec<SendEntry>,
}

pub const SENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: SENDENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SendNodeData, entries),
            },
        ],
    }),
    array_type: Some(SENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SendNodeData {
    fn type_info() -> &'static TypeInfo {
        SENDNODEDATA_TYPE_INFO
    }
}


pub const SENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SendNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SendEntry {
    pub r#in: AudioGraphNodePort,
    pub target: AudioGraphParameter,
}

pub const SENDENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SendEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(SendEntry, target),
            },
        ],
    }),
    array_type: Some(SENDENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SendEntry {
    fn type_info() -> &'static TypeInfo {
        SENDENTRY_TYPE_INFO
    }
}


pub const SENDENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SendEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ScaleClampNodeConfigData {
    pub in_min: f32,
    pub in_max: f32,
    pub out_min: f32,
    pub out_max: f32,
}

pub const SCALECLAMPNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "InMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeConfigData, in_min),
            },
            FieldInfoData {
                name: "InMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeConfigData, in_max),
            },
            FieldInfoData {
                name: "OutMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeConfigData, out_min),
            },
            FieldInfoData {
                name: "OutMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeConfigData, out_max),
            },
        ],
    }),
    array_type: Some(SCALECLAMPNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScaleClampNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        SCALECLAMPNODECONFIGDATA_TYPE_INFO
    }
}


pub const SCALECLAMPNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScaleClampNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ScaleClampNodeData {
    pub r#in: AudioGraphNodePort,
    pub in_min: AudioGraphNodePort,
    pub in_max: AudioGraphNodePort,
    pub out_min: AudioGraphNodePort,
    pub out_max: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub const SCALECLAMPNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeData, r#in),
            },
            FieldInfoData {
                name: "InMin",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeData, in_min),
            },
            FieldInfoData {
                name: "InMax",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeData, in_max),
            },
            FieldInfoData {
                name: "OutMin",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeData, out_min),
            },
            FieldInfoData {
                name: "OutMax",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeData, out_max),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ScaleClampNodeData, out),
            },
        ],
    }),
    array_type: Some(SCALECLAMPNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScaleClampNodeData {
    fn type_info() -> &'static TypeInfo {
        SCALECLAMPNODEDATA_TYPE_INFO
    }
}


pub const SCALECLAMPNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScaleClampNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ContextSendNodeData {
    pub entries: Vec<SoundContextSendEntry>,
}

pub const CONTEXTSENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextSendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ContextSendNodeData, entries),
            },
        ],
    }),
    array_type: Some(CONTEXTSENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextSendNodeData {
    fn type_info() -> &'static TypeInfo {
        CONTEXTSENDNODEDATA_TYPE_INFO
    }
}


pub const CONTEXTSENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextSendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ContextSendNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundContextSendEntry {
    pub r#in: AudioGraphNodePort,
    pub context: SoundContextData,
}

pub const SOUNDCONTEXTSENDENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSendEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SoundContextSendEntry, r#in),
            },
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundContextSendEntry, context),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextSendEntry {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTSENDENTRY_TYPE_INFO
    }
}


pub const SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSendEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextSendEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ContextReceiveNodeData {
    pub entries: Vec<SoundContextReceiveEntry>,
}

pub const CONTEXTRECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ContextReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(CONTEXTRECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextReceiveNodeData {
    fn type_info() -> &'static TypeInfo {
        CONTEXTRECEIVENODEDATA_TYPE_INFO
    }
}


pub const CONTEXTRECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ContextReceiveNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundContextReceiveEntry {
    pub out: AudioGraphNodePort,
    pub context: SoundContextData,
}

pub const SOUNDCONTEXTRECEIVEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextReceiveEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SoundContextReceiveEntry, out),
            },
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundContextReceiveEntry, context),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextReceiveEntry {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTRECEIVEENTRY_TYPE_INFO
    }
}


pub const SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextReceiveEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextReceiveEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ReceiveNodeData {
    pub entries: Vec<ReceiveEntry>,
}

pub const RECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: RECEIVEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(RECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReceiveNodeData {
    fn type_info() -> &'static TypeInfo {
        RECEIVENODEDATA_TYPE_INFO
    }
}


pub const RECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ReceiveNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ReceiveEntry {
    pub out: AudioGraphNodePort,
    pub source: AudioGraphParameter,
    pub parameter: f32,
    pub saved_value: f32,
}

pub const RECEIVEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ReceiveEntry, out),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(ReceiveEntry, source),
            },
            FieldInfoData {
                name: "Parameter",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ReceiveEntry, parameter),
            },
            FieldInfoData {
                name: "SavedValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ReceiveEntry, saved_value),
            },
        ],
    }),
    array_type: Some(RECEIVEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReceiveEntry {
    fn type_info() -> &'static TypeInfo {
        RECEIVEENTRY_TYPE_INFO
    }
}


pub const RECEIVEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ReceiveEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct RangeMapperNodeConfigData {
    pub ranges: Vec<RangeMapperConfigEntry>,
}

pub const RANGEMAPPERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Ranges",
                flags: MemberInfoFlags::new(144),
                field_type: RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperNodeConfigData, ranges),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RangeMapperNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        RANGEMAPPERNODECONFIGDATA_TYPE_INFO
    }
}


pub const RANGEMAPPERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct RangeMapperConfigEntry {
    pub range_start: f32,
    pub range_end: f32,
    pub output_value: f32,
}

pub const RANGEMAPPERCONFIGENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperConfigEntry",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "RangeStart",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperConfigEntry, range_start),
            },
            FieldInfoData {
                name: "RangeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperConfigEntry, range_end),
            },
            FieldInfoData {
                name: "OutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperConfigEntry, output_value),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RangeMapperConfigEntry {
    fn type_info() -> &'static TypeInfo {
        RANGEMAPPERCONFIGENTRY_TYPE_INFO
    }
}


pub const RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperConfigEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperConfigEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct RangeMapperNodeData {
    pub r#in: AudioGraphNodePort,
    pub default_output_value: AudioGraphNodePort,
    pub ranges: Vec<RangeMapperEntry>,
    pub out: AudioGraphNodePort,
    pub default_output_value_enabled: bool,
}

pub const RANGEMAPPERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperNodeData, r#in),
            },
            FieldInfoData {
                name: "DefaultOutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperNodeData, default_output_value),
            },
            FieldInfoData {
                name: "Ranges",
                flags: MemberInfoFlags::new(144),
                field_type: RANGEMAPPERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperNodeData, ranges),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperNodeData, out),
            },
            FieldInfoData {
                name: "DefaultOutputValueEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperNodeData, default_output_value_enabled),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RangeMapperNodeData {
    fn type_info() -> &'static TypeInfo {
        RANGEMAPPERNODEDATA_TYPE_INFO
    }
}


pub const RANGEMAPPERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct RangeMapperEntry {
    pub range_start: AudioGraphNodePort,
    pub range_end: AudioGraphNodePort,
    pub output_value: AudioGraphNodePort,
}

pub const RANGEMAPPERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RangeStart",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperEntry, range_start),
            },
            FieldInfoData {
                name: "RangeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperEntry, range_end),
            },
            FieldInfoData {
                name: "OutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RangeMapperEntry, output_value),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RangeMapperEntry {
    fn type_info() -> &'static TypeInfo {
        RANGEMAPPERENTRY_TYPE_INFO
    }
}


pub const RANGEMAPPERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterFilterLinearNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub attack_speed: AudioGraphNodePort,
    pub release_speed: AudioGraphNodePort,
    pub default_output_value: f32,
    pub keep_active: bool,
    pub skip_first_update: bool,
}

pub const PARAMETERFILTERLINEARNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLinearNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, out),
            },
            FieldInfoData {
                name: "AttackSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, attack_speed),
            },
            FieldInfoData {
                name: "ReleaseSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, release_speed),
            },
            FieldInfoData {
                name: "DefaultOutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, default_output_value),
            },
            FieldInfoData {
                name: "KeepActive",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, keep_active),
            },
            FieldInfoData {
                name: "SkipFirstUpdate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLinearNodeData, skip_first_update),
            },
        ],
    }),
    array_type: Some(PARAMETERFILTERLINEARNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterFilterLinearNodeData {
    fn type_info() -> &'static TypeInfo {
        PARAMETERFILTERLINEARNODEDATA_TYPE_INFO
    }
}


pub const PARAMETERFILTERLINEARNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLinearNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterFilterLinearNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterFilterLpNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub hz: AudioGraphNodePort,
    pub version: ParameterFilterLpNodeVersion,
}

pub const PARAMETERFILTERLPNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLpNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLpNodeData, out),
            },
            FieldInfoData {
                name: "Hz",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLpNodeData, hz),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: PARAMETERFILTERLPNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(ParameterFilterLpNodeData, version),
            },
        ],
    }),
    array_type: Some(PARAMETERFILTERLPNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterFilterLpNodeData {
    fn type_info() -> &'static TypeInfo {
        PARAMETERFILTERLPNODEDATA_TYPE_INFO
    }
}


pub const PARAMETERFILTERLPNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterFilterLpNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ParameterFilterLpNodeVersion {
    #[default]
    ParameterFilterLpNodeVersion_2010_2 = 0,
    ParameterFilterLpNodeVersion_2012_5 = 1,
    ParameterFilterLpNodeVersion_2015_1 = 2,
}

pub const PARAMETERFILTERLPNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PARAMETERFILTERLPNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ParameterFilterLpNodeVersion {
    fn type_info() -> &'static TypeInfo {
        PARAMETERFILTERLPNODEVERSION_TYPE_INFO
    }
}


pub const PARAMETERFILTERLPNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterFilterLpNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterDelayNodeData {
    pub parameters: Vec<ParameterDelayNodeEntry>,
    pub delay_time: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub max_updates_per_second: u32,
}

pub const PARAMETERDELAYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeData, parameters),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeData, delay_time),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "MaxUpdatesPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeData, max_updates_per_second),
            },
        ],
    }),
    array_type: Some(PARAMETERDELAYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterDelayNodeData {
    fn type_info() -> &'static TypeInfo {
        PARAMETERDELAYNODEDATA_TYPE_INFO
    }
}


pub const PARAMETERDELAYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterDelayNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterDelayNodeEntry {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub default_value: f32,
}

pub const PARAMETERDELAYNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeEntry, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeEntry, out),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ParameterDelayNodeEntry, default_value),
            },
        ],
    }),
    array_type: Some(PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterDelayNodeEntry {
    fn type_info() -> &'static TypeInfo {
        PARAMETERDELAYNODEENTRY_TYPE_INFO
    }
}


pub const PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterDelayNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct NumberGeneratorNodeConfigData {
    pub min: f32,
    pub max: f32,
}

pub const NUMBERGENERATORNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeConfigData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeConfigData, max),
            },
        ],
    }),
    array_type: Some(NUMBERGENERATORNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NumberGeneratorNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        NUMBERGENERATORNODECONFIGDATA_TYPE_INFO
    }
}


pub const NUMBERGENERATORNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct NumberGeneratorNodeData {
    pub trigger: AudioGraphNodePort,
    pub min: AudioGraphNodePort,
    pub max: AudioGraphNodePort,
    pub mode: NumberGeneratorMode,
    pub y: AudioGraphNodePort,
    pub version: NumberGeneratorNodeVersion,
}

pub const NUMBERGENERATORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeData, trigger),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeData, max),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: NUMBERGENERATORMODE_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeData, mode),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeData, y),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: NUMBERGENERATORNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(NumberGeneratorNodeData, version),
            },
        ],
    }),
    array_type: Some(NUMBERGENERATORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NumberGeneratorNodeData {
    fn type_info() -> &'static TypeInfo {
        NUMBERGENERATORNODEDATA_TYPE_INFO
    }
}


pub const NUMBERGENERATORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum NumberGeneratorMode {
    #[default]
    NumberGeneratorMode_RandomUniform = 0,
}

pub const NUMBERGENERATORMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(NUMBERGENERATORMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for NumberGeneratorMode {
    fn type_info() -> &'static TypeInfo {
        NUMBERGENERATORMODE_TYPE_INFO
    }
}


pub const NUMBERGENERATORMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum NumberGeneratorNodeVersion {
    #[default]
    NumberGeneratorNodeVersion_2010_2 = 0,
    NumberGeneratorNodeVersion_2013_1 = 1,
}

pub const NUMBERGENERATORNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(NUMBERGENERATORNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for NumberGeneratorNodeVersion {
    fn type_info() -> &'static TypeInfo {
        NUMBERGENERATORNODEVERSION_TYPE_INFO
    }
}


pub const NUMBERGENERATORNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultiCrossfaderNodeConfigData {
    pub crossfader_config_groups: Vec<MultiCrossfaderConfigGroup>,
}

pub const MULTICROSSFADERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CrossfaderConfigGroups",
                flags: MemberInfoFlags::new(144),
                field_type: MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderNodeConfigData, crossfader_config_groups),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiCrossfaderNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        MULTICROSSFADERNODECONFIGDATA_TYPE_INFO
    }
}


pub const MULTICROSSFADERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultiCrossfaderConfigGroup {
    pub fade_amplitude: f32,
    pub fade_begin: f32,
    pub fade_end: f32,
    pub fade_type: FaderType,
}

pub const MULTICROSSFADERCONFIGGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderConfigGroup",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "FadeAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_amplitude),
            },
            FieldInfoData {
                name: "FadeBegin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_begin),
            },
            FieldInfoData {
                name: "FadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_end),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: FADERTYPE_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_type),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MultiCrossfaderConfigGroup {
    fn type_info() -> &'static TypeInfo {
        MULTICROSSFADERCONFIGGROUP_TYPE_INFO
    }
}


pub const MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderConfigGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderConfigGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultiCrossfaderNodeData {
    pub crossfader_groups: Vec<MultiCrossfaderGroup>,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub control: AudioGraphNodePort,
    pub lock_control_value: bool,
}

pub const MULTICROSSFADERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CrossfaderGroups",
                flags: MemberInfoFlags::new(144),
                field_type: MULTICROSSFADERGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderNodeData, crossfader_groups),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderNodeData, stop),
            },
            FieldInfoData {
                name: "Control",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderNodeData, control),
            },
            FieldInfoData {
                name: "LockControlValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderNodeData, lock_control_value),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiCrossfaderNodeData {
    fn type_info() -> &'static TypeInfo {
        MULTICROSSFADERNODEDATA_TYPE_INFO
    }
}


pub const MULTICROSSFADERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultiCrossfaderGroup {
    pub amplitude: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub fade_amplitude: f32,
    pub fade_begin: f32,
    pub fade_end: f32,
    pub fade_type: FaderType,
}

pub const MULTICROSSFADERGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, amplitude),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, stop),
            },
            FieldInfoData {
                name: "FadeAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_amplitude),
            },
            FieldInfoData {
                name: "FadeBegin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_begin),
            },
            FieldInfoData {
                name: "FadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_end),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: FADERTYPE_TYPE_INFO,
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_type),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiCrossfaderGroup {
    fn type_info() -> &'static TypeInfo {
        MULTICROSSFADERGROUP_TYPE_INFO
    }
}


pub const MULTICROSSFADERGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum FaderType {
    #[default]
    FaderType_Linear = 0,
    FaderType_Cosine = 1,
}

pub const FADERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaderType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FADERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FaderType {
    fn type_info() -> &'static TypeInfo {
        FADERTYPE_TYPE_INFO
    }
}


pub const FADERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaderType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FaderType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MinMaxValueSelectorNodeData {
    pub inputs: Vec<MinMaxValueSelectorEntry>,
    pub max_value: AudioGraphNodePort,
    pub max_index: AudioGraphNodePort,
    pub min_value: AudioGraphNodePort,
    pub min_index: AudioGraphNodePort,
}

pub const MINMAXVALUESELECTORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, inputs),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, max_value),
            },
            FieldInfoData {
                name: "MaxIndex",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, max_index),
            },
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, min_value),
            },
            FieldInfoData {
                name: "MinIndex",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, min_index),
            },
        ],
    }),
    array_type: Some(MINMAXVALUESELECTORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MinMaxValueSelectorNodeData {
    fn type_info() -> &'static TypeInfo {
        MINMAXVALUESELECTORNODEDATA_TYPE_INFO
    }
}


pub const MINMAXVALUESELECTORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MinMaxValueSelectorNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MinMaxValueSelectorEntry {
    pub input: AudioGraphNodePort,
}

pub const MINMAXVALUESELECTORENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxValueSelectorEntry, input),
            },
        ],
    }),
    array_type: Some(MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MinMaxValueSelectorEntry {
    fn type_info() -> &'static TypeInfo {
        MINMAXVALUESELECTORENTRY_TYPE_INFO
    }
}


pub const MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MinMaxValueSelectorEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MinMaxNodeData {
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub max: AudioGraphNodePort,
    pub min: AudioGraphNodePort,
}

pub const MINMAXNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxNodeData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxNodeData, y),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxNodeData, max),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MinMaxNodeData, min),
            },
        ],
    }),
    array_type: Some(MINMAXNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MinMaxNodeData {
    fn type_info() -> &'static TypeInfo {
        MINMAXNODEDATA_TYPE_INFO
    }
}


pub const MINMAXNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MinMaxNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LogicalExpressionNodeData {
    pub reset: AudioGraphNodePort,
    pub inputs: Vec<LogicalExpressionEntry>,
    pub trigger: AudioGraphNodePort,
    pub operator: LogicalExpressionOperator,
}

pub const LOGICALEXPRESSIONNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LogicalExpressionNodeData, reset),
            },
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LogicalExpressionNodeData, inputs),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LogicalExpressionNodeData, trigger),
            },
            FieldInfoData {
                name: "Operator",
                flags: MemberInfoFlags::new(0),
                field_type: LOGICALEXPRESSIONOPERATOR_TYPE_INFO,
                rust_offset: offset_of!(LogicalExpressionNodeData, operator),
            },
        ],
    }),
    array_type: Some(LOGICALEXPRESSIONNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicalExpressionNodeData {
    fn type_info() -> &'static TypeInfo {
        LOGICALEXPRESSIONNODEDATA_TYPE_INFO
    }
}


pub const LOGICALEXPRESSIONNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicalExpressionNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum LogicalExpressionOperator {
    #[default]
    LogicalExpressionOperator_And = 0,
    LogicalExpressionOperator_Or = 1,
    LogicalExpressionOperator_Nand = 2,
    LogicalExpressionOperator_Nor = 3,
    LogicalExpressionOperator_And2 = 4,
}

pub const LOGICALEXPRESSIONOPERATOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionOperator",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LOGICALEXPRESSIONOPERATOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LogicalExpressionOperator {
    fn type_info() -> &'static TypeInfo {
        LOGICALEXPRESSIONOPERATOR_TYPE_INFO
    }
}


pub const LOGICALEXPRESSIONOPERATOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionOperator-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicalExpressionOperator-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LogicalExpressionEntry {
    pub trigger: AudioGraphNodePort,
}

pub const LOGICALEXPRESSIONENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LogicalExpressionEntry, trigger),
            },
        ],
    }),
    array_type: Some(LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicalExpressionEntry {
    fn type_info() -> &'static TypeInfo {
        LOGICALEXPRESSIONENTRY_TYPE_INFO
    }
}


pub const LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicalExpressionEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendAudioNodeData {
    pub audio_entries: Vec<LinkSendAudioNodeEntry>,
}

pub const LINKSENDAUDIONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AudioEntries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkSendAudioNodeData, audio_entries),
            },
        ],
    }),
    array_type: Some(LINKSENDAUDIONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAudioNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKSENDAUDIONODEDATA_TYPE_INFO
    }
}


pub const LINKSENDAUDIONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAudioNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendAudioNodeEntry {
    pub input: AudioGraphNodePort,
    pub send_audio_name: String,
}

pub const LINKSENDAUDIONODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkSendAudioNodeEntry, input),
            },
            FieldInfoData {
                name: "SendAudioName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LinkSendAudioNodeEntry, send_audio_name),
            },
        ],
    }),
    array_type: Some(LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAudioNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKSENDAUDIONODEENTRY_TYPE_INFO
    }
}


pub const LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAudioNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveAudioNodeData {
    pub audio_entries: Vec<LinkReceiveAudioNodeEntry>,
}

pub const LINKRECEIVEAUDIONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AudioEntries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveAudioNodeData, audio_entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEAUDIONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAudioNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVEAUDIONODEDATA_TYPE_INFO
    }
}


pub const LINKRECEIVEAUDIONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAudioNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveAudioNodeEntry {
    pub output: AudioGraphNodePort,
    pub audio_sender: LinkSendAudioNodeEntry,
}

pub const LINKRECEIVEAUDIONODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveAudioNodeEntry, output),
            },
            FieldInfoData {
                name: "AudioSender",
                flags: MemberInfoFlags::new(0),
                field_type: LINKSENDAUDIONODEENTRY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveAudioNodeEntry, audio_sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAudioNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVEAUDIONODEENTRY_TYPE_INFO
    }
}


pub const LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAudioNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendAssetNodeData {
    pub asset_entries: Vec<LinkSendAssetNodeEntry>,
}

pub const LINKSENDASSETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AssetEntries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkSendAssetNodeData, asset_entries),
            },
        ],
    }),
    array_type: Some(LINKSENDASSETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAssetNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKSENDASSETNODEDATA_TYPE_INFO
    }
}


pub const LINKSENDASSETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAssetNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendAssetNodeEntry {
    pub input: AudioGraphNodePort,
    pub send_asset_name: String,
}

pub const LINKSENDASSETNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkSendAssetNodeEntry, input),
            },
            FieldInfoData {
                name: "SendAssetName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LinkSendAssetNodeEntry, send_asset_name),
            },
        ],
    }),
    array_type: Some(LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAssetNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKSENDASSETNODEENTRY_TYPE_INFO
    }
}


pub const LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAssetNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveAssetNodeData {
    pub asset_entries: Vec<LinkReceiveAssetNodeEntry>,
}

pub const LINKRECEIVEASSETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "AssetEntries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveAssetNodeData, asset_entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEASSETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAssetNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVEASSETNODEDATA_TYPE_INFO
    }
}


pub const LINKRECEIVEASSETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAssetNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveAssetNodeEntry {
    pub output: AudioGraphNodePort,
    pub asset_sender: LinkSendAssetNodeEntry,
}

pub const LINKRECEIVEASSETNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveAssetNodeEntry, output),
            },
            FieldInfoData {
                name: "AssetSender",
                flags: MemberInfoFlags::new(0),
                field_type: LINKSENDASSETNODEENTRY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveAssetNodeEntry, asset_sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAssetNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVEASSETNODEENTRY_TYPE_INFO
    }
}


pub const LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAssetNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendEventNodeData {
    pub event_entries: Vec<LinkSendEventNodeEntry>,
}

pub const LINKSENDEVENTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EventEntries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkSendEventNodeData, event_entries),
            },
        ],
    }),
    array_type: Some(LINKSENDEVENTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendEventNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKSENDEVENTNODEDATA_TYPE_INFO
    }
}


pub const LINKSENDEVENTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendEventNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendEventNodeEntry {
    pub input: AudioGraphNodePort,
    pub send_event_name: String,
}

pub const LINKSENDEVENTNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkSendEventNodeEntry, input),
            },
            FieldInfoData {
                name: "SendEventName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LinkSendEventNodeEntry, send_event_name),
            },
        ],
    }),
    array_type: Some(LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendEventNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKSENDEVENTNODEENTRY_TYPE_INFO
    }
}


pub const LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendEventNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveEventNodeData {
    pub event_entries: Vec<LinkReceiveEventNodeEntry>,
}

pub const LINKRECEIVEEVENTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EventEntries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveEventNodeData, event_entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEEVENTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveEventNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVEEVENTNODEDATA_TYPE_INFO
    }
}


pub const LINKRECEIVEEVENTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveEventNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveEventNodeEntry {
    pub output: AudioGraphNodePort,
    pub event_sender: LinkSendEventNodeEntry,
}

pub const LINKRECEIVEEVENTNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveEventNodeEntry, output),
            },
            FieldInfoData {
                name: "EventSender",
                flags: MemberInfoFlags::new(0),
                field_type: LINKSENDEVENTNODEENTRY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveEventNodeEntry, event_sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveEventNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVEEVENTNODEENTRY_TYPE_INFO
    }
}


pub const LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveEventNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendNodeData {
    pub entries: Vec<LinkSendNodeEntry>,
}

pub const LINKSENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKSENDNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkSendNodeData, entries),
            },
        ],
    }),
    array_type: Some(LINKSENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKSENDNODEDATA_TYPE_INFO
    }
}


pub const LINKSENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkSendNodeEntry {
    pub input: AudioGraphNodePort,
    pub send_name: String,
}

pub const LINKSENDNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkSendNodeEntry, input),
            },
            FieldInfoData {
                name: "SendName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LinkSendNodeEntry, send_name),
            },
        ],
    }),
    array_type: Some(LINKSENDNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKSENDNODEENTRY_TYPE_INFO
    }
}


pub const LINKSENDNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveNodeData {
    pub entries: Vec<LinkReceiveNodeEntry>,
}

pub const LINKRECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveNodeData {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVENODEDATA_TYPE_INFO
    }
}


pub const LINKRECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinkReceiveNodeEntry {
    pub output: AudioGraphNodePort,
    pub sender: LinkSendNodeEntry,
}

pub const LINKRECEIVENODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveNodeEntry, output),
            },
            FieldInfoData {
                name: "Sender",
                flags: MemberInfoFlags::new(0),
                field_type: LINKSENDNODEENTRY_TYPE_INFO,
                rust_offset: offset_of!(LinkReceiveNodeEntry, sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveNodeEntry {
    fn type_info() -> &'static TypeInfo {
        LINKRECEIVENODEENTRY_TYPE_INFO
    }
}


pub const LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LinearTransformNodeData {
    pub x: AudioGraphNodePort,
    pub k: AudioGraphNodePort,
    pub m: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
}

pub const LINEARTRANSFORMNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTransformNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinearTransformNodeData, x),
            },
            FieldInfoData {
                name: "K",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinearTransformNodeData, k),
            },
            FieldInfoData {
                name: "M",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinearTransformNodeData, m),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LinearTransformNodeData, y),
            },
        ],
    }),
    array_type: Some(LINEARTRANSFORMNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinearTransformNodeData {
    fn type_info() -> &'static TypeInfo {
        LINEARTRANSFORMNODEDATA_TYPE_INFO
    }
}


pub const LINEARTRANSFORMNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTransformNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinearTransformNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LfoNodeData {
    pub hz: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub min: f32,
    pub max: f32,
    pub start_at_random_value: bool,
}

pub const LFONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LfoNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Hz",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LfoNodeData, hz),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LfoNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LfoNodeData, out),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LfoNodeData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(LfoNodeData, max),
            },
            FieldInfoData {
                name: "StartAtRandomValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(LfoNodeData, start_at_random_value),
            },
        ],
    }),
    array_type: Some(LFONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LfoNodeData {
    fn type_info() -> &'static TypeInfo {
        LFONODEDATA_TYPE_INFO
    }
}


pub const LFONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LfoNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LfoNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FollowEnvelopeNodeData {
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub base: f32,
    pub scale: f32,
    pub pivot: f32,
}

pub const FOLLOWENVELOPENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowEnvelopeNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FollowEnvelopeNodeData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FollowEnvelopeNodeData, y),
            },
            FieldInfoData {
                name: "Base",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowEnvelopeNodeData, base),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowEnvelopeNodeData, scale),
            },
            FieldInfoData {
                name: "Pivot",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FollowEnvelopeNodeData, pivot),
            },
        ],
    }),
    array_type: Some(FOLLOWENVELOPENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowEnvelopeNodeData {
    fn type_info() -> &'static TypeInfo {
        FOLLOWENVELOPENODEDATA_TYPE_INFO
    }
}


pub const FOLLOWENVELOPENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowEnvelopeNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FollowEnvelopeNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventSwitcherNodeData {
    pub inputs: Vec<EventSwitcherEntry>,
    pub triggered: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub default_value: f32,
}

pub const EVENTSWITCHERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: EVENTSWITCHERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EventSwitcherNodeData, inputs),
            },
            FieldInfoData {
                name: "Triggered",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSwitcherNodeData, triggered),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSwitcherNodeData, value),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EventSwitcherNodeData, default_value),
            },
        ],
    }),
    array_type: Some(EVENTSWITCHERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSwitcherNodeData {
    fn type_info() -> &'static TypeInfo {
        EVENTSWITCHERNODEDATA_TYPE_INFO
    }
}


pub const EVENTSWITCHERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSwitcherNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventSwitcherEntry {
    pub case_trigger: AudioGraphNodePort,
    pub value: f32,
}

pub const EVENTSWITCHERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CaseTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventSwitcherEntry, case_trigger),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EventSwitcherEntry, value),
            },
        ],
    }),
    array_type: Some(EVENTSWITCHERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSwitcherEntry {
    fn type_info() -> &'static TypeInfo {
        EVENTSWITCHERENTRY_TYPE_INFO
    }
}


pub const EVENTSWITCHERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSwitcherEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventGateNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub cool_down_time: AudioGraphNodePort,
    pub probability: AudioGraphNodePort,
    pub enable: AudioGraphNodePort,
}

pub const EVENTGATENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventGateNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventGateNodeData, out),
            },
            FieldInfoData {
                name: "CoolDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventGateNodeData, cool_down_time),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventGateNodeData, probability),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventGateNodeData, enable),
            },
        ],
    }),
    array_type: Some(EVENTGATENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventGateNodeData {
    fn type_info() -> &'static TypeInfo {
        EVENTGATENODEDATA_TYPE_INFO
    }
}


pub const EVENTGATENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventGateNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventDelayNodeData {
    pub events: Vec<EventDelayNodeEntry>,
    pub delay_time: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub max_updates_per_second: u32,
}

pub const EVENTDELAYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EventDelayNodeData, events),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventDelayNodeData, delay_time),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EventDelayNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "MaxUpdatesPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(EventDelayNodeData, max_updates_per_second),
            },
        ],
    }),
    array_type: Some(EVENTDELAYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventDelayNodeData {
    fn type_info() -> &'static TypeInfo {
        EVENTDELAYNODEDATA_TYPE_INFO
    }
}


pub const EVENTDELAYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventDelayNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventDelayNodeEntry {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub const EVENTDELAYNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventDelayNodeEntry, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EventDelayNodeEntry, out),
            },
        ],
    }),
    array_type: Some(EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventDelayNodeEntry {
    fn type_info() -> &'static TypeInfo {
        EVENTDELAYNODEENTRY_TYPE_INFO
    }
}


pub const EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventDelayNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DeMuxNodeData {
    pub outputs: Vec<DeMuxOutput>,
    pub trigger: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub wrap_value: bool,
}

pub const DEMUXNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: DEMUXOUTPUT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(DeMuxNodeData, outputs),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DeMuxNodeData, trigger),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DeMuxNodeData, value),
            },
            FieldInfoData {
                name: "WrapValue",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DeMuxNodeData, wrap_value),
            },
        ],
    }),
    array_type: Some(DEMUXNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeMuxNodeData {
    fn type_info() -> &'static TypeInfo {
        DEMUXNODEDATA_TYPE_INFO
    }
}


pub const DEMUXNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeMuxNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DeMuxOutput {
    pub trigger: AudioGraphNodePort,
}

pub const DEMUXOUTPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxOutput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DeMuxOutput, trigger),
            },
        ],
    }),
    array_type: Some(DEMUXOUTPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeMuxOutput {
    fn type_info() -> &'static TypeInfo {
        DEMUXOUTPUT_TYPE_INFO
    }
}


pub const DEMUXOUTPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxOutput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeMuxOutput-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DeltaNodeData {
    pub deltas: Vec<DeltaGroup>,
}

pub const DELTANODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Deltas",
                flags: MemberInfoFlags::new(144),
                field_type: DELTAGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(DeltaNodeData, deltas),
            },
        ],
    }),
    array_type: Some(DELTANODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaNodeData {
    fn type_info() -> &'static TypeInfo {
        DELTANODEDATA_TYPE_INFO
    }
}


pub const DELTANODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeltaNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DeltaGroup {
    pub r#in: AudioGraphNodePort,
    pub delta: AudioGraphNodePort,
}

pub const DELTAGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DeltaGroup, r#in),
            },
            FieldInfoData {
                name: "Delta",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DeltaGroup, delta),
            },
        ],
    }),
    array_type: Some(DELTAGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaGroup {
    fn type_info() -> &'static TypeInfo {
        DELTAGROUP_TYPE_INFO
    }
}


pub const DELTAGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeltaGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EventDebugNodeData {
    pub events: Vec<DebugEventInput>,
    pub enabled: bool,
}

pub const EVENTDEBUGNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDebugNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: DEBUGEVENTINPUT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EventDebugNodeData, events),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(EventDebugNodeData, enabled),
            },
        ],
    }),
    array_type: Some(EVENTDEBUGNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventDebugNodeData {
    fn type_info() -> &'static TypeInfo {
        EVENTDEBUGNODEDATA_TYPE_INFO
    }
}


pub const EVENTDEBUGNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDebugNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventDebugNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DebugEventInput {
    pub e: AudioGraphNodePort,
    pub name: String,
    pub require_triggered_and_set: bool,
}

pub const DEBUGEVENTINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugEventInput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "E",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DebugEventInput, e),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(DebugEventInput, name),
            },
            FieldInfoData {
                name: "RequireTriggeredAndSet",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DebugEventInput, require_triggered_and_set),
            },
        ],
    }),
    array_type: Some(DEBUGEVENTINPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugEventInput {
    fn type_info() -> &'static TypeInfo {
        DEBUGEVENTINPUT_TYPE_INFO
    }
}


pub const DEBUGEVENTINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugEventInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DebugEventInput-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ValueDebugNodeData {
    pub values: Vec<DebugValueInput>,
    pub enabled: bool,
}

pub const VALUEDEBUGNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueDebugNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: DEBUGVALUEINPUT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ValueDebugNodeData, values),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ValueDebugNodeData, enabled),
            },
        ],
    }),
    array_type: Some(VALUEDEBUGNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueDebugNodeData {
    fn type_info() -> &'static TypeInfo {
        VALUEDEBUGNODEDATA_TYPE_INFO
    }
}


pub const VALUEDEBUGNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueDebugNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueDebugNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DebugValueInput {
    pub v: AudioGraphNodePort,
    pub name: String,
    pub render_type: DebugRenderType,
    pub min: f32,
    pub max: f32,
}

pub const DEBUGVALUEINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugValueInput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "V",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DebugValueInput, v),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(DebugValueInput, name),
            },
            FieldInfoData {
                name: "RenderType",
                flags: MemberInfoFlags::new(0),
                field_type: DEBUGRENDERTYPE_TYPE_INFO,
                rust_offset: offset_of!(DebugValueInput, render_type),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DebugValueInput, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DebugValueInput, max),
            },
        ],
    }),
    array_type: Some(DEBUGVALUEINPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugValueInput {
    fn type_info() -> &'static TypeInfo {
        DEBUGVALUEINPUT_TYPE_INFO
    }
}


pub const DEBUGVALUEINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugValueInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DebugValueInput-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum DebugRenderType {
    #[default]
    DebugRenderType_Text = 0,
    DebugRenderType_Plot = 1,
    DebugRenderType_Bar = 2,
    DebugRenderType_World = 3,
}

pub const DEBUGRENDERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugRenderType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(DEBUGRENDERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DebugRenderType {
    fn type_info() -> &'static TypeInfo {
        DEBUGRENDERTYPE_TYPE_INFO
    }
}


pub const DEBUGRENDERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugRenderType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DebugRenderType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct Crossfader2NodeData {
    pub ctrl: AudioGraphNodePort,
    pub ctrl_out1: AudioGraphNodePort,
    pub ctrl_out2: AudioGraphNodePort,
}

pub const CROSSFADER2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Crossfader2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Ctrl",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Crossfader2NodeData, ctrl),
            },
            FieldInfoData {
                name: "CtrlOut1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Crossfader2NodeData, ctrl_out1),
            },
            FieldInfoData {
                name: "CtrlOut2",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Crossfader2NodeData, ctrl_out2),
            },
        ],
    }),
    array_type: Some(CROSSFADER2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Crossfader2NodeData {
    fn type_info() -> &'static TypeInfo {
        CROSSFADER2NODEDATA_TYPE_INFO
    }
}


pub const CROSSFADER2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Crossfader2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Crossfader2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ConditionNodeConfigData {
    pub conditions: Vec<ConditionGroupConfig>,
}

pub const CONDITIONNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Conditions",
                flags: MemberInfoFlags::new(144),
                field_type: CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ConditionNodeConfigData, conditions),
            },
        ],
    }),
    array_type: Some(CONDITIONNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConditionNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        CONDITIONNODECONFIGDATA_TYPE_INFO
    }
}


pub const CONDITIONNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ConditionGroupConfig {
    pub x: f32,
    pub y: f32,
    pub auto_evaluate: bool,
    pub condition: ConditionType,
}

pub const CONDITIONGROUPCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroupConfig",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroupConfig, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroupConfig, y),
            },
            FieldInfoData {
                name: "AutoEvaluate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroupConfig, auto_evaluate),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: CONDITIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroupConfig, condition),
            },
        ],
    }),
    array_type: Some(CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ConditionGroupConfig {
    fn type_info() -> &'static TypeInfo {
        CONDITIONGROUPCONFIG_TYPE_INFO
    }
}


pub const CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroupConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionGroupConfig-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ConditionNodeData {
    pub conditions: Vec<ConditionGroup>,
}

pub const CONDITIONNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Conditions",
                flags: MemberInfoFlags::new(144),
                field_type: CONDITIONGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(ConditionNodeData, conditions),
            },
        ],
    }),
    array_type: Some(CONDITIONNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConditionNodeData {
    fn type_info() -> &'static TypeInfo {
        CONDITIONNODEDATA_TYPE_INFO
    }
}


pub const CONDITIONNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ConditionGroup {
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub r#true: AudioGraphNodePort,
    pub evaluate: AudioGraphNodePort,
    pub auto_evaluate: bool,
    pub condition: ConditionType,
}

pub const CONDITIONGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroup, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroup, y),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroup, r#true),
            },
            FieldInfoData {
                name: "Evaluate",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroup, evaluate),
            },
            FieldInfoData {
                name: "AutoEvaluate",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroup, auto_evaluate),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: CONDITIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(ConditionGroup, condition),
            },
        ],
    }),
    array_type: Some(CONDITIONGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConditionGroup {
    fn type_info() -> &'static TypeInfo {
        CONDITIONGROUP_TYPE_INFO
    }
}


pub const CONDITIONGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ConditionType {
    #[default]
    ConditionType_And = 0,
    ConditionType_Or = 1,
    ConditionType_XOr = 2,
    ConditionType_Equal = 3,
    ConditionType_NotEqual = 4,
    ConditionType_Less = 5,
    ConditionType_Greater = 6,
    ConditionType_LessOrEqual = 7,
    ConditionType_GreaterOrEqual = 8,
}

pub const CONDITIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(CONDITIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ConditionType {
    fn type_info() -> &'static TypeInfo {
        CONDITIONTYPE_TYPE_INFO
    }
}


pub const CONDITIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AdsrNodeData {
    pub trigger: AudioGraphNodePort,
    pub release: AudioGraphNodePort,
    pub a: AudioGraphNodePort,
    pub d: AudioGraphNodePort,
    pub s: AudioGraphNodePort,
    pub r: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub finished: AudioGraphNodePort,
    pub scale: f32,
    pub retrigger_from_start: bool,
}

pub const ADSRNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AdsrNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, trigger),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, release),
            },
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, a),
            },
            FieldInfoData {
                name: "D",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, d),
            },
            FieldInfoData {
                name: "S",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, s),
            },
            FieldInfoData {
                name: "R",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, r),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, value),
            },
            FieldInfoData {
                name: "Finished",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, finished),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, scale),
            },
            FieldInfoData {
                name: "RetriggerFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(AdsrNodeData, retrigger_from_start),
            },
        ],
    }),
    array_type: Some(ADSRNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AdsrNodeData {
    fn type_info() -> &'static TypeInfo {
        ADSRNODEDATA_TYPE_INFO
    }
}


pub const ADSRNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AdsrNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AdsrNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabelToValueNode {
    pub source: VoiceOverValueConnection,
    pub result: VoiceOverValue,
    pub label_array: VoiceOverLabelArray,
    pub default_result: VoiceOverConstantValue,
    pub assert_when_no_label: bool,
    pub assert_when_several_labels: bool,
}

pub const VOICEOVERLABELTOVALUENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelToValueNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelToValueNode, source),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelToValueNode, result),
            },
            FieldInfoData {
                name: "LabelArray",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelToValueNode, label_array),
            },
            FieldInfoData {
                name: "DefaultResult",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONSTANTVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelToValueNode, default_result),
            },
            FieldInfoData {
                name: "AssertWhenNoLabel",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelToValueNode, assert_when_no_label),
            },
            FieldInfoData {
                name: "AssertWhenSeveralLabels",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelToValueNode, assert_when_several_labels),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELTOVALUENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelToValueNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELTOVALUENODE_TYPE_INFO
    }
}


pub const VOICEOVERLABELTOVALUENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelToValueNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelToValueNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverSystemAsset {
    pub intervals: Vec<VoiceOverInterval>,
    pub labels: Vec<VoiceOverLabel>,
    pub types: Vec<VoiceOverObject>,
    pub objects: Vec<VoiceOverObject>,
    pub constants: Vec<VoiceOverGlobalConstantValue>,
    pub master_language: AudioLanguage,
    pub default_pronunciation: VoiceOverPronunciation,
    pub pronunciations: Vec<VoiceOverPronunciation>,
    pub queue_groups: Vec<VoiceOverConversationQueueGroup>,
    pub default_positioned_queue_group: VoiceOverConversationQueueGroup,
    pub default_unpositioned_queue_group: VoiceOverConversationQueueGroup,
    pub label_arrays: Vec<VoiceOverLabelArray>,
}

pub const VOICEOVERSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERINTERVAL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, intervals),
            },
            FieldInfoData {
                name: "Labels",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABEL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, labels),
            },
            FieldInfoData {
                name: "Types",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVEROBJECT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, types),
            },
            FieldInfoData {
                name: "Objects",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVEROBJECT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, objects),
            },
            FieldInfoData {
                name: "Constants",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, constants),
            },
            FieldInfoData {
                name: "MasterLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, master_language),
            },
            FieldInfoData {
                name: "DefaultPronunciation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERPRONUNCIATION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, default_pronunciation),
            },
            FieldInfoData {
                name: "Pronunciations",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, pronunciations),
            },
            FieldInfoData {
                name: "QueueGroups",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, queue_groups),
            },
            FieldInfoData {
                name: "DefaultPositionedQueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, default_positioned_queue_group),
            },
            FieldInfoData {
                name: "DefaultUnpositionedQueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, default_unpositioned_queue_group),
            },
            FieldInfoData {
                name: "LabelArrays",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABELARRAY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverSystemAsset, label_arrays),
            },
        ],
    }),
    array_type: Some(VOICEOVERSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverSystemAsset {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERSYSTEMASSET_TYPE_INFO
    }
}


pub const VOICEOVERSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverSystemAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabelArray {
    pub name: String,
    pub label_values: Vec<VoiceOverLabelValue>,
}

pub const VOICEOVERLABELARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelArray",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelArray, name),
            },
            FieldInfoData {
                name: "LabelValues",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABELVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelArray, label_values),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELARRAY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelArray {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELARRAY_TYPE_INFO
    }
}


pub const VOICEOVERLABELARRAY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelArray-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelArray-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabelValue {
    pub label: VoiceOverLabel,
    pub source: VoiceOverConstantValue,
}

pub const VOICEOVERLABELVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Label",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABEL_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelValue, label),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONSTANTVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelValue, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELVALUE_TYPE_INFO
    }
}


pub const VOICEOVERLABELVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverPronunciation {
    pub name: String,
    pub primary_language: AudioLanguage,
    pub secondary_language: AudioLanguage,
    pub secondary_fallback: VoiceOverPronunciationFallback,
}

pub const VOICEOVERPRONUNCIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciation",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverPronunciation, name),
            },
            FieldInfoData {
                name: "PrimaryLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverPronunciation, primary_language),
            },
            FieldInfoData {
                name: "SecondaryLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverPronunciation, secondary_language),
            },
            FieldInfoData {
                name: "SecondaryFallback",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverPronunciation, secondary_fallback),
            },
        ],
    }),
    array_type: Some(VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverPronunciation {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERPRONUNCIATION_TYPE_INFO
    }
}


pub const VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverPronunciation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverPronunciationFallback {
    #[default]
    VoiceOverPronunciationFallback_None = 0,
    VoiceOverPronunciationFallback_Master = 1,
}

pub const VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciationFallback",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERPRONUNCIATIONFALLBACK_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverPronunciationFallback {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO
    }
}


pub const VOICEOVERPRONUNCIATIONFALLBACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciationFallback-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverPronunciationFallback-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConversationQueueGroup {
    pub name: String,
    pub polyphony_mode: VoiceOverConversationQueueGroupPolyphony,
    pub polyphony: u32,
}

pub const VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationQueueGroup, name),
            },
            FieldInfoData {
                name: "PolyphonyMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationQueueGroup, polyphony_mode),
            },
            FieldInfoData {
                name: "Polyphony",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationQueueGroup, polyphony),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationQueueGroup {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationQueueGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverConversationQueueGroupPolyphony {
    #[default]
    VoiceOverConversationQueueGroupPolyphony_Sources = 0,
    VoiceOverConversationQueueGroupPolyphony_GlobalSources = 1,
    VoiceOverConversationQueueGroupPolyphony_Conversations = 2,
}

pub const VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroupPolyphony",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverConversationQueueGroupPolyphony {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroupPolyphony-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationQueueGroupPolyphony-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FinalDraftManuscriptAsset {
    pub spreadsheet_file_name: String,
}

pub const FINALDRAFTMANUSCRIPTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftManuscriptAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERMANUSCRIPTASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SpreadsheetFileName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(FinalDraftManuscriptAsset, spreadsheet_file_name),
            },
        ],
    }),
    array_type: Some(FINALDRAFTMANUSCRIPTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FinalDraftManuscriptAsset {
    fn type_info() -> &'static TypeInfo {
        FINALDRAFTMANUSCRIPTASSET_TYPE_INFO
    }
}


pub const FINALDRAFTMANUSCRIPTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftManuscriptAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FinalDraftManuscriptAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct FinalDraftLineInfo {
}

pub const FINALDRAFTLINEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftLineInfo",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(FINALDRAFTLINEINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FinalDraftLineInfo {
    fn type_info() -> &'static TypeInfo {
        FINALDRAFTLINEINFO_TYPE_INFO
    }
}


pub const FINALDRAFTLINEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftLineInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FinalDraftLineInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverManuscriptAsset {
    pub master_language: AudioLanguage,
    pub languages: Vec<VoiceOverLanguageRoot>,
    pub name_translation: VoiceOverWaveNameTranslation,
    pub keep_path: bool,
    pub variation_underscore_count: u32,
    pub string_id_column: String,
    pub file_name_column: String,
    pub path_column: String,
    pub wave_asset_status_column: String,
    pub sheet_name: String,
    pub voice_column: String,
    pub character_column: String,
    pub language_columns: Vec<VoiceOverManuscriptLanguageColumns>,
    pub first_content_row: i32,
    pub string_id_prefix: String,
    pub string_id_upper_case: bool,
    pub output_path: String,
    pub allow_delete: bool,
    pub enable_subtitles: bool,
}

pub const VOICEOVERMANUSCRIPTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MasterLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, master_language),
            },
            FieldInfoData {
                name: "Languages",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, languages),
            },
            FieldInfoData {
                name: "NameTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERWAVENAMETRANSLATION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, name_translation),
            },
            FieldInfoData {
                name: "KeepPath",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, keep_path),
            },
            FieldInfoData {
                name: "VariationUnderscoreCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, variation_underscore_count),
            },
            FieldInfoData {
                name: "StringIdColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, string_id_column),
            },
            FieldInfoData {
                name: "FileNameColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, file_name_column),
            },
            FieldInfoData {
                name: "PathColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, path_column),
            },
            FieldInfoData {
                name: "WaveAssetStatusColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, wave_asset_status_column),
            },
            FieldInfoData {
                name: "SheetName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, sheet_name),
            },
            FieldInfoData {
                name: "VoiceColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, voice_column),
            },
            FieldInfoData {
                name: "CharacterColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, character_column),
            },
            FieldInfoData {
                name: "LanguageColumns",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, language_columns),
            },
            FieldInfoData {
                name: "FirstContentRow",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, first_content_row),
            },
            FieldInfoData {
                name: "StringIdPrefix",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, string_id_prefix),
            },
            FieldInfoData {
                name: "StringIdUpperCase",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, string_id_upper_case),
            },
            FieldInfoData {
                name: "OutputPath",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, output_path),
            },
            FieldInfoData {
                name: "AllowDelete",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, allow_delete),
            },
            FieldInfoData {
                name: "EnableSubtitles",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptAsset, enable_subtitles),
            },
        ],
    }),
    array_type: Some(VOICEOVERMANUSCRIPTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverManuscriptAsset {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERMANUSCRIPTASSET_TYPE_INFO
    }
}


pub const VOICEOVERMANUSCRIPTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverManuscriptAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverManuscriptLanguageColumns {
    pub language: AudioLanguage,
    pub text_column: String,
    pub subtitle_offset_column: String,
}

pub const VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptLanguageColumns",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Language",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptLanguageColumns, language),
            },
            FieldInfoData {
                name: "TextColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptLanguageColumns, text_column),
            },
            FieldInfoData {
                name: "SubtitleOffsetColumn",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverManuscriptLanguageColumns, subtitle_offset_column),
            },
        ],
    }),
    array_type: Some(VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverManuscriptLanguageColumns {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_TYPE_INFO
    }
}


pub const VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptLanguageColumns-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverManuscriptLanguageColumns-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverWaveNameTranslation {
    #[default]
    VoiceOverWaveNameTranslation_FullName = 0,
    VoiceOverWaveNameTranslation_PathOnly = 1,
    VoiceOverWaveNameTranslation_NameOnly = 2,
}

pub const VOICEOVERWAVENAMETRANSLATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverWaveNameTranslation",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERWAVENAMETRANSLATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverWaveNameTranslation {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERWAVENAMETRANSLATION_TYPE_INFO
    }
}


pub const VOICEOVERWAVENAMETRANSLATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverWaveNameTranslation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverWaveNameTranslation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLanguageRoot {
    pub language: AudioLanguage,
    pub path: String,
}

pub const VOICEOVERLANGUAGEROOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLanguageRoot",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Language",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOLANGUAGE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLanguageRoot, language),
            },
            FieldInfoData {
                name: "Path",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLanguageRoot, path),
            },
        ],
    }),
    array_type: Some(VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLanguageRoot {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLANGUAGEROOT_TYPE_INFO
    }
}


pub const VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLanguageRoot-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLanguageRoot-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverLogicAsset {
    pub events: Vec<VoiceOverEvent>,
    pub groups: Vec<VoiceOverGroup>,
    pub flows: Vec<VoiceOverLogicFlow>,
    pub flow_configs: Vec<VoiceOverLogicFlowConfigData>,
    pub system: VoiceOverSystemAsset,
}

pub const VOICEOVERLOGICASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVEREVENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicAsset, events),
            },
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicAsset, groups),
            },
            FieldInfoData {
                name: "Flows",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicAsset, flows),
            },
            FieldInfoData {
                name: "FlowConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicAsset, flow_configs),
            },
            FieldInfoData {
                name: "System",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERSYSTEMASSET_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicAsset, system),
            },
        ],
    }),
    array_type: Some(VOICEOVERLOGICASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLogicAsset {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLOGICASSET_TYPE_INFO
    }
}


pub const VOICEOVERLOGICASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverGroup {
    pub name: String,
    pub priority: i32,
}

pub const VOICEOVERGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGroup, name),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGroup, priority),
            },
        ],
    }),
    array_type: Some(VOICEOVERGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGroup {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERGROUP_TYPE_INFO
    }
}


pub const VOICEOVERGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverLogicFlowConfigData {
    pub name: String,
    pub owner: VoiceOverLogicAsset,
    pub group: VoiceOverGroup,
    pub locals: Vec<VoiceOverValue>,
    pub roots: Vec<VoiceOverEventNodeConfigData>,
    pub flow: VoiceOverLogicFlow,
    pub node_configs: Vec<VoiceOverNodeConfigData>,
}

pub const VOICEOVERLOGICFLOWCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, name),
            },
            FieldInfoData {
                name: "Owner",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLOGICASSET_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, owner),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERGROUP_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, group),
            },
            FieldInfoData {
                name: "Locals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, locals),
            },
            FieldInfoData {
                name: "Roots",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, roots),
            },
            FieldInfoData {
                name: "Flow",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLOGICFLOW_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, flow),
            },
            FieldInfoData {
                name: "NodeConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, node_configs),
            },
        ],
    }),
    array_type: Some(VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLogicFlowConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLOGICFLOWCONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicFlowConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverLogicFlow {
    pub name: String,
    pub owner: VoiceOverLogicAsset,
    pub group: VoiceOverGroup,
    pub locals: Vec<VoiceOverValue>,
    pub roots: Vec<VoiceOverEventNode>,
}

pub const VOICEOVERLOGICFLOW_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlow",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlow, name),
            },
            FieldInfoData {
                name: "Owner",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLOGICASSET_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlow, owner),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERGROUP_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlow, group),
            },
            FieldInfoData {
                name: "Locals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlow, locals),
            },
            FieldInfoData {
                name: "Roots",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVEREVENTNODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLogicFlow, roots),
            },
        ],
    }),
    array_type: Some(VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLogicFlow {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLOGICFLOW_TYPE_INFO
    }
}


pub const VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlow-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicFlow-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverRandomContainerNodeConfigData {
    pub flow_outputs: Vec<VoiceOverRandomContainerOutput>,
}

pub const VOICEOVERRANDOMCONTAINERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FlowOutputs",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverRandomContainerNodeConfigData, flow_outputs),
            },
        ],
    }),
    array_type: Some(VOICEOVERRANDOMCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRandomContainerNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERRANDOMCONTAINERNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERRANDOMCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRandomContainerNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverRandomContainerNode {
    pub intervals: Vec<VoiceOverIntervalNode>,
    pub flow_outputs: Vec<VoiceOverRandomContainerOutput>,
}

pub const VOICEOVERRANDOMCONTAINERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverRandomContainerNode, intervals),
            },
            FieldInfoData {
                name: "FlowOutputs",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverRandomContainerNode, flow_outputs),
            },
        ],
    }),
    array_type: Some(VOICEOVERRANDOMCONTAINERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRandomContainerNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERRANDOMCONTAINERNODE_TYPE_INFO
    }
}


pub const VOICEOVERRANDOMCONTAINERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRandomContainerNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverRandomContainerOutput {
    pub output_relationship: Vec<VoiceOverStructureNode>,
    pub weight: u32,
}

pub const VOICEOVERRANDOMCONTAINEROUTPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerOutput",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "OutputRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverRandomContainerOutput, output_relationship),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverRandomContainerOutput, weight),
            },
        ],
    }),
    array_type: Some(VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRandomContainerOutput {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERRANDOMCONTAINEROUTPUT_TYPE_INFO
    }
}


pub const VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerOutput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRandomContainerOutput-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverTriggerNodeConfigData {
    pub delay: f32,
    pub parameters: Vec<VoiceOverTriggerParameter>,
    pub event: VoiceOverEvent,
}

pub const VOICEOVERTRIGGERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerNodeConfigData, delay),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerNodeConfigData, parameters),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEREVENT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerNodeConfigData, event),
            },
        ],
    }),
    array_type: Some(VOICEOVERTRIGGERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverTriggerNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERTRIGGERNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERTRIGGERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverTriggerNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverTriggerNode {
    pub parameters: Vec<VoiceOverTriggerParameter>,
    pub delay: f32,
    pub event: VoiceOverEvent,
}

pub const VOICEOVERTRIGGERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerNode, parameters),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerNode, delay),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEREVENT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerNode, event),
            },
        ],
    }),
    array_type: Some(VOICEOVERTRIGGERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverTriggerNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERTRIGGERNODE_TYPE_INFO
    }
}


pub const VOICEOVERTRIGGERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverTriggerNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverTriggerParameter {
    pub source: VoiceOverValueConnection,
    pub event_parameter: VoiceOverNamedValue,
}

pub const VOICEOVERTRIGGERPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerParameter, source),
            },
            FieldInfoData {
                name: "EventParameter",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverTriggerParameter, event_parameter),
            },
        ],
    }),
    array_type: Some(VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverTriggerParameter {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERTRIGGERPARAMETER_TYPE_INFO
    }
}


pub const VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverTriggerParameter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverEventNodeConfigData {
    pub redirects: Vec<VoiceOverValueRedirect>,
    pub event: VoiceOverEvent,
    pub debug_enabled: bool,
    pub debug_color: super::core::Vec3,
    pub debug_interval_time: f32,
}

pub const VOICEOVEREVENTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Redirects",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, redirects),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEREVENT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, event),
            },
            FieldInfoData {
                name: "DebugEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, debug_enabled),
            },
            FieldInfoData {
                name: "DebugColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, debug_color),
            },
            FieldInfoData {
                name: "DebugIntervalTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, debug_interval_time),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverEventNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVEREVENTNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverEventNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverEventNode {
    pub intervals: Vec<VoiceOverIntervalNode>,
    pub relationship: Vec<VoiceOverStructureNode>,
    pub redirects: Vec<VoiceOverValueRedirect>,
    pub event: VoiceOverEvent,
    pub debug_enabled: bool,
    pub debug_color: super::core::Vec3,
    pub debug_interval_time: f32,
}

pub const VOICEOVEREVENTNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, intervals),
            },
            FieldInfoData {
                name: "Relationship",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, relationship),
            },
            FieldInfoData {
                name: "Redirects",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, redirects),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEREVENT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, event),
            },
            FieldInfoData {
                name: "DebugEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, debug_enabled),
            },
            FieldInfoData {
                name: "DebugColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, debug_color),
            },
            FieldInfoData {
                name: "DebugIntervalTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEventNode, debug_interval_time),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENTNODE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverEventNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVEREVENTNODE_TYPE_INFO
    }
}


pub const VOICEOVEREVENTNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverEventNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverConversationNodeConfigData {
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub conversation: VoiceOverConversationInfo,
}

pub const VOICEOVERCONVERSATIONNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNodeConfigData, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNodeConfigData, probability),
            },
            FieldInfoData {
                name: "Conversation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONINFO_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNodeConfigData, conversation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverConversationNode {
    pub condition: Vec<VoiceOverValueConnection>,
    pub pronunciation_index: VoiceOverValueConnection,
    pub intervals: Vec<VoiceOverIntervalNode>,
    pub finished_relationship: Vec<VoiceOverStructureNode>,
    pub blocked_relationship: Vec<VoiceOverStructureNode>,
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub conversation: VoiceOverConversationInfo,
}

pub const VOICEOVERCONVERSATIONNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, condition),
            },
            FieldInfoData {
                name: "PronunciationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, pronunciation_index),
            },
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, intervals),
            },
            FieldInfoData {
                name: "FinishedRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, finished_relationship),
            },
            FieldInfoData {
                name: "BlockedRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, blocked_relationship),
            },
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, probability),
            },
            FieldInfoData {
                name: "Conversation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONINFO_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationNode, conversation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONNODE_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverConversationInfo {
    pub groups: Vec<VoiceOverDialogGroup>,
    pub tracks: Vec<VoiceOverDialogTrack>,
    pub pronunciations: Vec<VoiceOverPronunciation>,
    pub interrupt_mode: VoiceOverConversationInterruptMode,
    pub priority: i32,
    pub queue_mode: VoiceOverConversationQueueMode,
    pub relevancy: f32,
    pub last_sequence_index: u8,
}

pub const VOICEOVERCONVERSATIONINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, groups),
            },
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, tracks),
            },
            FieldInfoData {
                name: "Pronunciations",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, pronunciations),
            },
            FieldInfoData {
                name: "InterruptMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, interrupt_mode),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, priority),
            },
            FieldInfoData {
                name: "QueueMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, queue_mode),
            },
            FieldInfoData {
                name: "Relevancy",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, relevancy),
            },
            FieldInfoData {
                name: "LastSequenceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationInfo, last_sequence_index),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationInfo {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONINFO_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverConversationQueueMode {
    #[default]
    VoiceOverConversationQueueMode_Always = 0,
    VoiceOverConversationQueueMode_Never = 1,
    VoiceOverConversationQueueMode_SamePriority = 2,
}

pub const VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONVERSATIONQUEUEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverConversationQueueMode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONQUEUEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationQueueMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverConversationInterruptMode {
    #[default]
    VoiceOverConversationInterruptMode_Disallow = 0,
    VoiceOverConversationInterruptMode_Allow = 1,
    VoiceOverConversationInterruptMode_AllowSame = 2,
}

pub const VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInterruptMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONVERSATIONINTERRUPTMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverConversationInterruptMode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONINTERRUPTMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInterruptMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationInterruptMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDialogGroup {
    pub sound: SoundAsset,
    pub parameters: Vec<VoiceOverDialogSoundParameter>,
    pub output_events: Vec<VoiceOverDialogOutputEvent>,
    pub track_count: u8,
}

pub const VOICEOVERDIALOGGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDASSET_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogGroup, sound),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogGroup, parameters),
            },
            FieldInfoData {
                name: "OutputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogGroup, output_events),
            },
            FieldInfoData {
                name: "TrackCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogGroup, track_count),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogGroup {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGGROUP_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogGroup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDialogOutputEvent {
    pub event: AudioGraphParameter,
}

pub const VOICEOVERDIALOGOUTPUTEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogOutputEvent",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogOutputEvent, event),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogOutputEvent {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGOUTPUTEVENT_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogOutputEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogOutputEvent-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDialogSoundParameter {
    pub source: VoiceOverValueConnection,
    pub entity_source_port_id: u32,
    pub target: AudioGraphParameter,
    pub behavior: VoiceOverDialogSoundParameterBehavior,
}

pub const VOICEOVERDIALOGSOUNDPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameter",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, source),
            },
            FieldInfoData {
                name: "EntitySourcePortId",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, entity_source_port_id),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, target),
            },
            FieldInfoData {
                name: "Behavior",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, behavior),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogSoundParameter {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGSOUNDPARAMETER_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogSoundParameter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverDialogSoundParameterBehavior {
    #[default]
    VoiceOverDialogSoundParameterBehavior_StartOnly = 0,
    VoiceOverDialogSoundParameterBehavior_Continuous = 1,
}

pub const VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameterBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverDialogSoundParameterBehavior {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameterBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogSoundParameterBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDialogTrack {
    pub source: VoiceOverValueConnection,
    pub take_control: VoiceOverValueConnection,
    pub take_index_mapping: Vec<VoiceOverDialogTakeMapping>,
    pub take_switching: VoiceOverDialogTakeBehavior,
    pub take_switching_on_resume: bool,
    pub parent_track_index: u8,
    pub group_index: u8,
    pub output: AudioGraphNodeData,
    pub sampler_node: AudioGraphNodeData,
    pub queue_group: VoiceOverConversationQueueGroup,
    pub clips: Vec<VoiceOverDialogClip>,
}

pub const VOICEOVERDIALOGTRACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTrack",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, source),
            },
            FieldInfoData {
                name: "TakeControl",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, take_control),
            },
            FieldInfoData {
                name: "TakeIndexMapping",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, take_index_mapping),
            },
            FieldInfoData {
                name: "TakeSwitching",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, take_switching),
            },
            FieldInfoData {
                name: "TakeSwitchingOnResume",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, take_switching_on_resume),
            },
            FieldInfoData {
                name: "ParentTrackIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, parent_track_index),
            },
            FieldInfoData {
                name: "GroupIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, group_index),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, output),
            },
            FieldInfoData {
                name: "SamplerNode",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, sampler_node),
            },
            FieldInfoData {
                name: "QueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, queue_group),
            },
            FieldInfoData {
                name: "Clips",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTrack, clips),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogTrack {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGTRACK_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTrack-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTrack-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverDialogTakeBehavior {
    #[default]
    VoiceOverDialogTakeBehavior_Start = 0,
    VoiceOverDialogTakeBehavior_Clip = 1,
    VoiceOverDialogTakeBehavior_Continuous = 2,
}

pub const VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERDIALOGTAKEBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverDialogTakeBehavior {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGTAKEBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTakeBehavior-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDialogTakeMapping {
    pub take_control_min: f32,
    pub take_control_max: f32,
    pub take_index: u8,
}

pub const VOICEOVERDIALOGTAKEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeMapping",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "TakeControlMin",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTakeMapping, take_control_min),
            },
            FieldInfoData {
                name: "TakeControlMax",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTakeMapping, take_control_max),
            },
            FieldInfoData {
                name: "TakeIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTakeMapping, take_index),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VoiceOverDialogTakeMapping {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGTAKEMAPPING_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTakeMapping-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDialogClip {
    pub min_offset: f32,
    pub max_offset: f32,
    pub takes: Vec<VoiceOverDialogTake>,
    pub offset_references: Vec<VoiceOverDialogClip>,
    pub sequence_index: u8,
    pub events: VoiceOverDialogClipEvents,
}

pub const VOICEOVERDIALOGCLIP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClip",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClip, min_offset),
            },
            FieldInfoData {
                name: "MaxOffset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClip, max_offset),
            },
            FieldInfoData {
                name: "Takes",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClip, takes),
            },
            FieldInfoData {
                name: "OffsetReferences",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClip, offset_references),
            },
            FieldInfoData {
                name: "SequenceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClip, sequence_index),
            },
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClip, events),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogClip {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGCLIP_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClip-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogClip-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverDialogClipEvents {
    pub started_name_hash: u32,
    pub finished_name_hash: u32,
}

pub const VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClipEvents",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "StartedNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClipEvents, started_name_hash),
            },
            FieldInfoData {
                name: "FinishedNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogClipEvents, finished_name_hash),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGCLIPEVENTS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogClipEvents {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGCLIPEVENTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClipEvents-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogClipEvents-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverDialogTake {
    pub wave: SoundWaveAssetBase,
}

pub const VOICEOVERDIALOGTAKE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTake",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDialogTake, wave),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogTake {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDIALOGTAKE_TYPE_INFO
    }
}


pub const VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTake-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTake-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverContainerNodeConfigData {
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub always_reset_interval: bool,
}

pub const VOICEOVERCONTAINERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNodeConfigData, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNodeConfigData, probability),
            },
            FieldInfoData {
                name: "AlwaysResetInterval",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNodeConfigData, always_reset_interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverContainerNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONTAINERNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverContainerNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverContainerNode {
    pub condition: Vec<VoiceOverValueConnection>,
    pub intervals: Vec<VoiceOverIntervalNode>,
    pub true_relationship: Vec<VoiceOverStructureNode>,
    pub false_relationship: Vec<VoiceOverStructureNode>,
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub always_reset_interval: bool,
}

pub const VOICEOVERCONTAINERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, condition),
            },
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, intervals),
            },
            FieldInfoData {
                name: "TrueRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, true_relationship),
            },
            FieldInfoData {
                name: "FalseRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, false_relationship),
            },
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, probability),
            },
            FieldInfoData {
                name: "AlwaysResetInterval",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverContainerNode, always_reset_interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONTAINERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverContainerNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONTAINERNODE_TYPE_INFO
    }
}


pub const VOICEOVERCONTAINERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverContainerNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverContainerConditionMode {
    #[default]
    VoiceOverContainerConditionMode_All = 0,
    VoiceOverContainerConditionMode_Any = 1,
}

pub const VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerConditionMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONTAINERCONDITIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverContainerConditionMode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO
    }
}


pub const VOICEOVERCONTAINERCONDITIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerConditionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverContainerConditionMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverStructureNode {
    pub flow_mode: VoiceOverLogicFlowMode,
}

pub const VOICEOVERSTRUCTURENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FlowMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLOGICFLOWMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverStructureNode, flow_mode),
            },
        ],
    }),
    array_type: Some(VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverStructureNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERSTRUCTURENODE_TYPE_INFO
    }
}


pub const VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverStructureNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverLogicFlowMode {
    #[default]
    VoiceOverLogicFlowMode_All = 0,
    VoiceOverLogicFlowMode_One = 1,
}

pub const VOICEOVERLOGICFLOWMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERLOGICFLOWMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverLogicFlowMode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLOGICFLOWMODE_TYPE_INFO
    }
}


pub const VOICEOVERLOGICFLOWMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicFlowMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverVariableNodeConfigData {
    pub source: VoiceOverNamedValue,
}

pub const VOICEOVERVARIABLENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverVariableNodeConfigData, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERVARIABLENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverVariableNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERVARIABLENODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERVARIABLENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverVariableNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverVariableNode {
    pub value: VoiceOverValue,
    pub source: VoiceOverNamedValue,
}

pub const VOICEOVERVARIABLENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverVariableNode, value),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverVariableNode, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERVARIABLENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverVariableNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERVARIABLENODE_TYPE_INFO
    }
}


pub const VOICEOVERVARIABLENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverVariableNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverProbabilityNodeConfigData {
    pub probability: f32,
}

pub const VOICEOVERPROBABILITYNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverProbabilityNodeConfigData, probability),
            },
        ],
    }),
    array_type: Some(VOICEOVERPROBABILITYNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverProbabilityNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERPROBABILITYNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERPROBABILITYNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverProbabilityNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverProbabilityNode {
    pub r#false: VoiceOverValue,
    pub r#true: VoiceOverValue,
    pub probability: f32,
}

pub const VOICEOVERPROBABILITYNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverProbabilityNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverProbabilityNode, r#true),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverProbabilityNode, probability),
            },
        ],
    }),
    array_type: Some(VOICEOVERPROBABILITYNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverProbabilityNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERPROBABILITYNODE_TYPE_INFO
    }
}


pub const VOICEOVERPROBABILITYNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverProbabilityNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabelNodeConfigData {
    pub wanted_labels: Vec<VoiceOverLabel>,
    pub unwanted_labels: Vec<VoiceOverLabel>,
    pub source_mode: VoiceOverLabelSourceMode,
    pub wanted_compare_mode: VoiceOverLabelCompareMode,
    pub unwanted_compare_mode: VoiceOverLabelCompareMode,
}

pub const VOICEOVERLABELNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABEL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, wanted_labels),
            },
            FieldInfoData {
                name: "UnwantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABEL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, unwanted_labels),
            },
            FieldInfoData {
                name: "SourceMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELSOURCEMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, source_mode),
            },
            FieldInfoData {
                name: "WantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELCOMPAREMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, wanted_compare_mode),
            },
            FieldInfoData {
                name: "UnwantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELCOMPAREMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, unwanted_compare_mode),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERLABELNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabelNode {
    pub sources: Vec<VoiceOverLabelSource>,
    pub r#false: VoiceOverValue,
    pub r#true: VoiceOverValue,
    pub wanted_labels: Vec<VoiceOverLabel>,
    pub unwanted_labels: Vec<VoiceOverLabel>,
    pub source_mode: VoiceOverLabelSourceMode,
    pub wanted_compare_mode: VoiceOverLabelCompareMode,
    pub unwanted_compare_mode: VoiceOverLabelCompareMode,
}

pub const VOICEOVERLABELNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Sources",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, sources),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, r#true),
            },
            FieldInfoData {
                name: "WantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABEL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, wanted_labels),
            },
            FieldInfoData {
                name: "UnwantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABEL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, unwanted_labels),
            },
            FieldInfoData {
                name: "SourceMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELSOURCEMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, source_mode),
            },
            FieldInfoData {
                name: "WantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELCOMPAREMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, wanted_compare_mode),
            },
            FieldInfoData {
                name: "UnwantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLABELCOMPAREMODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelNode, unwanted_compare_mode),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELNODE_TYPE_INFO
    }
}


pub const VOICEOVERLABELNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabelSource {
    pub source: VoiceOverValueConnection,
}

pub const VOICEOVERLABELSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSource",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabelSource, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelSource {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELSOURCE_TYPE_INFO
    }
}


pub const VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelSource-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverLabelCompareMode {
    #[default]
    VoiceOverLabelCompareMode_Any = 0,
    VoiceOverLabelCompareMode_All = 1,
    VoiceOverLabelCompareMode_One = 2,
}

pub const VOICEOVERLABELCOMPAREMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelCompareMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERLABELCOMPAREMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverLabelCompareMode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELCOMPAREMODE_TYPE_INFO
    }
}


pub const VOICEOVERLABELCOMPAREMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelCompareMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelCompareMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverLabelSourceMode {
    #[default]
    VoiceOverLabelSourceMode_Combined = 0,
    VoiceOverLabelSourceMode_Shared = 1,
}

pub const VOICEOVERLABELSOURCEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSourceMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERLABELSOURCEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverLabelSourceMode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABELSOURCEMODE_TYPE_INFO
    }
}


pub const VOICEOVERLABELSOURCEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSourceMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelSourceMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverIntervalNodeConfigData {
    pub interval: VoiceOverInterval,
}

pub const VOICEOVERINTERVALNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERINTERVAL_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverIntervalNodeConfigData, interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERINTERVALNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverIntervalNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERINTERVALNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERINTERVALNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverIntervalNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverIntervalNode {
    pub threshold: VoiceOverValueConnection,
    pub time: VoiceOverValue,
    pub r#false: VoiceOverValue,
    pub r#true: VoiceOverValue,
    pub interval: VoiceOverInterval,
}

pub const VOICEOVERINTERVALNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverIntervalNode, threshold),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverIntervalNode, time),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverIntervalNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverIntervalNode, r#true),
            },
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERINTERVAL_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverIntervalNode, interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverIntervalNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERINTERVALNODE_TYPE_INFO
    }
}


pub const VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverIntervalNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverInfoNodeConfigData {
    pub field: VoiceOverNamedValue,
    pub expected_type: VoiceOverObject,
}

pub const VOICEOVERINFONODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInfoNodeConfigData, field),
            },
            FieldInfoData {
                name: "ExpectedType",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEROBJECT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInfoNodeConfigData, expected_type),
            },
        ],
    }),
    array_type: Some(VOICEOVERINFONODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverInfoNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERINFONODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERINFONODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverInfoNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverInfoNode {
    pub object: VoiceOverValueConnection,
    pub value: VoiceOverValue,
    pub field: VoiceOverNamedValue,
    pub expected_type: VoiceOverObject,
}

pub const VOICEOVERINFONODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInfoNode, object),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInfoNode, value),
            },
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInfoNode, field),
            },
            FieldInfoData {
                name: "ExpectedType",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEROBJECT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInfoNode, expected_type),
            },
        ],
    }),
    array_type: Some(VOICEOVERINFONODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverInfoNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERINFONODE_TYPE_INFO
    }
}


pub const VOICEOVERINFONODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverInfoNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverGlobalNodeConfigData {
    pub field: VoiceOverNamedValue,
    pub object: VoiceOverObject,
}

pub const VOICEOVERGLOBALNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalNodeConfigData, field),
            },
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEROBJECT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalNodeConfigData, object),
            },
        ],
    }),
    array_type: Some(VOICEOVERGLOBALNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGlobalNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERGLOBALNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERGLOBALNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGlobalNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverGlobalNode {
    pub value: VoiceOverValue,
    pub field: VoiceOverNamedValue,
    pub object: VoiceOverObject,
}

pub const VOICEOVERGLOBALNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalNode, value),
            },
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNAMEDVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalNode, field),
            },
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEROBJECT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalNode, object),
            },
        ],
    }),
    array_type: Some(VOICEOVERGLOBALNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGlobalNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERGLOBALNODE_TYPE_INFO
    }
}


pub const VOICEOVERGLOBALNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGlobalNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverDistanceNodeConfigData {
    pub operation: VoiceOverCompareExpressionType,
}

pub const VOICEOVERDISTANCENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNodeConfigData, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERDISTANCENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDistanceNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDISTANCENODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERDISTANCENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDistanceNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverDistanceNode {
    pub a: VoiceOverValueConnection,
    pub b: VoiceOverValueConnection,
    pub threshold: VoiceOverValueConnection,
    pub distance: VoiceOverValue,
    pub r#false: VoiceOverValue,
    pub r#true: VoiceOverValue,
    pub operation: VoiceOverCompareExpressionType,
}

pub const VOICEOVERDISTANCENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, b),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, threshold),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, distance),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, r#true),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDistanceNode, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERDISTANCENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDistanceNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDISTANCENODE_TYPE_INFO
    }
}


pub const VOICEOVERDISTANCENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDistanceNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDebugValueNodeConfigData {
    pub name: String,
    pub color: super::core::Vec3,
    pub display_time: f32,
    pub enabled: bool,
}

pub const VOICEOVERDEBUGVALUENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, name),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, color),
            },
            FieldInfoData {
                name: "DisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, display_time),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, enabled),
            },
        ],
    }),
    array_type: Some(VOICEOVERDEBUGVALUENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverDebugValueNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDEBUGVALUENODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERDEBUGVALUENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDebugValueNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverDebugValueNode {
    pub r#in: VoiceOverValueConnection,
    pub out: VoiceOverValue,
    pub value_name: String,
    pub plot: bool,
    pub min: f32,
    pub max: f32,
    pub color: super::core::Vec3,
    pub display_time: f32,
    pub enabled: bool,
}

pub const VOICEOVERDEBUGVALUENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, out),
            },
            FieldInfoData {
                name: "ValueName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, value_name),
            },
            FieldInfoData {
                name: "Plot",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, plot),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, max),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, color),
            },
            FieldInfoData {
                name: "DisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, display_time),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverDebugValueNode, enabled),
            },
        ],
    }),
    array_type: Some(VOICEOVERDEBUGVALUENODE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverDebugValueNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERDEBUGVALUENODE_TYPE_INFO
    }
}


pub const VOICEOVERDEBUGVALUENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDebugValueNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConstantNodeConfigData {
    pub source: VoiceOverConstantValue,
}

pub const VOICEOVERCONSTANTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONSTANTVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantNodeConfigData, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConstantNode {
    pub value: VoiceOverValue,
    pub source: VoiceOverConstantValue,
}

pub const VOICEOVERCONSTANTNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantNode, value),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONSTANTVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantNode, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTNODE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverConstantVectorValue {
    pub value: super::core::Vec4,
}

pub const VOICEOVERCONSTANTVECTORVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantVectorValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: VEC4_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantVectorValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTVECTORVALUE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverConstantVectorValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTVECTORVALUE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTVECTORVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantVectorValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantVectorValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConstantGlobalValue {
    pub source: VoiceOverGlobalConstantValue,
}

pub const VOICEOVERCONSTANTGLOBALVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantGlobalValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantGlobalValue, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTGLOBALVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantGlobalValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTGLOBALVALUE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTGLOBALVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantGlobalValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantGlobalValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverConstantFloatValue {
    pub value: f32,
}

pub const VOICEOVERCONSTANTFLOATVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantFloatValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantFloatValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTFLOATVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantFloatValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTFLOATVALUE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTFLOATVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantFloatValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantFloatValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConstantIntegerValue {
    pub value: i32,
}

pub const VOICEOVERCONSTANTINTEGERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantIntegerValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantIntegerValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTINTEGERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantIntegerValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTINTEGERVALUE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTINTEGERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantIntegerValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantIntegerValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConstantBooleanValue {
    pub value: bool,
}

pub const VOICEOVERCONSTANTBOOLEANVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantBooleanValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConstantBooleanValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTBOOLEANVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantBooleanValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTBOOLEANVALUE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTBOOLEANVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantBooleanValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantBooleanValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverGlobalConstantValue {
    pub name: String,
    pub source: VoiceOverConstantValue,
}

pub const VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalConstantValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalConstantValue, name),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONSTANTVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverGlobalConstantValue, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGlobalConstantValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO
    }
}


pub const VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalConstantValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGlobalConstantValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConstantValue {
}

pub const VOICEOVERCONSTANTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONSTANTVALUE_TYPE_INFO
    }
}


pub const VOICEOVERCONSTANTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverCompareNodeConfigData {
    pub operation: VoiceOverCompareExpressionType,
}

pub const VOICEOVERCOMPARENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverCompareNodeConfigData, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCOMPARENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverCompareNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCOMPARENODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERCOMPARENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverCompareNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverCompareNode {
    pub a: VoiceOverValueConnection,
    pub b: VoiceOverValueConnection,
    pub r#false: VoiceOverValue,
    pub r#true: VoiceOverValue,
    pub operation: VoiceOverCompareExpressionType,
}

pub const VOICEOVERCOMPARENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverCompareNode, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverCompareNode, b),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverCompareNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverCompareNode, r#true),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverCompareNode, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCOMPARENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverCompareNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCOMPARENODE_TYPE_INFO
    }
}


pub const VOICEOVERCOMPARENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverCompareNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverCompareExpressionType {
    #[default]
    VoiceOverCompareExpressionType_Equals = 0,
    VoiceOverCompareExpressionType_Differs = 1,
    VoiceOverCompareExpressionType_Greater = 2,
    VoiceOverCompareExpressionType_Less = 3,
    VoiceOverCompareExpressionType_GreaterOrEquals = 4,
    VoiceOverCompareExpressionType_LessOrEquals = 5,
}

pub const VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareExpressionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCOMPAREEXPRESSIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverCompareExpressionType {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO
    }
}


pub const VOICEOVERCOMPAREEXPRESSIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareExpressionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverCompareExpressionType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverArithmeticNodeConfigData {
    pub operation: VoiceOverArithmeticExpressionType,
}

pub const VOICEOVERARITHMETICNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverArithmeticNodeConfigData, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERARITHMETICNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverArithmeticNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERARITHMETICNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERARITHMETICNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverArithmeticNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverArithmeticNode {
    pub a: VoiceOverValueConnection,
    pub b: VoiceOverValueConnection,
    pub result: VoiceOverValue,
    pub operation: VoiceOverArithmeticExpressionType,
}

pub const VOICEOVERARITHMETICNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverArithmeticNode, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUECONNECTION_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverArithmeticNode, b),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverArithmeticNode, result),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverArithmeticNode, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERARITHMETICNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverArithmeticNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERARITHMETICNODE_TYPE_INFO
    }
}


pub const VOICEOVERARITHMETICNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverArithmeticNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverArithmeticExpressionType {
    #[default]
    VoiceOverArithmeticExpressionType_Addition = 0,
    VoiceOverArithmeticExpressionType_Subtraction = 1,
    VoiceOverArithmeticExpressionType_Multiplication = 2,
    VoiceOverArithmeticExpressionType_Division = 3,
    VoiceOverArithmeticExpressionType_Difference = 4,
}

pub const VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticExpressionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERARITHMETICEXPRESSIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverArithmeticExpressionType {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO
    }
}


pub const VOICEOVERARITHMETICEXPRESSIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticExpressionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverArithmeticExpressionType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverStructureConnection {
    pub target_node: VoiceOverStructureNode,
    pub target_input: VoiceOverRelationshipInput,
}

pub const VOICEOVERSTRUCTURECONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureConnection",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TargetNode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERSTRUCTURENODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverStructureConnection, target_node),
            },
            FieldInfoData {
                name: "TargetInput",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERRELATIONSHIPINPUT_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverStructureConnection, target_input),
            },
        ],
    }),
    array_type: Some(VOICEOVERSTRUCTURECONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverStructureConnection {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERSTRUCTURECONNECTION_TYPE_INFO
    }
}


pub const VOICEOVERSTRUCTURECONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverStructureConnection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverRelationshipInput {
}

pub const VOICEOVERRELATIONSHIPINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRelationshipInput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERRELATIONSHIPINPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRelationshipInput {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERRELATIONSHIPINPUT_TYPE_INFO
    }
}


pub const VOICEOVERRELATIONSHIPINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRelationshipInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRelationshipInput-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverValueConnection {
    pub target_node: VoiceOverExpressionNode,
    pub target_value: VoiceOverValue,
}

pub const VOICEOVERVALUECONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueConnection",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "TargetNode",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEREXPRESSIONNODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverValueConnection, target_node),
            },
            FieldInfoData {
                name: "TargetValue",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverValueConnection, target_value),
            },
        ],
    }),
    array_type: Some(VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverValueConnection {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERVALUECONNECTION_TYPE_INFO
    }
}


pub const VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValueConnection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverExpressionNode {
}

pub const VOICEOVEREXPRESSIONNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverExpressionNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODE_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVEREXPRESSIONNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverExpressionNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVEREXPRESSIONNODE_TYPE_INFO
    }
}


pub const VOICEOVEREXPRESSIONNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverExpressionNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverExpressionNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct EntityVoiceOverInfo {
    pub voice_over_type: VoiceOverObject,
    pub labels: Vec<VoiceOverLabel>,
}

pub const ENTITYVOICEOVERINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityVoiceOverInfo",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "VoiceOverType",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVEROBJECT_TYPE_INFO,
                rust_offset: offset_of!(EntityVoiceOverInfo, voice_over_type),
            },
            FieldInfoData {
                name: "Labels",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERLABEL_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(EntityVoiceOverInfo, labels),
            },
        ],
    }),
    array_type: Some(ENTITYVOICEOVERINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntityVoiceOverInfo {
    fn type_info() -> &'static TypeInfo {
        ENTITYVOICEOVERINFO_TYPE_INFO
    }
}


pub const ENTITYVOICEOVERINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityVoiceOverInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EntityVoiceOverInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverInterval {
    pub name: String,
    pub name_hash: u32,
}

pub const VOICEOVERINTERVAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInterval",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInterval, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverInterval, name_hash),
            },
        ],
    }),
    array_type: Some(VOICEOVERINTERVAL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverInterval {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERINTERVAL_TYPE_INFO
    }
}


pub const VOICEOVERINTERVAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInterval-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverInterval-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverLabel {
    pub name: String,
    pub name_hash: u32,
}

pub const VOICEOVERLABEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabel",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabel, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverLabel, name_hash),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABEL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabel {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERLABEL_TYPE_INFO
    }
}


pub const VOICEOVERLABEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabel-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverValueRedirect {
    pub source: VoiceOverValue,
    pub target: VoiceOverValue,
}

pub const VOICEOVERVALUEREDIRECT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueRedirect",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverValueRedirect, source),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverValueRedirect, target),
            },
        ],
    }),
    array_type: Some(VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverValueRedirect {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERVALUEREDIRECT_TYPE_INFO
    }
}


pub const VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueRedirect-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValueRedirect-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverNodeConfigData {
    pub node: VoiceOverNode,
}

pub const VOICEOVERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERNODE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverNodeConfigData, node),
            },
        ],
    }),
    array_type: Some(VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERNODECONFIGDATA_TYPE_INFO
    }
}


pub const VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverNode {
}

pub const VOICEOVERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverNode {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERNODE_TYPE_INFO
    }
}


pub const VOICEOVERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverNode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VoiceOverEvent {
    pub name: String,
    pub name_hash: u32,
    pub parameters: Vec<VoiceOverNamedValue>,
    pub owner: VoiceOverLogicAsset,
}

pub const VOICEOVEREVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEvent",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEvent, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEvent, name_hash),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEvent, parameters),
            },
            FieldInfoData {
                name: "Owner",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERLOGICASSET_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverEvent, owner),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverEvent {
    fn type_info() -> &'static TypeInfo {
        VOICEOVEREVENT_TYPE_INFO
    }
}


pub const VOICEOVEREVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverEvent-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverObject {
    pub properties: Vec<VoiceOverNamedValue>,
}

pub const VOICEOVEROBJECT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObject",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNAMEDVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverObject, properties),
            },
        ],
    }),
    array_type: Some(VOICEOVEROBJECT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverObject {
    fn type_info() -> &'static TypeInfo {
        VOICEOVEROBJECT_TYPE_INFO
    }
}


pub const VOICEOVEROBJECT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObject-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverObject-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverNamedValue {
    pub name: String,
    pub name_hash: u32,
    pub value_type: VoiceOverValueType,
}

pub const VOICEOVERNAMEDVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNamedValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERVALUE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverNamedValue, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverNamedValue, name_hash),
            },
            FieldInfoData {
                name: "ValueType",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERVALUETYPE_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverNamedValue, value_type),
            },
        ],
    }),
    array_type: Some(VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverNamedValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERNAMEDVALUE_TYPE_INFO
    }
}


pub const VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNamedValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverNamedValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverValue {
}

pub const VOICEOVERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverValue {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERVALUE_TYPE_INFO
    }
}


pub const VOICEOVERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValue-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VoiceOverValueType {
    #[default]
    VoiceOverValueType_Boolean = 0,
    VoiceOverValueType_Integer = 1,
    VoiceOverValueType_Float = 2,
    VoiceOverValueType_Vector = 3,
    VoiceOverValueType_Object = 4,
    VoiceOverValueTypeCount = 5,
}

pub const VOICEOVERVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverValueType {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERVALUETYPE_TYPE_INFO
    }
}


pub const VOICEOVERVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValueType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPlayerNodeConfigData {
    pub asset: MusicBaseAsset,
}

pub const MUSICPLAYERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICBASEASSET_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeConfigData, asset),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERNODECONFIGDATA_TYPE_INFO
    }
}


pub const MUSICPLAYERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPlayerNodeData {
    pub pitch: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub buffer: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub pause: AudioGraphNodePort,
    pub unpause: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub overlay: AudioGraphNodePort,
    pub is_buffered: AudioGraphNodePort,
    pub is_finished: AudioGraphNodePort,
    pub asset: MusicBaseAsset,
    pub default_start_event_name_hash: u32,
    pub entries: Vec<MusicPlayerEntry>,
    pub layers: Vec<MusicLayerEntry>,
    pub plugins: Vec<MusicPlayerPlugins>,
    pub routed_voices: Vec<MusicPlayerRoutedVoice>,
    pub pitch_source: OutputNodeData,
    pub on_beat: AudioGraphNodePort,
    pub on_bar: AudioGraphNodePort,
    pub on_transition: AudioGraphNodePort,
}

pub const MUSICPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, pitch),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, amplitude),
            },
            FieldInfoData {
                name: "Buffer",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, buffer),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, stop),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, pause),
            },
            FieldInfoData {
                name: "Unpause",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, unpause),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, output),
            },
            FieldInfoData {
                name: "Overlay",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, overlay),
            },
            FieldInfoData {
                name: "IsBuffered",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, is_buffered),
            },
            FieldInfoData {
                name: "IsFinished",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, is_finished),
            },
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICBASEASSET_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, asset),
            },
            FieldInfoData {
                name: "DefaultStartEventNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, default_start_event_name_hash),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPLAYERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, entries),
            },
            FieldInfoData {
                name: "Layers",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICLAYERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, layers),
            },
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, plugins),
            },
            FieldInfoData {
                name: "RoutedVoices",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, routed_voices),
            },
            FieldInfoData {
                name: "PitchSource",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, pitch_source),
            },
            FieldInfoData {
                name: "OnBeat",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, on_beat),
            },
            FieldInfoData {
                name: "OnBar",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, on_bar),
            },
            FieldInfoData {
                name: "OnTransition",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerNodeData, on_transition),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerNodeData {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERNODEDATA_TYPE_INFO
    }
}


pub const MUSICPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicLayerEntry {
    pub amplitude: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
}

pub const MUSICLAYERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicLayerEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicLayerEntry, amplitude),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicLayerEntry, output),
            },
        ],
    }),
    array_type: Some(MUSICLAYERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicLayerEntry {
    fn type_info() -> &'static TypeInfo {
        MUSICLAYERENTRY_TYPE_INFO
    }
}


pub const MUSICLAYERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicLayerEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicLayerEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPlayerEntry {
    pub r#in: AudioGraphNodePort,
    pub target_name_hash: u32,
    pub is_event: bool,
}

pub const MUSICPLAYERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerEntry, r#in),
            },
            FieldInfoData {
                name: "TargetNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerEntry, target_name_hash),
            },
            FieldInfoData {
                name: "IsEvent",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerEntry, is_event),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerEntry {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERENTRY_TYPE_INFO
    }
}


pub const MUSICPLAYERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicPlayerRoutedVoice {
    pub layer_count: u8,
    pub routed_plugins: Vec<MusicPlayerRoutedPlugins>,
    pub routed_target_plugins: Vec<MusicPlayerRoutedTargetPlugins>,
}

pub const MUSICPLAYERROUTEDVOICE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedVoice",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "LayerCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedVoice, layer_count),
            },
            FieldInfoData {
                name: "RoutedPlugins",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedVoice, routed_plugins),
            },
            FieldInfoData {
                name: "RoutedTargetPlugins",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedVoice, routed_target_plugins),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerRoutedVoice {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERROUTEDVOICE_TYPE_INFO
    }
}


pub const MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedVoice-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerRoutedVoice-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicPlayerRoutedTargetPlugins {
    pub none: SoundGraphPluginRef,
}

pub const MUSICPLAYERROUTEDTARGETPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedTargetPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "None",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedTargetPlugins, none),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPlayerRoutedTargetPlugins {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERROUTEDTARGETPLUGINS_TYPE_INFO
    }
}


pub const MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedTargetPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerRoutedTargetPlugins-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicPlayerRoutedPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub resample: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
    pub route: Vec<SoundGraphPluginRef>,
}

pub const MUSICPLAYERROUTEDPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedPlugins",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, snd_player),
            },
            FieldInfoData {
                name: "Resample",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, resample),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, gain),
            },
            FieldInfoData {
                name: "Route",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, route),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerRoutedPlugins {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERROUTEDPLUGINS_TYPE_INFO
    }
}


pub const MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerRoutedPlugins-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicPlayerPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub rechannel: SoundGraphPluginRef,
    pub resample: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
}

pub const MUSICPLAYERPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerPlugins, snd_player),
            },
            FieldInfoData {
                name: "Rechannel",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerPlugins, rechannel),
            },
            FieldInfoData {
                name: "Resample",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerPlugins, resample),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayerPlugins, gain),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPlayerPlugins {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYERPLUGINS_TYPE_INFO
    }
}


pub const MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerPlugins-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct LoadingMusicBundleAsset {
    pub assets: Vec<SoundAsset>,
    pub unique_id: String,
    pub super_bundle: String,
}

pub const LOADINGMUSICBUNDLEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicBundleAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Assets",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDASSET_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(LoadingMusicBundleAsset, assets),
            },
            FieldInfoData {
                name: "UniqueId",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LoadingMusicBundleAsset, unique_id),
            },
            FieldInfoData {
                name: "SuperBundle",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LoadingMusicBundleAsset, super_bundle),
            },
        ],
    }),
    array_type: Some(LOADINGMUSICBUNDLEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LoadingMusicBundleAsset {
    fn type_info() -> &'static TypeInfo {
        LOADINGMUSICBUNDLEASSET_TYPE_INFO
    }
}


pub const LOADINGMUSICBUNDLEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicBundleAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LoadingMusicBundleAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MusicMarkerType {
    #[default]
    MusicMarkerType_None = 0,
    MusicMarkerType_Beat = 1,
    MusicMarkerType_Bar = 2,
}

pub const MUSICMARKERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMarkerType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICMARKERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicMarkerType {
    fn type_info() -> &'static TypeInfo {
        MUSICMARKERTYPE_TYPE_INFO
    }
}


pub const MUSICMARKERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMarkerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicMarkerType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MusicFadeType {
    #[default]
    MusicFadeType_Seconds = 0,
    MusicFadeType_Milliseconds = 1,
    MusicFadeType_Beats = 2,
    MusicFadeType_Bars = 3,
}

pub const MUSICFADETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICFADETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicFadeType {
    fn type_info() -> &'static TypeInfo {
        MUSICFADETYPE_TYPE_INFO
    }
}


pub const MUSICFADETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicFadeType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPlaylistAsset {
    pub playlist_type: MusicPlaylistType,
    pub assets: Vec<MusicAsset>,
    pub selectors: Vec<MusicPlaylistSelector>,
    pub fade: SynchedFadeData,
    pub repeat: bool,
    pub min_delay: f32,
    pub max_delay: f32,
}

pub const MUSICPLAYLISTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICBASEASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PlaylistType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICPLAYLISTTYPE_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, playlist_type),
            },
            FieldInfoData {
                name: "Assets",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICASSET_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, assets),
            },
            FieldInfoData {
                name: "Selectors",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, selectors),
            },
            FieldInfoData {
                name: "Fade",
                flags: MemberInfoFlags::new(0),
                field_type: SYNCHEDFADEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, fade),
            },
            FieldInfoData {
                name: "Repeat",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, repeat),
            },
            FieldInfoData {
                name: "MinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, min_delay),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistAsset, max_delay),
            },
        ],
    }),
    array_type: Some(MUSICPLAYLISTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlaylistAsset {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYLISTASSET_TYPE_INFO
    }
}


pub const MUSICPLAYLISTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlaylistAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPlaylistSelector {
    pub event: MusicEventData,
    pub target: MusicAsset,
    pub trigger_on_target: MusicEventData,
}

pub const MUSICPLAYLISTSELECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistSelector",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICEVENTDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistSelector, event),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICASSET_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistSelector, target),
            },
            FieldInfoData {
                name: "TriggerOnTarget",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICEVENTDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicPlaylistSelector, trigger_on_target),
            },
        ],
    }),
    array_type: Some(MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlaylistSelector {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYLISTSELECTOR_TYPE_INFO
    }
}


pub const MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistSelector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlaylistSelector-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MusicPlaylistType {
    #[default]
    MusicPlaylistType_PlayFirstAndShuffle = 0,
    MusicPlaylistType_Random = 1,
    MusicPlaylistType_Shuffle = 2,
    MusicPlaylistType_Sequential = 3,
}

pub const MUSICPLAYLISTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICPLAYLISTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPlaylistType {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYLISTTYPE_TYPE_INFO
    }
}


pub const MUSICPLAYLISTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlaylistType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicAsset {
    pub name_hash: u32,
    pub metadata: MusicMetadataBase,
    pub beats_per_minute: u32,
    pub beats_per_bar: u32,
    pub playables: Vec<MusicStreamableData>,
    pub overlays: Vec<MusicOverlayData>,
    pub selectors: Vec<MusicSelectorBase>,
    pub default_selector: MusicSelectorBase,
    pub fallback_transitions: Vec<MusicTransition>,
    pub voice_priority: u8,
}

pub const MUSICASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICBASEASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, name_hash),
            },
            FieldInfoData {
                name: "Metadata",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICMETADATABASE_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, metadata),
            },
            FieldInfoData {
                name: "BeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, beats_per_minute),
            },
            FieldInfoData {
                name: "BeatsPerBar",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, beats_per_bar),
            },
            FieldInfoData {
                name: "Playables",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, playables),
            },
            FieldInfoData {
                name: "Overlays",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICOVERLAYDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, overlays),
            },
            FieldInfoData {
                name: "Selectors",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICSELECTORBASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, selectors),
            },
            FieldInfoData {
                name: "DefaultSelector",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSELECTORBASE_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, default_selector),
            },
            FieldInfoData {
                name: "FallbackTransitions",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICTRANSITION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, fallback_transitions),
            },
            FieldInfoData {
                name: "VoicePriority",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(MusicAsset, voice_priority),
            },
        ],
    }),
    array_type: Some(MUSICASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicAsset {
    fn type_info() -> &'static TypeInfo {
        MUSICASSET_TYPE_INFO
    }
}


pub const MUSICASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicBaseAsset {
    pub interface: MusicInterfaceAsset,
    pub max_overlay_count: u32,
    pub channel_count: u8,
    pub overlay_channel_count: u8,
}

pub const MUSICBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicBaseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Interface",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICINTERFACEASSET_TYPE_INFO,
                rust_offset: offset_of!(MusicBaseAsset, interface),
            },
            FieldInfoData {
                name: "MaxOverlayCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicBaseAsset, max_overlay_count),
            },
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(MusicBaseAsset, channel_count),
            },
            FieldInfoData {
                name: "OverlayChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(MusicBaseAsset, overlay_channel_count),
            },
        ],
    }),
    array_type: Some(MUSICBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicBaseAsset {
    fn type_info() -> &'static TypeInfo {
        MUSICBASEASSET_TYPE_INFO
    }
}


pub const MUSICBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicBaseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicBaseAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicTransition {
    pub source: MusicStreamableData,
    pub destination: MusicStreamableData,
    pub fade: BasicFadeData,
    pub overlay_control: OverlayControl,
}

pub const MUSICTRANSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicTransition",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSTREAMABLEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicTransition, source),
            },
            FieldInfoData {
                name: "Destination",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSTREAMABLEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicTransition, destination),
            },
            FieldInfoData {
                name: "Fade",
                flags: MemberInfoFlags::new(0),
                field_type: BASICFADEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicTransition, fade),
            },
            FieldInfoData {
                name: "OverlayControl",
                flags: MemberInfoFlags::new(0),
                field_type: OVERLAYCONTROL_TYPE_INFO,
                rust_offset: offset_of!(MusicTransition, overlay_control),
            },
        ],
    }),
    array_type: Some(MUSICTRANSITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicTransition {
    fn type_info() -> &'static TypeInfo {
        MUSICTRANSITION_TYPE_INFO
    }
}


pub const MUSICTRANSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicTransition-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicTransition-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicSelectorParameter {
    pub parameter: MusicParameterData,
    pub selectors: Vec<ParameterBoundSelector>,
}

pub const MUSICSELECTORPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSELECTORBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Parameter",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICPARAMETERDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicSelectorParameter, parameter),
            },
            FieldInfoData {
                name: "Selectors",
                flags: MemberInfoFlags::new(144),
                field_type: PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicSelectorParameter, selectors),
            },
        ],
    }),
    array_type: Some(MUSICSELECTORPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicSelectorParameter {
    fn type_info() -> &'static TypeInfo {
        MUSICSELECTORPARAMETER_TYPE_INFO
    }
}


pub const MUSICSELECTORPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelectorParameter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ParameterBoundSelector {
    pub parameter_value: f32,
    pub selector: MusicSelector,
}

pub const PARAMETERBOUNDSELECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterBoundSelector",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ParameterValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ParameterBoundSelector, parameter_value),
            },
            FieldInfoData {
                name: "Selector",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSELECTOR_TYPE_INFO,
                rust_offset: offset_of!(ParameterBoundSelector, selector),
            },
        ],
    }),
    array_type: Some(PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterBoundSelector {
    fn type_info() -> &'static TypeInfo {
        PARAMETERBOUNDSELECTOR_TYPE_INFO
    }
}


pub const PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterBoundSelector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterBoundSelector-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicSelector {
    pub trigger_type: MusicSelectorTriggerType,
    pub sync_type: MusicSyncType,
    pub target: MusicStreamableData,
    pub default: MusicTransition,
    pub transitions: Vec<MusicTransition>,
}

pub const MUSICSELECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelector",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSELECTORBASE_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "TriggerType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSELECTORTRIGGERTYPE_TYPE_INFO,
                rust_offset: offset_of!(MusicSelector, trigger_type),
            },
            FieldInfoData {
                name: "SyncType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSYNCTYPE_TYPE_INFO,
                rust_offset: offset_of!(MusicSelector, sync_type),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSTREAMABLEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicSelector, target),
            },
            FieldInfoData {
                name: "Default",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICTRANSITION_TYPE_INFO,
                rust_offset: offset_of!(MusicSelector, default),
            },
            FieldInfoData {
                name: "Transitions",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICTRANSITION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicSelector, transitions),
            },
        ],
    }),
    array_type: Some(MUSICSELECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicSelector {
    fn type_info() -> &'static TypeInfo {
        MUSICSELECTOR_TYPE_INFO
    }
}


pub const MUSICSELECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelector-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicSelectorBase {
    pub event: MusicEventData,
}

pub const MUSICSELECTORBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorBase",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICEVENTDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicSelectorBase, event),
            },
        ],
    }),
    array_type: Some(MUSICSELECTORBASE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MusicSelectorBase {
    fn type_info() -> &'static TypeInfo {
        MUSICSELECTORBASE_TYPE_INFO
    }
}


pub const MUSICSELECTORBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelectorBase-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct OverlayControl {
    pub overlay: MusicOverlayData,
    pub sync: bool,
}

pub const OVERLAYCONTROL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OverlayControl",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Overlay",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICOVERLAYDATA_TYPE_INFO,
                rust_offset: offset_of!(OverlayControl, overlay),
            },
            FieldInfoData {
                name: "Sync",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(OverlayControl, sync),
            },
        ],
    }),
    array_type: Some(OVERLAYCONTROL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OverlayControl {
    fn type_info() -> &'static TypeInfo {
        OVERLAYCONTROL_TYPE_INFO
    }
}


pub const OVERLAYCONTROL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OverlayControl-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OverlayControl-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MusicSelectorTriggerType {
    #[default]
    MusicSelectorTriggerType_Interrupt = 0,
    MusicSelectorTriggerType_Queue = 1,
    MusicSelectorTriggerType_Fade = 2,
}

pub const MUSICSELECTORTRIGGERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorTriggerType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICSELECTORTRIGGERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicSelectorTriggerType {
    fn type_info() -> &'static TypeInfo {
        MUSICSELECTORTRIGGERTYPE_TYPE_INFO
    }
}


pub const MUSICSELECTORTRIGGERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorTriggerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelectorTriggerType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicInterfaceAsset {
    pub events: Vec<MusicEventData>,
    pub parameters: Vec<MusicParameterData>,
}

pub const MUSICINTERFACEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInterfaceAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ASSET_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICEVENTDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicInterfaceAsset, events),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICPARAMETERDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicInterfaceAsset, parameters),
            },
        ],
    }),
    array_type: Some(MUSICINTERFACEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicInterfaceAsset {
    fn type_info() -> &'static TypeInfo {
        MUSICINTERFACEASSET_TYPE_INFO
    }
}


pub const MUSICINTERFACEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInterfaceAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicInterfaceAsset-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicOverlayData {
    pub variations: Vec<MusicOverlayVariation>,
}

pub const MUSICOVERLAYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICPLAYABLEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Variations",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicOverlayData, variations),
            },
        ],
    }),
    array_type: Some(MUSICOVERLAYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicOverlayData {
    fn type_info() -> &'static TypeInfo {
        MUSICOVERLAYDATA_TYPE_INFO
    }
}


pub const MUSICOVERLAYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicOverlayData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicOverlayVariation {
    pub wave: SoundWaveAssetBase,
    pub transient_point: f32,
}

pub const MUSICOVERLAYVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayVariation",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(MusicOverlayVariation, wave),
            },
            FieldInfoData {
                name: "TransientPoint",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicOverlayVariation, transient_point),
            },
        ],
    }),
    array_type: Some(MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicOverlayVariation {
    fn type_info() -> &'static TypeInfo {
        MUSICOVERLAYVARIATION_TYPE_INFO
    }
}


pub const MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicOverlayVariation-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPhraseData {
    pub selection_type: MusicPhraseSelectionType,
    pub selection_parameter: MusicParameterData,
    pub range_fade: SynchedFadeData,
    pub playables: Vec<MusicStreamableData>,
}

pub const MUSICPHRASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSTREAMABLEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SelectionType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICPHRASESELECTIONTYPE_TYPE_INFO,
                rust_offset: offset_of!(MusicPhraseData, selection_type),
            },
            FieldInfoData {
                name: "SelectionParameter",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICPARAMETERDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicPhraseData, selection_parameter),
            },
            FieldInfoData {
                name: "RangeFade",
                flags: MemberInfoFlags::new(0),
                field_type: SYNCHEDFADEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicPhraseData, range_fade),
            },
            FieldInfoData {
                name: "Playables",
                flags: MemberInfoFlags::new(144),
                field_type: MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MusicPhraseData, playables),
            },
        ],
    }),
    array_type: Some(MUSICPHRASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPhraseData {
    fn type_info() -> &'static TypeInfo {
        MUSICPHRASEDATA_TYPE_INFO
    }
}


pub const MUSICPHRASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPhraseData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicSegmentData {
    pub wave: SoundWaveAssetBase,
    pub multitrack_layers: MultitrackData,
}

pub const MUSICSEGMENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSegmentData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSTREAMABLEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(MusicSegmentData, wave),
            },
            FieldInfoData {
                name: "MultitrackLayers",
                flags: MemberInfoFlags::new(0),
                field_type: MULTITRACKDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicSegmentData, multitrack_layers),
            },
        ],
    }),
    array_type: Some(MUSICSEGMENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicSegmentData {
    fn type_info() -> &'static TypeInfo {
        MUSICSEGMENTDATA_TYPE_INFO
    }
}


pub const MUSICSEGMENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSegmentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSegmentData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultitrackData {
    pub layer_control_parameter: MusicParameterData,
    pub range_fade: SynchedFadeData,
    pub layers: Vec<MultitrackLayerData>,
}

pub const MULTITRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "LayerControlParameter",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICPARAMETERDATA_TYPE_INFO,
                rust_offset: offset_of!(MultitrackData, layer_control_parameter),
            },
            FieldInfoData {
                name: "RangeFade",
                flags: MemberInfoFlags::new(0),
                field_type: SYNCHEDFADEDATA_TYPE_INFO,
                rust_offset: offset_of!(MultitrackData, range_fade),
            },
            FieldInfoData {
                name: "Layers",
                flags: MemberInfoFlags::new(144),
                field_type: MULTITRACKLAYERDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MultitrackData, layers),
            },
        ],
    }),
    array_type: Some(MULTITRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultitrackData {
    fn type_info() -> &'static TypeInfo {
        MULTITRACKDATA_TYPE_INFO
    }
}


pub const MULTITRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultitrackData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MultitrackLayerData {
    pub min_value: f32,
    pub max_value: f32,
    pub amplitudes: Vec<f32>,
}

pub const MULTITRACKLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultitrackLayerData, min_value),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MultitrackLayerData, max_value),
            },
            FieldInfoData {
                name: "Amplitudes",
                flags: MemberInfoFlags::new(144),
                field_type: FLOAT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MultitrackLayerData, amplitudes),
            },
        ],
    }),
    array_type: Some(MULTITRACKLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultitrackLayerData {
    fn type_info() -> &'static TypeInfo {
        MULTITRACKLAYERDATA_TYPE_INFO
    }
}


pub const MULTITRACKLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultitrackLayerData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SynchedFadeData {
    pub sync_type: MusicSyncType,
}

pub const SYNCHEDFADEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SynchedFadeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICFADEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SyncType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSYNCTYPE_TYPE_INFO,
                rust_offset: offset_of!(SynchedFadeData, sync_type),
            },
        ],
    }),
    array_type: Some(SYNCHEDFADEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SynchedFadeData {
    fn type_info() -> &'static TypeInfo {
        SYNCHEDFADEDATA_TYPE_INFO
    }
}


pub const SYNCHEDFADEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SynchedFadeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SynchedFadeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BasicFadeData {
}

pub const BASICFADEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicFadeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICFADEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(BASICFADEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicFadeData {
    fn type_info() -> &'static TypeInfo {
        BASICFADEDATA_TYPE_INFO
    }
}


pub const BASICFADEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicFadeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BasicFadeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicFadeData {
    pub fade_out_length: f32,
    pub fade_out_type: MusicFadeType,
    pub fade_in_length: f32,
    pub fade_in_type: MusicFadeType,
    pub equal_power: bool,
}

pub const MUSICFADEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "FadeOutLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicFadeData, fade_out_length),
            },
            FieldInfoData {
                name: "FadeOutType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICFADETYPE_TYPE_INFO,
                rust_offset: offset_of!(MusicFadeData, fade_out_type),
            },
            FieldInfoData {
                name: "FadeInLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicFadeData, fade_in_length),
            },
            FieldInfoData {
                name: "FadeInType",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICFADETYPE_TYPE_INFO,
                rust_offset: offset_of!(MusicFadeData, fade_in_type),
            },
            FieldInfoData {
                name: "EqualPower",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MusicFadeData, equal_power),
            },
        ],
    }),
    array_type: Some(MUSICFADEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicFadeData {
    fn type_info() -> &'static TypeInfo {
        MUSICFADEDATA_TYPE_INFO
    }
}


pub const MUSICFADEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicFadeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MusicSyncType {
    #[default]
    MusicSyncType_Beat = 0,
    MusicSyncType_Bar = 1,
    MusicSyncType_Immediate = 2,
    MusicSyncType_Timed = 3,
}

pub const MUSICSYNCTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSyncType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICSYNCTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicSyncType {
    fn type_info() -> &'static TypeInfo {
        MUSICSYNCTYPE_TYPE_INFO
    }
}


pub const MUSICSYNCTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSyncType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSyncType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicStreamableData {
    pub range_value: f32,
    pub allow_range_fade: bool,
    pub restart_if_already_playing: bool,
    pub weight: i32,
    pub next_playable: MusicStreamableData,
    pub on_next_playable_overlay: MusicOverlayData,
    pub next_playable_fade_in_time: f32,
    pub metadata: MusicMetadataBase,
}

pub const MUSICSTREAMABLEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicStreamableData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICPLAYABLEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "RangeValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, range_value),
            },
            FieldInfoData {
                name: "AllowRangeFade",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, allow_range_fade),
            },
            FieldInfoData {
                name: "RestartIfAlreadyPlaying",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, restart_if_already_playing),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, weight),
            },
            FieldInfoData {
                name: "NextPlayable",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICSTREAMABLEDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, next_playable),
            },
            FieldInfoData {
                name: "OnNextPlayableOverlay",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICOVERLAYDATA_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, on_next_playable_overlay),
            },
            FieldInfoData {
                name: "NextPlayableFadeInTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, next_playable_fade_in_time),
            },
            FieldInfoData {
                name: "Metadata",
                flags: MemberInfoFlags::new(0),
                field_type: MUSICMETADATABASE_TYPE_INFO,
                rust_offset: offset_of!(MusicStreamableData, metadata),
            },
        ],
    }),
    array_type: Some(MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicStreamableData {
    fn type_info() -> &'static TypeInfo {
        MUSICSTREAMABLEDATA_TYPE_INFO
    }
}


pub const MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicStreamableData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicStreamableData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicPlayableData {
    pub name: String,
    pub play_count: u32,
    pub min_delay: f32,
    pub max_delay: f32,
    pub transition_time: f32,
    pub beats_per_minute: u32,
    pub beats_per_bar: u32,
    pub gain: f32,
    pub pitch: f32,
}

pub const MUSICPLAYABLEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayableData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, name),
            },
            FieldInfoData {
                name: "PlayCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, play_count),
            },
            FieldInfoData {
                name: "MinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, min_delay),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, max_delay),
            },
            FieldInfoData {
                name: "TransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, transition_time),
            },
            FieldInfoData {
                name: "BeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, beats_per_minute),
            },
            FieldInfoData {
                name: "BeatsPerBar",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, beats_per_bar),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, gain),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicPlayableData, pitch),
            },
        ],
    }),
    array_type: Some(MUSICPLAYABLEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayableData {
    fn type_info() -> &'static TypeInfo {
        MUSICPLAYABLEDATA_TYPE_INFO
    }
}


pub const MUSICPLAYABLEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayableData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayableData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicMetadataChangedMessage {
}

pub const MUSICMETADATACHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMetadataChangedMessage",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for MusicMetadataChangedMessage {
    fn type_info() -> &'static TypeInfo {
        MUSICMETADATACHANGEDMESSAGE_TYPE_INFO
    }
}

#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicMetadataBase {
}

pub const MUSICMETADATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMetadataBase",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(MUSICMETADATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicMetadataBase {
    fn type_info() -> &'static TypeInfo {
        MUSICMETADATABASE_TYPE_INFO
    }
}


pub const MUSICMETADATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMetadataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicMetadataBase-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MusicParameterData {
    pub default_value: f32,
}

pub const MUSICPARAMETERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicParameterData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICINPUTDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MusicParameterData, default_value),
            },
        ],
    }),
    array_type: Some(MUSICPARAMETERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicParameterData {
    fn type_info() -> &'static TypeInfo {
        MUSICPARAMETERDATA_TYPE_INFO
    }
}


pub const MUSICPARAMETERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicParameterData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicParameterData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicEventData {
}

pub const MUSICEVENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicEventData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICINPUTDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(MUSICEVENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicEventData {
    fn type_info() -> &'static TypeInfo {
        MUSICEVENTDATA_TYPE_INFO
    }
}


pub const MUSICEVENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicEventData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicEventData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MusicInputData {
    pub name: String,
    pub name_hash: u32,
}

pub const MUSICINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInputData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(MusicInputData, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MusicInputData, name_hash),
            },
        ],
    }),
    array_type: Some(MUSICINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicInputData {
    fn type_info() -> &'static TypeInfo {
        MUSICINPUTDATA_TYPE_INFO
    }
}


pub const MUSICINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicInputData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MusicPhraseSelectionType {
    #[default]
    MusicPhraseSelectionType_PlayFirstAndShuffle = 0,
    MusicPhraseSelectionType_PlayAllAndShuffle = 1,
    MusicPhraseSelectionType_Random = 2,
    MusicPhraseSelectionType_Range = 3,
    MusicPhraseSelectionType_Sequential = 4,
    MusicPhraseSelectionType_Shuffle = 5,
    MusicPhraseSelectionType_Weighted = 6,
}

pub const MUSICPHRASESELECTIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseSelectionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICPHRASESELECTIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPhraseSelectionType {
    fn type_info() -> &'static TypeInfo {
        MUSICPHRASESELECTIONTYPE_TYPE_INFO
    }
}


pub const MUSICPHRASESELECTIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseSelectionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPhraseSelectionType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundContextLinkEntityData {
}

pub const SOUNDCONTEXTLINKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTLINKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextLinkEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTLINKENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTLINKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextLinkEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundContextEntityData {
    pub context_group: SoundContextGroupData,
    pub activate_on_creation: bool,
}

pub const SOUNDCONTEXTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ContextGroup",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDCONTEXTGROUPDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundContextEntityData, context_group),
            },
            FieldInfoData {
                name: "ActivateOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundContextEntityData, activate_on_creation),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDCONTEXTENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDCONTEXTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerEntityData {
    pub activate_on_creation: bool,
    pub accumulated_inputs: bool,
    pub mixer: MixerAsset,
}

pub const MIXERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ActivateOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerEntityData, activate_on_creation),
            },
            FieldInfoData {
                name: "AccumulatedInputs",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MixerEntityData, accumulated_inputs),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(MixerEntityData, mixer),
            },
        ],
    }),
    array_type: Some(MIXERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerEntityData {
    fn type_info() -> &'static TypeInfo {
        MIXERENTITYDATA_TYPE_INFO
    }
}


pub const MIXERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct LoadingMusicEntityData {
    pub sound_guid: super::core::Guid,
    pub bundle_unique_id: String,
    pub load_on_creation: bool,
}

pub const LOADINGMUSICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SoundGuid",
                flags: MemberInfoFlags::new(0),
                field_type: GUID_TYPE_INFO,
                rust_offset: offset_of!(LoadingMusicEntityData, sound_guid),
            },
            FieldInfoData {
                name: "BundleUniqueId",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(LoadingMusicEntityData, bundle_unique_id),
            },
            FieldInfoData {
                name: "LoadOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(LoadingMusicEntityData, load_on_creation),
            },
        ],
    }),
    array_type: Some(LOADINGMUSICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LoadingMusicEntityData {
    fn type_info() -> &'static TypeInfo {
        LOADINGMUSICENTITYDATA_TYPE_INFO
    }
}


pub const LOADINGMUSICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LoadingMusicEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundPauseEntityData {
    pub exclusion_list: Vec<MixGroup>,
}

pub const SOUNDPAUSEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ExclusionList",
                flags: MemberInfoFlags::new(144),
                field_type: MIXGROUP_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundPauseEntityData, exclusion_list),
            },
        ],
    }),
    array_type: Some(SOUNDPAUSEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPauseEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDPAUSEENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDPAUSEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPauseEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundHdrEntityData {
    pub hdr_setting: HdrSetting,
    pub apply_setting_on_creation: bool,
}

pub const SOUNDHDRENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "HdrSetting",
                flags: MemberInfoFlags::new(0),
                field_type: HDRSETTING_TYPE_INFO,
                rust_offset: offset_of!(SoundHdrEntityData, hdr_setting),
            },
            FieldInfoData {
                name: "ApplySettingOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundHdrEntityData, apply_setting_on_creation),
            },
        ],
    }),
    array_type: Some(SOUNDHDRENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundHdrEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDHDRENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDHDRENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundHdrEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct IrReverbEntityData {
    pub impulse_response: ImpulseResponseAsset,
    pub gain: f32,
    pub volume: f32,
    pub fade_curve: FadeCurveType,
    pub is_dominant: bool,
}

pub const IRREVERBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ImpulseResponse",
                flags: MemberInfoFlags::new(0),
                field_type: IMPULSERESPONSEASSET_TYPE_INFO,
                rust_offset: offset_of!(IrReverbEntityData, impulse_response),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(IrReverbEntityData, gain),
            },
            FieldInfoData {
                name: "Volume",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(IrReverbEntityData, volume),
            },
            FieldInfoData {
                name: "FadeCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FADECURVETYPE_TYPE_INFO,
                rust_offset: offset_of!(IrReverbEntityData, fade_curve),
            },
            FieldInfoData {
                name: "IsDominant",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(IrReverbEntityData, is_dominant),
            },
        ],
    }),
    array_type: Some(IRREVERBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IrReverbEntityData {
    fn type_info() -> &'static TypeInfo {
        IRREVERBENTITYDATA_TYPE_INFO
    }
}


pub const IRREVERBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VoiceOverConversationGroupEntityData {
    pub queue_group: VoiceOverConversationQueueGroup,
}

pub const VOICEOVERCONVERSATIONGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "QueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO,
                rust_offset: offset_of!(VoiceOverConversationGroupEntityData, queue_group),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationGroupEntityData {
    fn type_info() -> &'static TypeInfo {
        VOICEOVERCONVERSATIONGROUPENTITYDATA_TYPE_INFO
    }
}


pub const VOICEOVERCONVERSATIONGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationGroupEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeSetupEntityData {
    pub setup: SoundScopeSetupData,
}

pub const SOUNDSCOPESETUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Setup",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPESETUPDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeSetupEntityData, setup),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESETUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeSetupEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPESETUPENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPESETUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeSetupEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundDataEntityData {
    pub data_assets: Vec<SoundDataAsset>,
}

pub const SOUNDDATAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "DataAssets",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDDATAASSET_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundDataEntityData, data_assets),
            },
        ],
    }),
    array_type: Some(SOUNDDATAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDDATAENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDDATAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundMasterEntityData {
    pub master: SoundMasterPatchAsset,
    pub support_dynamic_propeties: bool,
}

pub const SOUNDMASTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Master",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDMASTERPATCHASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundMasterEntityData, master),
            },
            FieldInfoData {
                name: "SupportDynamicPropeties",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundMasterEntityData, support_dynamic_propeties),
            },
        ],
    }),
    array_type: Some(SOUNDMASTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundMasterEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDMASTERENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDMASTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundMasterEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityData {
    pub transform: super::core::LinearTransform,
    pub sound: SoundAsset,
    pub play_on_creation: bool,
    pub enable_on_creation: bool,
    pub use_parent_transform: bool,
    pub forget_on_destroy: bool,
    pub master_amplitude: f32,
}

pub const SOUNDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: LINEARTRANSFORM_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, transform),
            },
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, sound),
            },
            FieldInfoData {
                name: "PlayOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, play_on_creation),
            },
            FieldInfoData {
                name: "EnableOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, enable_on_creation),
            },
            FieldInfoData {
                name: "UseParentTransform",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, use_parent_transform),
            },
            FieldInfoData {
                name: "ForgetOnDestroy",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, forget_on_destroy),
            },
            FieldInfoData {
                name: "MasterAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityData, master_amplitude),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoundEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEffectEntityData {
    pub sound: SoundAsset,
    pub use_default_stop_event: bool,
}

pub const SOUNDEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEffectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(CHILDEFFECTENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundEffectEntityData, sound),
            },
            FieldInfoData {
                name: "UseDefaultStopEvent",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEffectEntityData, use_default_stop_event),
            },
        ],
    }),
    array_type: Some(SOUNDEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoundEffectEntityData {
    fn type_info() -> &'static TypeInfo {
        SOUNDEFFECTENTITYDATA_TYPE_INFO
    }
}


pub const SOUNDEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEffectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEffectEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackData {
    pub sound: SoundAsset,
    pub force_stop_with_timeline: bool,
    pub fire_default_stop_event_on_complete: bool,
    pub layer_tracks: Vec<super::timeline::TimelineTrackData>,
    pub guide_track_source: AudioGraphParameter,
    pub skipped_event: AudioGraphEvent,
    pub buffer_event: AudioGraphEvent,
    pub buffered_event: AudioGraphEvent,
    pub seek_to_event: AudioGraphEvent,
    pub seek_to_parameter: AudioGraphParameter,
    pub sound_length_parameter: AudioGraphParameter,
    pub finished_event: AudioGraphEvent,
    pub guide_track_priority: i32,
}

pub const SOUNDENTITYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TIMELINETRACKDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDASSET_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, sound),
            },
            FieldInfoData {
                name: "ForceStopWithTimeline",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, force_stop_with_timeline),
            },
            FieldInfoData {
                name: "FireDefaultStopEventOnComplete",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, fire_default_stop_event_on_complete),
            },
            FieldInfoData {
                name: "LayerTracks",
                flags: MemberInfoFlags::new(144),
                field_type: TIMELINETRACKDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, layer_tracks),
            },
            FieldInfoData {
                name: "GuideTrackSource",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, guide_track_source),
            },
            FieldInfoData {
                name: "SkippedEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, skipped_event),
            },
            FieldInfoData {
                name: "BufferEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, buffer_event),
            },
            FieldInfoData {
                name: "BufferedEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, buffered_event),
            },
            FieldInfoData {
                name: "SeekToEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, seek_to_event),
            },
            FieldInfoData {
                name: "SeekToParameter",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, seek_to_parameter),
            },
            FieldInfoData {
                name: "SoundLengthParameter",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHPARAMETER_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, sound_length_parameter),
            },
            FieldInfoData {
                name: "FinishedEvent",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHEVENT_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, finished_event),
            },
            FieldInfoData {
                name: "GuideTrackPriority",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackData, guide_track_priority),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackAssetLayerData {
    pub keyframes: Vec<SoundEntityTrackAssetKeyframeData>,
    pub fire_events_upon_skip: bool,
}

pub const SOUNDENTITYTRACKASSETLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackAssetLayerData, keyframes),
            },
            FieldInfoData {
                name: "FireEventsUponSkip",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackAssetLayerData, fire_events_upon_skip),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKASSETLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackAssetLayerData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKASSETLAYERDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKASSETLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackAssetLayerData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackParameterLayerData {
    pub curve_data: super::timeline::CurveData,
}

pub const SOUNDENTITYTRACKPARAMETERLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "CurveData",
                flags: MemberInfoFlags::new(0),
                field_type: CURVEDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackParameterLayerData, curve_data),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKPARAMETERLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackParameterLayerData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKPARAMETERLAYERDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKPARAMETERLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackParameterLayerData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackEventLayerData {
    pub keyframes: Vec<SoundEntityTrackEventKeyframeData>,
    pub fire_events_upon_skip: bool,
}

pub const SOUNDENTITYTRACKEVENTLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackEventLayerData, keyframes),
            },
            FieldInfoData {
                name: "FireEventsUponSkip",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackEventLayerData, fire_events_upon_skip),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKEVENTLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackEventLayerData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKEVENTLAYERDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKEVENTLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackEventLayerData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundEntityTrackLayerData {
    pub layer_hash: u32,
}

pub const SOUNDENTITYTRACKLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TIMELINETRACKDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "LayerHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackLayerData, layer_hash),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackLayerData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKLAYERDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackLayerData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackTransformLayerData {
    pub layer_hash: u32,
}

pub const SOUNDENTITYTRACKTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(LAYEREDTRANSFORMTRACKDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "LayerHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackTransformLayerData, layer_hash),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackTransformLayerData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKTRANSFORMLAYERDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackTransformLayerData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackAssetKeyframeData {
    pub asset: SoundWaveAssetBase,
    pub trigger_default_start_event: bool,
}

pub const SOUNDENTITYTRACKASSETKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetKeyframeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackAssetKeyframeData, asset),
            },
            FieldInfoData {
                name: "TriggerDefaultStartEvent",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackAssetKeyframeData, trigger_default_start_event),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackAssetKeyframeData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKASSETKEYFRAMEDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetKeyframeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackAssetKeyframeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackEventKeyframeData {
}

pub const SOUNDENTITYTRACKEVENTKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventKeyframeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackEventKeyframeData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKEVENTKEYFRAMEDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventKeyframeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackEventKeyframeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundEntityTrackKeyframeData {
    pub time: f32,
}

pub const SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackKeyframeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(TIMELINEKEYFRAMEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundEntityTrackKeyframeData, time),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackKeyframeData {
    fn type_info() -> &'static TypeInfo {
        SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO
    }
}


pub const SOUNDENTITYTRACKKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackKeyframeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackKeyframeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct NewWaveAssetObserverEntityData {
    pub new_wave_asset: NewWaveAsset,
}

pub const NEWWAVEASSETOBSERVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAssetObserverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(ENTITYDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "NewWaveAsset",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVEASSET_TYPE_INFO,
                rust_offset: offset_of!(NewWaveAssetObserverEntityData, new_wave_asset),
            },
        ],
    }),
    array_type: Some(NEWWAVEASSETOBSERVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveAssetObserverEntityData {
    fn type_info() -> &'static TypeInfo {
        NEWWAVEASSETOBSERVERENTITYDATA_TYPE_INFO
    }
}


pub const NEWWAVEASSETOBSERVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAssetObserverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveAssetObserverEntityData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct PropertySortScopeStageData {
    pub count: u32,
    pub property: ScopeStageSortProperty,
    pub order: PropertySortScopeStageOrder,
}

pub const PROPERTYSORTSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDSCOPESTAGEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(PropertySortScopeStageData, count),
            },
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: SCOPESTAGESORTPROPERTY_TYPE_INFO,
                rust_offset: offset_of!(PropertySortScopeStageData, property),
            },
            FieldInfoData {
                name: "Order",
                flags: MemberInfoFlags::new(0),
                field_type: PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO,
                rust_offset: offset_of!(PropertySortScopeStageData, order),
            },
        ],
    }),
    array_type: Some(PROPERTYSORTSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertySortScopeStageData {
    fn type_info() -> &'static TypeInfo {
        PROPERTYSORTSCOPESTAGEDATA_TYPE_INFO
    }
}


pub const PROPERTYSORTSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PropertySortScopeStageData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum PropertySortScopeStageOrder {
    #[default]
    PropertySortScopeStageOrder_Ascending = 0,
    PropertySortScopeStageOrder_Descending = 1,
}

pub const PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageOrder",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PROPERTYSORTSCOPESTAGEORDER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PropertySortScopeStageOrder {
    fn type_info() -> &'static TypeInfo {
        PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO
    }
}


pub const PROPERTYSORTSCOPESTAGEORDER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageOrder-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PropertySortScopeStageOrder-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ScopeStageSortProperty {
    #[default]
    ScopeStageSortProperty_DistanceToListener = 0,
    ScopeStageSortProperty_Loudness = 1,
    ScopeStageSortProperty_PotentialLoudness = 2,
    ScopeStageSortProperty_Age = 3,
    ScopeStageSortProperty_InterpolatedLoudness = 4,
}

pub const SCOPESTAGESORTPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeStageSortProperty",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SCOPESTAGESORTPROPERTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ScopeStageSortProperty {
    fn type_info() -> &'static TypeInfo {
        SCOPESTAGESORTPROPERTY_TYPE_INFO
    }
}


pub const SCOPESTAGESORTPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeStageSortProperty-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScopeStageSortProperty-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DuplicateSpawnScopeStageData {
    pub time: f32,
    pub distance: f32,
    pub group_types: bool,
    pub closest_count: u32,
}

pub const DUPLICATESPAWNSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DuplicateSpawnScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDSCOPESTAGEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, time),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, distance),
            },
            FieldInfoData {
                name: "GroupTypes",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, group_types),
            },
            FieldInfoData {
                name: "ClosestCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, closest_count),
            },
        ],
    }),
    array_type: Some(DUPLICATESPAWNSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DuplicateSpawnScopeStageData {
    fn type_info() -> &'static TypeInfo {
        DUPLICATESPAWNSCOPESTAGEDATA_TYPE_INFO
    }
}


pub const DUPLICATESPAWNSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DuplicateSpawnScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DuplicateSpawnScopeStageData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct MaxInstancesScopeStageData {
    pub count: u32,
    pub keep_oldest: bool,
}

pub const MAXINSTANCESSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaxInstancesScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDSCOPESTAGEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(MaxInstancesScopeStageData, count),
            },
            FieldInfoData {
                name: "KeepOldest",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(MaxInstancesScopeStageData, keep_oldest),
            },
        ],
    }),
    array_type: Some(MAXINSTANCESSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaxInstancesScopeStageData {
    fn type_info() -> &'static TypeInfo {
        MAXINSTANCESSCOPESTAGEDATA_TYPE_INFO
    }
}


pub const MAXINSTANCESSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaxInstancesScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MaxInstancesScopeStageData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeSetupData {
    pub name: String,
    pub mappings: Vec<SoundScopeStrategyMapping>,
}

pub const SOUNDSCOPESETUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeSetupData, name),
            },
            FieldInfoData {
                name: "Mappings",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeSetupData, mappings),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeSetupData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPESETUPDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeSetupData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeStrategyMapping {
    pub scope: SoundScopeData,
    pub strategy: SoundScopeStrategyData,
}

pub const SOUNDSCOPESTRATEGYMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyMapping",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Scope",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPEDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeStrategyMapping, scope),
            },
            FieldInfoData {
                name: "Strategy",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPESTRATEGYDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeStrategyMapping, strategy),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeStrategyMapping {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPESTRATEGYMAPPING_TYPE_INFO
    }
}


pub const SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeStrategyMapping-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeStrategyData {
    pub name: String,
    pub stages: Vec<SoundScopeStageData>,
}

pub const SOUNDSCOPESTRATEGYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeStrategyData, name),
            },
            FieldInfoData {
                name: "Stages",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeStrategyData, stages),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeStrategyData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPESTRATEGYDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeStrategyData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeStageData {
}

pub const SOUNDSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeStageData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPESTAGEDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeStageData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundScopeAggregateData {
    pub name: String,
    pub strategy: SoundScopeStrategyData,
    pub max_input_count: u32,
    pub inputs: Vec<SoundScopeAggregateInputData>,
}

pub const SOUNDSCOPEAGGREGATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeAggregateData, name),
            },
            FieldInfoData {
                name: "Strategy",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPESTRATEGYDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeAggregateData, strategy),
            },
            FieldInfoData {
                name: "MaxInputCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeAggregateData, max_input_count),
            },
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeAggregateData, inputs),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeAggregateData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPEAGGREGATEDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeAggregateData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundScopeAggregateInputData {
    pub source: super::core::DataContainer,
    pub weight: f32,
}

pub const SOUNDSCOPEAGGREGATEINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateInputData",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: DATACONTAINER_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeAggregateInputData, source),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeAggregateInputData, weight),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeAggregateInputData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPEAGGREGATEINPUTDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeAggregateInputData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundScopeData {
    pub name: String,
    pub default_strategy: SoundScopeStrategyData,
}

pub const SOUNDSCOPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeData, name),
            },
            FieldInfoData {
                name: "DefaultStrategy",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDSCOPESTRATEGYDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundScopeData, default_strategy),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeData {
    fn type_info() -> &'static TypeInfo {
        SOUNDSCOPEDATA_TYPE_INFO
    }
}


pub const SOUNDSCOPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EqualizerSettings {
    pub low_shelf_frequency: f32,
    pub low_shelf_gain: f32,
    pub high_shelf_frequency: f32,
    pub high_shelf_gain: f32,
    pub hp_cutoff_frequency: f32,
}

pub const EQUALIZERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EqualizerSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "LowShelfFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EqualizerSettings, low_shelf_frequency),
            },
            FieldInfoData {
                name: "LowShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EqualizerSettings, low_shelf_gain),
            },
            FieldInfoData {
                name: "HighShelfFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EqualizerSettings, high_shelf_frequency),
            },
            FieldInfoData {
                name: "HighShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EqualizerSettings, high_shelf_gain),
            },
            FieldInfoData {
                name: "HpCutoffFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(EqualizerSettings, hp_cutoff_frequency),
            },
        ],
    }),
    array_type: Some(EQUALIZERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EqualizerSettings {
    fn type_info() -> &'static TypeInfo {
        EQUALIZERSETTINGS_TYPE_INFO
    }
}


pub const EQUALIZERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EqualizerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EqualizerSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CompressorSettings {
    pub ratio: f32,
    pub threshold: f32,
    pub attack: f32,
    pub release: f32,
}

pub const COMPRESSORSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Ratio",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CompressorSettings, ratio),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CompressorSettings, threshold),
            },
            FieldInfoData {
                name: "Attack",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CompressorSettings, attack),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(CompressorSettings, release),
            },
        ],
    }),
    array_type: Some(COMPRESSORSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompressorSettings {
    fn type_info() -> &'static TypeInfo {
        COMPRESSORSETTINGS_TYPE_INFO
    }
}


pub const COMPRESSORSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CompressorSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MasterUnitSettings {
    pub name: String,
    pub equalizer: EqualizerSettings,
    pub compressor: CompressorSettings,
    pub master_volume: f32,
    pub master_lfe_gain: f32,
    pub master_dialog_gain: f32,
    pub reverb_volume: f32,
    pub main_mix_volume: f32,
    pub distortion_clip_level: f32,
    pub parallel_distortion_gain: f32,
    pub post_effects_gain: f32,
    pub fade_time: f32,
}

pub const MASTERUNITSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, name),
            },
            FieldInfoData {
                name: "Equalizer",
                flags: MemberInfoFlags::new(0),
                field_type: EQUALIZERSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, equalizer),
            },
            FieldInfoData {
                name: "Compressor",
                flags: MemberInfoFlags::new(0),
                field_type: COMPRESSORSETTINGS_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, compressor),
            },
            FieldInfoData {
                name: "MasterVolume",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, master_volume),
            },
            FieldInfoData {
                name: "MasterLfeGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, master_lfe_gain),
            },
            FieldInfoData {
                name: "MasterDialogGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, master_dialog_gain),
            },
            FieldInfoData {
                name: "ReverbVolume",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, reverb_volume),
            },
            FieldInfoData {
                name: "MainMixVolume",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, main_mix_volume),
            },
            FieldInfoData {
                name: "DistortionClipLevel",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, distortion_clip_level),
            },
            FieldInfoData {
                name: "ParallelDistortionGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, parallel_distortion_gain),
            },
            FieldInfoData {
                name: "PostEffectsGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, post_effects_gain),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitSettings, fade_time),
            },
        ],
    }),
    array_type: Some(MASTERUNITSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MasterUnitSettings {
    fn type_info() -> &'static TypeInfo {
        MASTERUNITSETTINGS_TYPE_INFO
    }
}


pub const MASTERUNITSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MasterUnitSettings-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HdrSetting {
    pub window_min_top: f32,
    pub window_min_bottom: f32,
    pub window_top_min_release_time: f32,
    pub window_top_max_release_time: f32,
    pub window_top_attack_time: f32,
    pub window_bottom_release_time: f32,
    pub window_top_release_time_curve: super::core::AudioCurve,
    pub discharge_factor: f32,
    pub max_allowed_energy: f32,
    pub window_bottom_attack_time: f32,
    pub window_size: f32,
    pub compress_factor: f32,
    pub headroom: f32,
    pub allowed_overshoot: f32,
}

pub const HDRSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HdrSetting",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WindowMinTop",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_min_top),
            },
            FieldInfoData {
                name: "WindowMinBottom",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_min_bottom),
            },
            FieldInfoData {
                name: "WindowTopMinReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_top_min_release_time),
            },
            FieldInfoData {
                name: "WindowTopMaxReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_top_max_release_time),
            },
            FieldInfoData {
                name: "WindowTopAttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_top_attack_time),
            },
            FieldInfoData {
                name: "WindowBottomReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_bottom_release_time),
            },
            FieldInfoData {
                name: "WindowTopReleaseTimeCurve",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOCURVE_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_top_release_time_curve),
            },
            FieldInfoData {
                name: "DischargeFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, discharge_factor),
            },
            FieldInfoData {
                name: "MaxAllowedEnergy",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, max_allowed_energy),
            },
            FieldInfoData {
                name: "WindowBottomAttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_bottom_attack_time),
            },
            FieldInfoData {
                name: "WindowSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, window_size),
            },
            FieldInfoData {
                name: "CompressFactor",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, compress_factor),
            },
            FieldInfoData {
                name: "Headroom",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, headroom),
            },
            FieldInfoData {
                name: "AllowedOvershoot",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(HdrSetting, allowed_overshoot),
            },
        ],
    }),
    array_type: Some(HDRSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HdrSetting {
    fn type_info() -> &'static TypeInfo {
        HDRSETTING_TYPE_INFO
    }
}


pub const HDRSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HdrSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HdrSetting-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundGraphData {
    pub info: SoundGraphInfo,
    pub input_parameters: Vec<AudioGraphParameter>,
    pub output_parameters: Vec<AudioGraphParameter>,
    pub input_events: Vec<AudioGraphEvent>,
    pub output_events: Vec<AudioGraphEvent>,
}

pub const SOUNDGRAPHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Info",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHINFO_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphData, info),
            },
            FieldInfoData {
                name: "InputParameters",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphData, input_parameters),
            },
            FieldInfoData {
                name: "OutputParameters",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphData, output_parameters),
            },
            FieldInfoData {
                name: "InputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHEVENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphData, input_events),
            },
            FieldInfoData {
                name: "OutputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: AUDIOGRAPHEVENT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphData, output_events),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphData {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHDATA_TYPE_INFO
    }
}


pub const SOUNDGRAPHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundBusData {
    pub channel_count: u8,
    pub bus_name: String,
    pub submix_plugin: SoundGraphPluginRef,
}

pub const SOUNDBUSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundBusData, channel_count),
            },
            FieldInfoData {
                name: "BusName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(SoundBusData, bus_name),
            },
            FieldInfoData {
                name: "SubmixPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(SoundBusData, submix_plugin),
            },
        ],
    }),
    array_type: Some(SOUNDBUSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundBusData {
    fn type_info() -> &'static TypeInfo {
        SOUNDBUSDATA_TYPE_INFO
    }
}


pub const SOUNDBUSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundBusData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundGraphInfo {
    pub voices: Vec<SoundGraphVoiceInfo>,
    pub linked_plugin_attributes: Vec<SoundGraphLinkedPluginAttribute>,
    pub connections: Vec<SoundGraphPluginConnection>,
    pub connection_params: Vec<SoundGraphPluginConnectionParam>,
    pub construct_params: Vec<SoundGraphPluginConstructParam>,
    pub plugins_param_count: u32,
    pub plugin_count: u32,
    pub dynamic_send_count: u32,
}

pub const SOUNDGRAPHINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Voices",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, voices),
            },
            FieldInfoData {
                name: "LinkedPluginAttributes",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, linked_plugin_attributes),
            },
            FieldInfoData {
                name: "Connections",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, connections),
            },
            FieldInfoData {
                name: "ConnectionParams",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, connection_params),
            },
            FieldInfoData {
                name: "ConstructParams",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, construct_params),
            },
            FieldInfoData {
                name: "PluginsParamCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, plugins_param_count),
            },
            FieldInfoData {
                name: "PluginCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, plugin_count),
            },
            FieldInfoData {
                name: "DynamicSendCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphInfo, dynamic_send_count),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphInfo {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHINFO_TYPE_INFO
    }
}


pub const SOUNDGRAPHINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundGraphVoiceInfo {
    pub plugins: Vec<SoundGraphPluginInfo>,
}

pub const SOUNDGRAPHVOICEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphVoiceInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphVoiceInfo, plugins),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphVoiceInfo {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHVOICEINFO_TYPE_INFO
    }
}


pub const SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphVoiceInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphVoiceInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundGraphLinkedPluginAttribute {
    pub unconnected_value: f32,
    pub value_index: u16,
    pub node_index_and_flags: u16,
    pub voice_index: u8,
    pub plugin_index: u8,
    pub attribute_index: u8,
}

pub const SOUNDGRAPHLINKEDPLUGINATTRIBUTE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphLinkedPluginAttribute",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "UnconnectedValue",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, unconnected_value),
            },
            FieldInfoData {
                name: "ValueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, value_index),
            },
            FieldInfoData {
                name: "NodeIndexAndFlags",
                flags: MemberInfoFlags::new(0),
                field_type: UINT16_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, node_index_and_flags),
            },
            FieldInfoData {
                name: "VoiceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, voice_index),
            },
            FieldInfoData {
                name: "PluginIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, plugin_index),
            },
            FieldInfoData {
                name: "AttributeIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, attribute_index),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphLinkedPluginAttribute {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHLINKEDPLUGINATTRIBUTE_TYPE_INFO
    }
}


pub const SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphLinkedPluginAttribute-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphLinkedPluginAttribute-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundGraphPluginInfo {
    pub id: u32,
    pub enable_attribute_read_mask: u32,
    pub connection_index: u8,
    pub output_channel_count: u8,
    pub construct_params_index: u8,
    pub construct_param_count: u8,
}

pub const SOUNDGRAPHPLUGININFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginInfo",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginInfo, id),
            },
            FieldInfoData {
                name: "EnableAttributeReadMask",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginInfo, enable_attribute_read_mask),
            },
            FieldInfoData {
                name: "ConnectionIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginInfo, connection_index),
            },
            FieldInfoData {
                name: "OutputChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginInfo, output_channel_count),
            },
            FieldInfoData {
                name: "ConstructParamsIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginInfo, construct_params_index),
            },
            FieldInfoData {
                name: "ConstructParamCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginInfo, construct_param_count),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphPluginInfo {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHPLUGININFO_TYPE_INFO
    }
}


pub const SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginInfo-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundGraphPluginRef {
    pub is_valid: bool,
    pub voice_index: u8,
    pub plugin_index: u8,
}

pub const SOUNDGRAPHPLUGINREF_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginRef",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "IsValid",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginRef, is_valid),
            },
            FieldInfoData {
                name: "VoiceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginRef, voice_index),
            },
            FieldInfoData {
                name: "PluginIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginRef, plugin_index),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundGraphPluginRef {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHPLUGINREF_TYPE_INFO
    }
}


pub const SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginRef-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginRef-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SoundGraphPluginConstructParam {
    pub index: u8,
    pub value: f32,
}

pub const SOUNDGRAPHPLUGINCONSTRUCTPARAM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConstructParam",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConstructParam, index),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConstructParam, value),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphPluginConstructParam {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONSTRUCTPARAM_TYPE_INFO
    }
}


pub const SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConstructParam-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConstructParam-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundGraphPluginConnection {
    pub context: AudioGraphNodeData,
    pub voice_index: u8,
    pub plugin_index: u8,
    pub signal_index_and_connection_info: u8,
    pub connection_param_base_index: u8,
}

pub const SOUNDGRAPHPLUGINCONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnection",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnection, context),
            },
            FieldInfoData {
                name: "VoiceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnection, voice_index),
            },
            FieldInfoData {
                name: "PluginIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnection, plugin_index),
            },
            FieldInfoData {
                name: "SignalIndexAndConnectionInfo",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnection, signal_index_and_connection_info),
            },
            FieldInfoData {
                name: "ConnectionParamBaseIndex",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnection, connection_param_base_index),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphPluginConnection {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONNECTION_TYPE_INFO
    }
}


pub const SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConnection-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SoundGraphPluginConnectionType {
    #[default]
    SoundGraphPluginConnectionType_Unconnected = 0,
    SoundGraphPluginConnectionType_Signal = 1,
    SoundGraphPluginConnectionType_Bus = 2,
    SoundGraphPluginConnectionType_Dynamic = 3,
}

pub const SOUNDGRAPHPLUGINCONNECTIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDGRAPHPLUGINCONNECTIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundGraphPluginConnectionType {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONNECTIONTYPE_TYPE_INFO
    }
}


pub const SOUNDGRAPHPLUGINCONNECTIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConnectionType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SoundGraphPluginConnectionParam {
    pub index: u8,
    pub value: i32,
}

pub const SOUNDGRAPHPLUGINCONNECTIONPARAM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionParam",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnectionParam, index),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SoundGraphPluginConnectionParam, value),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphPluginConnectionParam {
    fn type_info() -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONNECTIONPARAM_TYPE_INFO
    }
}


pub const SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionParam-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConnectionParam-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum FadeCurveType {
    #[default]
    FadeCurveType_LinearAmplitude = 0,
    FadeCurveType_SineAmplitude = 1,
    FadeCurveType_LinearDecibel = 2,
    FadeCurveType_EqualPower = 3,
}

pub const FADECURVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeCurveType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FADECURVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FadeCurveType {
    fn type_info() -> &'static TypeInfo {
        FADECURVETYPE_TYPE_INFO
    }
}


pub const FADECURVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeCurveType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FadeCurveType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PointEnvelope {
    pub points: Vec<PointEnvelopePoint>,
}

pub const POINTENVELOPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelope",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: POINTENVELOPEPOINT_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(PointEnvelope, points),
            },
        ],
    }),
    array_type: Some(POINTENVELOPE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PointEnvelope {
    fn type_info() -> &'static TypeInfo {
        POINTENVELOPE_TYPE_INFO
    }
}


pub const POINTENVELOPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelope-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PointEnvelope-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PointEnvelopePoint {
    pub x: f32,
    pub y: f32,
}

pub const POINTENVELOPEPOINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelopePoint",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PointEnvelopePoint, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(PointEnvelopePoint, y),
            },
        ],
    }),
    array_type: Some(POINTENVELOPEPOINT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PointEnvelopePoint {
    fn type_info() -> &'static TypeInfo {
        POINTENVELOPEPOINT_TYPE_INFO
    }
}


pub const POINTENVELOPEPOINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelopePoint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PointEnvelopePoint-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct AudioLanguage {
    pub name: String,
    pub language_mapping: super::core::LanguageFormat,
}

pub const AUDIOLANGUAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguage",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguage, name),
            },
            FieldInfoData {
                name: "LanguageMapping",
                flags: MemberInfoFlags::new(0),
                field_type: LANGUAGEFORMAT_TYPE_INFO,
                rust_offset: offset_of!(AudioLanguage, language_mapping),
            },
        ],
    }),
    array_type: Some(AUDIOLANGUAGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioLanguage {
    fn type_info() -> &'static TypeInfo {
        AUDIOLANGUAGE_TYPE_INFO
    }
}


pub const AUDIOLANGUAGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguage-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioLanguage-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum AudioSystemSpeakerSetup {
    #[default]
    FiveDotOne = 6,
    SevenDotOne = 8,
}

pub const AUDIOSYSTEMSPEAKERSETUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemSpeakerSetup",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(AUDIOSYSTEMSPEAKERSETUP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AudioSystemSpeakerSetup {
    fn type_info() -> &'static TypeInfo {
        AUDIOSYSTEMSPEAKERSETUP_TYPE_INFO
    }
}


pub const AUDIOSYSTEMSPEAKERSETUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemSpeakerSetup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioSystemSpeakerSetup-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BeatDetectNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub filter_response_time: f32,
    pub zero_run_detect_time: f32,
    pub beat_detect_frame_size: BeatDetectFrameSize,
    pub causality: BeatDetectCausality,
    pub maximum_beats_per_minute: f32,
    pub update_lookahead: f32,
    pub clicks_per_beat: i32,
    pub click: AudioGraphNodePort,
    pub beats_per_minute: AudioGraphNodePort,
    pub beat_time: AudioGraphNodePort,
    pub beat_confidence: AudioGraphNodePort,
    pub meter: AudioGraphNodePort,
    pub meter_confidence: AudioGraphNodePort,
    pub beat_detect_plugin: SoundGraphPluginRef,
}

pub const BEATDETECTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, out),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, stop),
            },
            FieldInfoData {
                name: "FilterResponseTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, filter_response_time),
            },
            FieldInfoData {
                name: "ZeroRunDetectTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, zero_run_detect_time),
            },
            FieldInfoData {
                name: "BeatDetectFrameSize",
                flags: MemberInfoFlags::new(0),
                field_type: BEATDETECTFRAMESIZE_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, beat_detect_frame_size),
            },
            FieldInfoData {
                name: "Causality",
                flags: MemberInfoFlags::new(0),
                field_type: BEATDETECTCAUSALITY_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, causality),
            },
            FieldInfoData {
                name: "MaximumBeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, maximum_beats_per_minute),
            },
            FieldInfoData {
                name: "UpdateLookahead",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, update_lookahead),
            },
            FieldInfoData {
                name: "ClicksPerBeat",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, clicks_per_beat),
            },
            FieldInfoData {
                name: "Click",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, click),
            },
            FieldInfoData {
                name: "BeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, beats_per_minute),
            },
            FieldInfoData {
                name: "BeatTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, beat_time),
            },
            FieldInfoData {
                name: "BeatConfidence",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, beat_confidence),
            },
            FieldInfoData {
                name: "Meter",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, meter),
            },
            FieldInfoData {
                name: "MeterConfidence",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, meter_confidence),
            },
            FieldInfoData {
                name: "BeatDetectPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(BeatDetectNodeData, beat_detect_plugin),
            },
        ],
    }),
    array_type: Some(BEATDETECTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BeatDetectNodeData {
    fn type_info() -> &'static TypeInfo {
        BEATDETECTNODEDATA_TYPE_INFO
    }
}


pub const BEATDETECTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BeatDetectNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum BeatDetectCausality {
    #[default]
    BeatDetectCausality_NonCausal = 0,
    BeatDetectCausality_Causal = 1,
}

pub const BEATDETECTCAUSALITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectCausality",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(BEATDETECTCAUSALITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BeatDetectCausality {
    fn type_info() -> &'static TypeInfo {
        BEATDETECTCAUSALITY_TYPE_INFO
    }
}


pub const BEATDETECTCAUSALITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectCausality-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BeatDetectCausality-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum BeatDetectFrameSize {
    #[default]
    BeatDetectFrameSize_256 = 0,
    BeatDetectFrameSize_512 = 1,
}

pub const BEATDETECTFRAMESIZE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectFrameSize",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(BEATDETECTFRAMESIZE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BeatDetectFrameSize {
    fn type_info() -> &'static TypeInfo {
        BEATDETECTFRAMESIZE_TYPE_INFO
    }
}


pub const BEATDETECTFRAMESIZE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectFrameSize-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BeatDetectFrameSize-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ModelReverbNodeData {
    pub max_space_size: f32,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub reverb_time: AudioGraphNodePort,
    pub space_size: AudioGraphNodePort,
    pub brightness: AudioGraphNodePort,
    pub reverb_plugin: SoundGraphPluginRef,
}

pub const MODELREVERBNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelReverbNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MaxSpaceSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, max_space_size),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, out),
            },
            FieldInfoData {
                name: "ReverbTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, reverb_time),
            },
            FieldInfoData {
                name: "SpaceSize",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, space_size),
            },
            FieldInfoData {
                name: "Brightness",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, brightness),
            },
            FieldInfoData {
                name: "ReverbPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ModelReverbNodeData, reverb_plugin),
            },
        ],
    }),
    array_type: Some(MODELREVERBNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ModelReverbNodeData {
    fn type_info() -> &'static TypeInfo {
        MODELREVERBNODEDATA_TYPE_INFO
    }
}


pub const MODELREVERBNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelReverbNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ModelReverbNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ActivateMixerNodeData {
    pub mixer: MixerAsset,
    pub activate: AudioGraphNodePort,
    pub deactivate: AudioGraphNodePort,
}

pub const ACTIVATEMIXERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActivateMixerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: MIXERASSET_TYPE_INFO,
                rust_offset: offset_of!(ActivateMixerNodeData, mixer),
            },
            FieldInfoData {
                name: "Activate",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ActivateMixerNodeData, activate),
            },
            FieldInfoData {
                name: "Deactivate",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ActivateMixerNodeData, deactivate),
            },
        ],
    }),
    array_type: Some(ACTIVATEMIXERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ActivateMixerNodeData {
    fn type_info() -> &'static TypeInfo {
        ACTIVATEMIXERNODEDATA_TYPE_INFO
    }
}


pub const ACTIVATEMIXERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActivateMixerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ActivateMixerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VuMeterNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub front_left: AudioGraphNodePort,
    pub center: AudioGraphNodePort,
    pub front_right: AudioGraphNodePort,
    pub rear_left: AudioGraphNodePort,
    pub rear_right: AudioGraphNodePort,
    pub lfe: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub mode: VuMeterMode,
    pub efficiency: i32,
    pub render_v_u_meter_bars: bool,
    pub v_u_meter_x_pos: i32,
    pub v_u_meter_y_pos: i32,
}

pub const VUMETERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, out),
            },
            FieldInfoData {
                name: "FrontLeft",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, front_left),
            },
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, center),
            },
            FieldInfoData {
                name: "FrontRight",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, front_right),
            },
            FieldInfoData {
                name: "RearLeft",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, rear_left),
            },
            FieldInfoData {
                name: "RearRight",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, rear_right),
            },
            FieldInfoData {
                name: "Lfe",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, lfe),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, plugin),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: VUMETERMODE_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, mode),
            },
            FieldInfoData {
                name: "Efficiency",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, efficiency),
            },
            FieldInfoData {
                name: "RenderVUMeterBars",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, render_v_u_meter_bars),
            },
            FieldInfoData {
                name: "VUMeterXPos",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, v_u_meter_x_pos),
            },
            FieldInfoData {
                name: "VUMeterYPos",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(VuMeterNodeData, v_u_meter_y_pos),
            },
        ],
    }),
    array_type: Some(VUMETERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VuMeterNodeData {
    fn type_info() -> &'static TypeInfo {
        VUMETERNODEDATA_TYPE_INFO
    }
}


pub const VUMETERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VuMeterNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum VuMeterMode {
    #[default]
    VuMeterMode_Rms = 0,
    VuMeterMode_Peak = 1,
    VuMeterMode_LargestPeak = 2,
}

pub const VUMETERMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VUMETERMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VuMeterMode {
    fn type_info() -> &'static TypeInfo {
        VUMETERMODE_TYPE_INFO
    }
}


pub const VUMETERMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VuMeterMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VibratoNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub max_modulation_depth: f32,
    pub modulation_depth: AudioGraphNodePort,
    pub modulation_frequency: AudioGraphNodePort,
}

pub const VIBRATONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VibratoNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VibratoNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VibratoNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(VibratoNodeData, plugin),
            },
            FieldInfoData {
                name: "MaxModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(VibratoNodeData, max_modulation_depth),
            },
            FieldInfoData {
                name: "ModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VibratoNodeData, modulation_depth),
            },
            FieldInfoData {
                name: "ModulationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VibratoNodeData, modulation_frequency),
            },
        ],
    }),
    array_type: Some(VIBRATONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VibratoNodeData {
    fn type_info() -> &'static TypeInfo {
        VIBRATONODEDATA_TYPE_INFO
    }
}


pub const VIBRATONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VibratoNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VibratoNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WaveSwitcherNodeConfigData {
    pub waves: Vec<SoundWaveAssetBase>,
    pub default_index: f32,
}

pub const WAVESWITCHERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Waves",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeConfigData, waves),
            },
            FieldInfoData {
                name: "DefaultIndex",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeConfigData, default_index),
            },
        ],
    }),
    array_type: Some(WAVESWITCHERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveSwitcherNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        WAVESWITCHERNODECONFIGDATA_TYPE_INFO
    }
}


pub const WAVESWITCHERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveSwitcherNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WaveSwitcherNodeData {
    pub index: AudioGraphNodePort,
    pub advance: AudioGraphNodePort,
    pub wave: AudioGraphNodePort,
    pub index_changed: AudioGraphNodePort,
    pub waves: Vec<SoundWaveAssetBase>,
    pub default_index: f32,
    pub wrap_index: bool,
    pub is_random: bool,
    pub random_start_index: bool,
}

pub const WAVESWITCHERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, index),
            },
            FieldInfoData {
                name: "Advance",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, advance),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, wave),
            },
            FieldInfoData {
                name: "IndexChanged",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, index_changed),
            },
            FieldInfoData {
                name: "Waves",
                flags: MemberInfoFlags::new(144),
                field_type: SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, waves),
            },
            FieldInfoData {
                name: "DefaultIndex",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, default_index),
            },
            FieldInfoData {
                name: "WrapIndex",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, wrap_index),
            },
            FieldInfoData {
                name: "IsRandom",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, is_random),
            },
            FieldInfoData {
                name: "RandomStartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(WaveSwitcherNodeData, random_start_index),
            },
        ],
    }),
    array_type: Some(WAVESWITCHERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveSwitcherNodeData {
    fn type_info() -> &'static TypeInfo {
        WAVESWITCHERNODEDATA_TYPE_INFO
    }
}


pub const WAVESWITCHERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveSwitcherNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WaveQueryNodeData {
    pub select: AudioGraphNodePort,
    pub selection_parameters: Vec<WaveQueryNodeParameterEntry>,
    pub selection: AudioGraphNodePort,
    pub selected: AudioGraphNodePort,
    pub selection_failed: AudioGraphNodePort,
    pub wave_references: Vec<WaveQueryWaveAssetReference>,
}

pub const WAVEQUERYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Select",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeData, select),
            },
            FieldInfoData {
                name: "SelectionParameters",
                flags: MemberInfoFlags::new(144),
                field_type: WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeData, selection_parameters),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeData, selection),
            },
            FieldInfoData {
                name: "Selected",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeData, selected),
            },
            FieldInfoData {
                name: "SelectionFailed",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeData, selection_failed),
            },
            FieldInfoData {
                name: "WaveReferences",
                flags: MemberInfoFlags::new(144),
                field_type: WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeData, wave_references),
            },
        ],
    }),
    array_type: Some(WAVEQUERYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveQueryNodeData {
    fn type_info() -> &'static TypeInfo {
        WAVEQUERYNODEDATA_TYPE_INFO
    }
}


pub const WAVEQUERYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WaveQueryNodeParameterEntry {
    pub selection_param: AudioGraphNodePort,
    pub parameter_name_hash: u32,
}

pub const WAVEQUERYNODEPARAMETERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SelectionParam",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeParameterEntry, selection_param),
            },
            FieldInfoData {
                name: "ParameterNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryNodeParameterEntry, parameter_name_hash),
            },
        ],
    }),
    array_type: Some(WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveQueryNodeParameterEntry {
    fn type_info() -> &'static TypeInfo {
        WAVEQUERYNODEPARAMETERENTRY_TYPE_INFO
    }
}


pub const WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryNodeParameterEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct WaveQueryWaveAssetReference {
    pub wave_asset: NewWaveAsset,
    pub selection_group: NewWaveSelectionGroup,
}

pub const WAVEQUERYWAVEASSETREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryWaveAssetReference",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "WaveAsset",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVEASSET_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryWaveAssetReference, wave_asset),
            },
            FieldInfoData {
                name: "SelectionGroup",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVESELECTIONGROUP_TYPE_INFO,
                rust_offset: offset_of!(WaveQueryWaveAssetReference, selection_group),
            },
        ],
    }),
    array_type: Some(WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveQueryWaveAssetReference {
    fn type_info() -> &'static TypeInfo {
        WAVEQUERYWAVEASSETREFERENCE_TYPE_INFO
    }
}


pub const WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryWaveAssetReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryWaveAssetReference-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum WaveQueryNodeParameterEntryType {
    #[default]
    WaveQueryNodeParameterEntryType_Int = 0,
    WaveQueryNodeParameterEntryType_Float = 1,
    WaveQueryNodeParameterEntryType_Bool = 2,
}

pub const WAVEQUERYNODEPARAMETERENTRYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntryType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(WAVEQUERYNODEPARAMETERENTRYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WaveQueryNodeParameterEntryType {
    fn type_info() -> &'static TypeInfo {
        WAVEQUERYNODEPARAMETERENTRYTYPE_TYPE_INFO
    }
}


pub const WAVEQUERYNODEPARAMETERENTRYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntryType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryNodeParameterEntryType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum WaveQueryConstEnum {
    #[default]
    WaveQueryMaxNumSelectionParams = 20,
}

pub const WAVEQUERYCONSTENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryConstEnum",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(WAVEQUERYCONSTENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WaveQueryConstEnum {
    fn type_info() -> &'static TypeInfo {
        WAVEQUERYCONSTENUM_TYPE_INFO
    }
}


pub const WAVEQUERYCONSTENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryConstEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryConstEnum-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct VariationSelectionObserverNodeData {
    pub selection: AudioGraphNodePort,
    pub select: AudioGraphNodePort,
    pub num_variations_in_selection: AudioGraphNodePort,
    pub num_variations_validated: AudioGraphNodePort,
    pub num_variations_loaded: AudioGraphNodePort,
    pub new_wave_asset: NewWaveAsset,
    pub variation_ids: Vec<u32>,
}

pub const VARIATIONSELECTIONOBSERVERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariationSelectionObserverNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, selection),
            },
            FieldInfoData {
                name: "Select",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, select),
            },
            FieldInfoData {
                name: "NumVariationsInSelection",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, num_variations_in_selection),
            },
            FieldInfoData {
                name: "NumVariationsValidated",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, num_variations_validated),
            },
            FieldInfoData {
                name: "NumVariationsLoaded",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, num_variations_loaded),
            },
            FieldInfoData {
                name: "NewWaveAsset",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVEASSET_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, new_wave_asset),
            },
            FieldInfoData {
                name: "VariationIds",
                flags: MemberInfoFlags::new(144),
                field_type: UINT32_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(VariationSelectionObserverNodeData, variation_ids),
            },
        ],
    }),
    array_type: Some(VARIATIONSELECTIONOBSERVERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VariationSelectionObserverNodeData {
    fn type_info() -> &'static TypeInfo {
        VARIATIONSELECTIONOBSERVERNODEDATA_TYPE_INFO
    }
}


pub const VARIATIONSELECTIONOBSERVERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariationSelectionObserverNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VariationSelectionObserverNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct UserMusicControllerNodeData {
    pub r#override: AudioGraphNodePort,
    pub restore: AudioGraphNodePort,
    pub restore_on_deactivated: bool,
}

pub const USERMUSICCONTROLLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicControllerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Override",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(UserMusicControllerNodeData, r#override),
            },
            FieldInfoData {
                name: "Restore",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(UserMusicControllerNodeData, restore),
            },
            FieldInfoData {
                name: "RestoreOnDeactivated",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(UserMusicControllerNodeData, restore_on_deactivated),
            },
        ],
    }),
    array_type: Some(USERMUSICCONTROLLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UserMusicControllerNodeData {
    fn type_info() -> &'static TypeInfo {
        USERMUSICCONTROLLERNODEDATA_TYPE_INFO
    }
}


pub const USERMUSICCONTROLLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicControllerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("UserMusicControllerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct UserMusicArbiterNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const USERMUSICARBITERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicArbiterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(UserMusicArbiterNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(UserMusicArbiterNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(UserMusicArbiterNodeData, plugin),
            },
        ],
    }),
    array_type: Some(USERMUSICARBITERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UserMusicArbiterNodeData {
    fn type_info() -> &'static TypeInfo {
        USERMUSICARBITERNODEDATA_TYPE_INFO
    }
}


pub const USERMUSICARBITERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicArbiterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("UserMusicArbiterNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct TimeStretchNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub window_size: f32,
    pub multi_channel_mode: TimeStretchMultiChannelMode,
    pub efficiency: TimeStretchEfficiency,
    pub stretch_ratio: AudioGraphNodePort,
}

pub const TIMESTRETCHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, plugin),
            },
            FieldInfoData {
                name: "WindowSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, window_size),
            },
            FieldInfoData {
                name: "MultiChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: TIMESTRETCHMULTICHANNELMODE_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, multi_channel_mode),
            },
            FieldInfoData {
                name: "Efficiency",
                flags: MemberInfoFlags::new(0),
                field_type: TIMESTRETCHEFFICIENCY_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, efficiency),
            },
            FieldInfoData {
                name: "StretchRatio",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(TimeStretchNodeData, stretch_ratio),
            },
        ],
    }),
    array_type: Some(TIMESTRETCHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TimeStretchNodeData {
    fn type_info() -> &'static TypeInfo {
        TIMESTRETCHNODEDATA_TYPE_INFO
    }
}


pub const TIMESTRETCHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimeStretchNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TimeStretchEfficiency {
    #[default]
    TimeStretchEfficiency_1 = 1,
    TimeStretchEfficiency_2 = 2,
    TimeStretchEfficiency_3 = 4,
    TimeStretchEfficiency_4 = 8,
    TimeStretchEfficiency_5 = 12,
    TimeStretchEfficiency_6 = 16,
    TimeStretchEfficiency_7 = 20,
    TimeStretchEfficiency_8 = 24,
    TimeStretchEfficiency_9 = 28,
    TimeStretchEfficiency_10 = 32,
}

pub const TIMESTRETCHEFFICIENCY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchEfficiency",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMESTRETCHEFFICIENCY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeStretchEfficiency {
    fn type_info() -> &'static TypeInfo {
        TIMESTRETCHEFFICIENCY_TYPE_INFO
    }
}


pub const TIMESTRETCHEFFICIENCY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchEfficiency-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimeStretchEfficiency-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum TimeStretchMultiChannelMode {
    #[default]
    TimeStretchMultiChannelMode_IndependentChannels = 0,
    TimeStretchMultiChannelMode_CombinedChannels = 1,
}

pub const TIMESTRETCHMULTICHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchMultiChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMESTRETCHMULTICHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeStretchMultiChannelMode {
    fn type_info() -> &'static TypeInfo {
        TIMESTRETCHMULTICHANNELMODE_TYPE_INFO
    }
}


pub const TIMESTRETCHMULTICHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchMultiChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimeStretchMultiChannelMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SamplerNodeConfigData {
    pub amplitude: f32,
    pub delay: f32,
    pub offset: f32,
    pub pitch: f32,
    pub wave: SoundWaveAssetBase,
}

pub const SAMPLERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeConfigData, amplitude),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeConfigData, delay),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeConfigData, offset),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeConfigData, pitch),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeConfigData, wave),
            },
        ],
    }),
    array_type: Some(SAMPLERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SamplerNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        SAMPLERNODECONFIGDATA_TYPE_INFO
    }
}


pub const SAMPLERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SamplerNodeData {
    pub external_wave: AudioGraphNodePort,
    pub variation: AudioGraphNodePort,
    pub selection: AudioGraphNodePort,
    pub offset: AudioGraphNodePort,
    pub delay: AudioGraphNodePort,
    pub pitch: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub enable_step: AudioGraphNodePort,
    pub shuffle_segments: AudioGraphNodePort,
    pub enable_subtitles: AudioGraphNodePort,
    pub buffer: AudioGraphNodePort,
    pub trigger: AudioGraphNodePort,
    pub release: AudioGraphNodePort,
    pub step: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub finished: AudioGraphNodePort,
    pub buffered: AudioGraphNodePort,
    pub position: AudioGraphNodePort,
    pub wave: SoundWaveAssetBase,
    pub looping: bool,
    pub instant_release: bool,
    pub offset_mode: SamplerOffsetMode,
    pub lead_out: u8,
    pub plugins: Vec<SamplerPlugins>,
    pub pitch_source: OutputNodeData,
    pub version: SamplerNodeVersion,
    pub sampler_node_debug: SamplerNodeDebugData,
    pub position_mode: SamplerPositionMode,
}

pub const SAMPLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ExternalWave",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, external_wave),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, variation),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, selection),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, offset),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, delay),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, pitch),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, amplitude),
            },
            FieldInfoData {
                name: "EnableStep",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, enable_step),
            },
            FieldInfoData {
                name: "ShuffleSegments",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, shuffle_segments),
            },
            FieldInfoData {
                name: "EnableSubtitles",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, enable_subtitles),
            },
            FieldInfoData {
                name: "Buffer",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, buffer),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, trigger),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, release),
            },
            FieldInfoData {
                name: "Step",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, step),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, output),
            },
            FieldInfoData {
                name: "Finished",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, finished),
            },
            FieldInfoData {
                name: "Buffered",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, buffered),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, position),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, wave),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, looping),
            },
            FieldInfoData {
                name: "InstantRelease",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, instant_release),
            },
            FieldInfoData {
                name: "OffsetMode",
                flags: MemberInfoFlags::new(0),
                field_type: SAMPLEROFFSETMODE_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, offset_mode),
            },
            FieldInfoData {
                name: "LeadOut",
                flags: MemberInfoFlags::new(0),
                field_type: UINT8_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, lead_out),
            },
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: SAMPLERPLUGINS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, plugins),
            },
            FieldInfoData {
                name: "PitchSource",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, pitch_source),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: SAMPLERNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, version),
            },
            FieldInfoData {
                name: "SamplerNodeDebug",
                flags: MemberInfoFlags::new(0),
                field_type: SAMPLERNODEDEBUGDATA_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, sampler_node_debug),
            },
            FieldInfoData {
                name: "PositionMode",
                flags: MemberInfoFlags::new(0),
                field_type: SAMPLERPOSITIONMODE_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeData, position_mode),
            },
        ],
    }),
    array_type: Some(SAMPLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SamplerNodeData {
    fn type_info() -> &'static TypeInfo {
        SAMPLERNODEDATA_TYPE_INFO
    }
}


pub const SAMPLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SamplerNodeDebugData {
    pub only_debug_if_playing: bool,
    pub enable_debug: bool,
    pub debug_input_connections: bool,
    pub debug_output_connections: bool,
    pub debug_text_x_pos: i32,
    pub debug_text_y_pos: i32,
    pub event_display_time: f32,
    pub sampler_debug_info_color: super::core::Vec3,
    pub properties_debug_info_color: super::core::Vec3,
    pub events_debug_info_color: super::core::Vec3,
    pub external_wave_debug_info_color: super::core::Vec3,
    pub selection_debug_info_color: super::core::Vec3,
    pub mute_sampler: bool,
}

pub const SAMPLERNODEDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeDebugData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "OnlyDebugIfPlaying",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, only_debug_if_playing),
            },
            FieldInfoData {
                name: "EnableDebug",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, enable_debug),
            },
            FieldInfoData {
                name: "DebugInputConnections",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, debug_input_connections),
            },
            FieldInfoData {
                name: "DebugOutputConnections",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, debug_output_connections),
            },
            FieldInfoData {
                name: "DebugTextXPos",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, debug_text_x_pos),
            },
            FieldInfoData {
                name: "DebugTextYPos",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, debug_text_y_pos),
            },
            FieldInfoData {
                name: "EventDisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, event_display_time),
            },
            FieldInfoData {
                name: "SamplerDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, sampler_debug_info_color),
            },
            FieldInfoData {
                name: "PropertiesDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, properties_debug_info_color),
            },
            FieldInfoData {
                name: "EventsDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, events_debug_info_color),
            },
            FieldInfoData {
                name: "ExternalWaveDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, external_wave_debug_info_color),
            },
            FieldInfoData {
                name: "SelectionDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, selection_debug_info_color),
            },
            FieldInfoData {
                name: "MuteSampler",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(SamplerNodeDebugData, mute_sampler),
            },
        ],
    }),
    array_type: Some(SAMPLERNODEDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SamplerNodeDebugData {
    fn type_info() -> &'static TypeInfo {
        SAMPLERNODEDEBUGDATA_TYPE_INFO
    }
}


pub const SAMPLERNODEDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeDebugData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SamplerPositionMode {
    #[default]
    SamplerPositionMode_Normal = 0,
    SamplerPositionMode_Wrap = 1,
    SamplerPositionMode_Countdown = 2,
    SamplerPositionMode_Relative = 3,
}

pub const SAMPLERPOSITIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPositionMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLERPOSITIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerPositionMode {
    fn type_info() -> &'static TypeInfo {
        SAMPLERPOSITIONMODE_TYPE_INFO
    }
}


pub const SAMPLERPOSITIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPositionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerPositionMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SamplerOffsetMode {
    #[default]
    SamplerOffsetMode_Absolute = 0,
    SamplerOffsetMode_Relative = 1,
    SamplerOffsetMode_RelativeMod = 2,
}

pub const SAMPLEROFFSETMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerOffsetMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLEROFFSETMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerOffsetMode {
    fn type_info() -> &'static TypeInfo {
        SAMPLEROFFSETMODE_TYPE_INFO
    }
}


pub const SAMPLEROFFSETMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerOffsetMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerOffsetMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SamplerLeadOut {
    #[default]
    SamplerLeadOut_None = 0,
    SamplerLeadOut_Normal = 1,
    SamplerLeadOut_Relative = 2,
}

pub const SAMPLERLEADOUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerLeadOut",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLERLEADOUT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerLeadOut {
    fn type_info() -> &'static TypeInfo {
        SAMPLERLEADOUT_TYPE_INFO
    }
}


pub const SAMPLERLEADOUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerLeadOut-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerLeadOut-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct SamplerPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub resample: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
}

pub const SAMPLERPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(SamplerPlugins, snd_player),
            },
            FieldInfoData {
                name: "Resample",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(SamplerPlugins, resample),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(SamplerPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(SamplerPlugins, gain),
            },
        ],
    }),
    array_type: Some(SAMPLERPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerPlugins {
    fn type_info() -> &'static TypeInfo {
        SAMPLERPLUGINS_TYPE_INFO
    }
}


pub const SAMPLERPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerPlugins-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum SamplerNodeVersion {
    #[default]
    SamplerNodeVersion_2010_2 = 0,
    SamplerNodeVersion_2013_2 = 1,
    SamplerNodeVersion_2016_1 = 2,
}

pub const SAMPLERNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLERNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerNodeVersion {
    fn type_info() -> &'static TypeInfo {
        SAMPLERNODEVERSION_TYPE_INFO
    }
}


pub const SAMPLERNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct RouteNodeData {
    pub r#in: AudioGraphNodePort,
    pub routes: Vec<RouteEntry>,
}

pub const ROUTENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RouteNodeData, r#in),
            },
            FieldInfoData {
                name: "Routes",
                flags: MemberInfoFlags::new(144),
                field_type: ROUTEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(RouteNodeData, routes),
            },
        ],
    }),
    array_type: Some(ROUTENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RouteNodeData {
    fn type_info() -> &'static TypeInfo {
        ROUTENODEDATA_TYPE_INFO
    }
}


pub const ROUTENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RouteNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct RouteEntry {
    pub output: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const ROUTEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RouteEntry, output),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(RouteEntry, amplitude),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(RouteEntry, plugin),
            },
        ],
    }),
    array_type: Some(ROUTEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RouteEntry {
    fn type_info() -> &'static TypeInfo {
        ROUTEENTRY_TYPE_INFO
    }
}


pub const ROUTEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RouteEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum RouteChannel {
    #[default]
    RouteChannel_0 = 0,
    RouteChannel_1 = 1,
    RouteChannel_2 = 2,
    RouteChannel_3 = 3,
    RouteChannel_4 = 4,
    RouteChannel_5 = 5,
    RouteChannel_6 = 6,
    RouteChannel_7 = 7,
    RouteChannel_8 = 8,
    RouteChannel_9 = 9,
    RouteChannel_10 = 10,
    RouteChannel_11 = 11,
    RouteChannel_12 = 12,
    RouteChannel_13 = 13,
    RouteChannel_14 = 14,
    RouteChannel_15 = 15,
    RouteChannel_16 = 16,
    RouteChannel_17 = 17,
    RouteChannel_18 = 18,
    RouteChannel_19 = 19,
    RouteChannel_21 = 20,
    RouteChannel_22 = 21,
    RouteChannel_23 = 22,
    RouteChannel_24 = 23,
    RouteChannel_25 = 24,
    RouteChannel_26 = 25,
    RouteChannel_27 = 26,
    RouteChannel_28 = 27,
    RouteChannel_29 = 28,
    RouteChannel_30 = 29,
    RouteChannel_31 = 30,
    RouteChannel_32 = 31,
    RouteChannel_33 = 32,
    RouteChannel_34 = 33,
    RouteChannel_35 = 34,
    RouteChannel_36 = 35,
    RouteChannel_37 = 36,
    RouteChannel_38 = 37,
    RouteChannel_39 = 38,
    RouteChannel_40 = 39,
    RouteChannel_41 = 40,
    RouteChannel_42 = 41,
    RouteChannel_43 = 42,
    RouteChannel_44 = 43,
    RouteChannel_45 = 44,
    RouteChannel_46 = 45,
    RouteChannel_47 = 46,
    RouteChannel_48 = 47,
    RouteChannel_49 = 48,
    RouteChannel_50 = 49,
    RouteChannel_51 = 50,
    RouteChannel_52 = 51,
    RouteChannel_53 = 52,
    RouteChannel_54 = 53,
    RouteChannel_55 = 54,
    RouteChannel_56 = 55,
    RouteChannel_57 = 56,
    RouteChannel_58 = 57,
    RouteChannel_59 = 58,
    RouteChannel_60 = 59,
    RouteChannel_61 = 60,
    RouteChannel_62 = 61,
    RouteChannel_63 = 62,
}

pub const ROUTECHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteChannel",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(ROUTECHANNEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RouteChannel {
    fn type_info() -> &'static TypeInfo {
        ROUTECHANNEL_TYPE_INFO
    }
}


pub const ROUTECHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteChannel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RouteChannel-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct IrReverbControllerNodeData {
    pub reverb0: AudioGraphNodePort,
    pub amplitude0: AudioGraphNodePort,
    pub reverb1: AudioGraphNodePort,
    pub amplitude1: AudioGraphNodePort,
    pub normalize_gain: bool,
}

pub const IRREVERBCONTROLLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbControllerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Reverb0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbControllerNodeData, reverb0),
            },
            FieldInfoData {
                name: "Amplitude0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbControllerNodeData, amplitude0),
            },
            FieldInfoData {
                name: "Reverb1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbControllerNodeData, reverb1),
            },
            FieldInfoData {
                name: "Amplitude1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbControllerNodeData, amplitude1),
            },
            FieldInfoData {
                name: "NormalizeGain",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(IrReverbControllerNodeData, normalize_gain),
            },
        ],
    }),
    array_type: Some(IRREVERBCONTROLLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IrReverbControllerNodeData {
    fn type_info() -> &'static TypeInfo {
        IRREVERBCONTROLLERNODEDATA_TYPE_INFO
    }
}


pub const IRREVERBCONTROLLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbControllerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbControllerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct IrReverbNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub reverb0: AudioGraphNodePort,
    pub amplitude0: AudioGraphNodePort,
    pub envelope_type0: AudioGraphNodePort,
    pub envelope_start_level0: AudioGraphNodePort,
    pub envelope_length0: AudioGraphNodePort,
    pub reverb1: AudioGraphNodePort,
    pub amplitude1: AudioGraphNodePort,
    pub envelope_type1: AudioGraphNodePort,
    pub envelope_start_level1: AudioGraphNodePort,
    pub envelope_length1: AudioGraphNodePort,
    pub max_reverb_length: f32,
    pub reverb_plugin: SoundGraphPluginRef,
}

pub const IRREVERBNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, out),
            },
            FieldInfoData {
                name: "Reverb0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, reverb0),
            },
            FieldInfoData {
                name: "Amplitude0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, amplitude0),
            },
            FieldInfoData {
                name: "EnvelopeType0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, envelope_type0),
            },
            FieldInfoData {
                name: "EnvelopeStartLevel0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, envelope_start_level0),
            },
            FieldInfoData {
                name: "EnvelopeLength0",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, envelope_length0),
            },
            FieldInfoData {
                name: "Reverb1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, reverb1),
            },
            FieldInfoData {
                name: "Amplitude1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, amplitude1),
            },
            FieldInfoData {
                name: "EnvelopeType1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, envelope_type1),
            },
            FieldInfoData {
                name: "EnvelopeStartLevel1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, envelope_start_level1),
            },
            FieldInfoData {
                name: "EnvelopeLength1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, envelope_length1),
            },
            FieldInfoData {
                name: "MaxReverbLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, max_reverb_length),
            },
            FieldInfoData {
                name: "ReverbPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(IrReverbNodeData, reverb_plugin),
            },
        ],
    }),
    array_type: Some(IRREVERBNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IrReverbNodeData {
    fn type_info() -> &'static TypeInfo {
        IRREVERBNODEDATA_TYPE_INFO
    }
}


pub const IRREVERBNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PlatformFoldDownNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const PLATFORMFOLDDOWNNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformFoldDownNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PlatformFoldDownNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PlatformFoldDownNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(PlatformFoldDownNodeData, plugin),
            },
        ],
    }),
    array_type: Some(PLATFORMFOLDDOWNNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformFoldDownNodeData {
    fn type_info() -> &'static TypeInfo {
        PLATFORMFOLDDOWNNODEDATA_TYPE_INFO
    }
}


pub const PLATFORMFOLDDOWNNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformFoldDownNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PlatformFoldDownNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum FoldDownMode {
    #[default]
    FoldDownMode_None = 0,
    FoldDownMode_PC_5_1 = 1,
    FoldDownMode_PC_Stereo = 2,
    FoldDownMode_PC_Mono = 3,
    FoldDownMode_PS4_5_1 = 4,
    FoldDownMode_PS4_Stereo = 5,
    FoldDownMode_XB1_5_1 = 6,
    FoldDownMode_XB1_Stereo = 7,
}

pub const FOLDDOWNMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FoldDownMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FOLDDOWNMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FoldDownMode {
    fn type_info() -> &'static TypeInfo {
        FOLDDOWNMODE_TYPE_INFO
    }
}


pub const FOLDDOWNMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FoldDownMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FoldDownMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PhysicsNodeData {
    pub distance: AudioGraphNodePort,
    pub velocity: AudioGraphNodePort,
    pub relative_velocity: AudioGraphNodePort,
    pub azimuth: AudioGraphNodePort,
    pub elevation_angle: AudioGraphNodePort,
    pub entries: Vec<PhysicsEntry>,
}

pub const PHYSICSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsNodeData, distance),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsNodeData, velocity),
            },
            FieldInfoData {
                name: "RelativeVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsNodeData, relative_velocity),
            },
            FieldInfoData {
                name: "Azimuth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsNodeData, azimuth),
            },
            FieldInfoData {
                name: "ElevationAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsNodeData, elevation_angle),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: PHYSICSENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(PhysicsNodeData, entries),
            },
        ],
    }),
    array_type: Some(PHYSICSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsNodeData {
    fn type_info() -> &'static TypeInfo {
        PHYSICSNODEDATA_TYPE_INFO
    }
}


pub const PHYSICSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PhysicsNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct Pan2dNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub output_channel_count: Pan2dOutputChannelCount,
    pub pan_angle: AudioGraphNodePort,
    pub pan_distance: AudioGraphNodePort,
    pub pan_size: AudioGraphNodePort,
    pub pan_twist: AudioGraphNodePort,
    pub center_amplitude: AudioGraphNodePort,
    pub main_amplitude: AudioGraphNodePort,
    pub lfe_amplitude: AudioGraphNodePort,
    pub version: Pan2dNodeVersion,
}

pub const PAN2DNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, plugin),
            },
            FieldInfoData {
                name: "OutputChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, output_channel_count),
            },
            FieldInfoData {
                name: "PanAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, pan_angle),
            },
            FieldInfoData {
                name: "PanDistance",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, pan_distance),
            },
            FieldInfoData {
                name: "PanSize",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, pan_size),
            },
            FieldInfoData {
                name: "PanTwist",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, pan_twist),
            },
            FieldInfoData {
                name: "CenterAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, center_amplitude),
            },
            FieldInfoData {
                name: "MainAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, main_amplitude),
            },
            FieldInfoData {
                name: "LfeAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, lfe_amplitude),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: PAN2DNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(Pan2dNodeData, version),
            },
        ],
    }),
    array_type: Some(PAN2DNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Pan2dNodeData {
    fn type_info() -> &'static TypeInfo {
        PAN2DNODEDATA_TYPE_INFO
    }
}


pub const PAN2DNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Pan2dNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum Pan2dNodeVersion {
    #[default]
    Pan2dNodeVersion_2010_2 = 0,
    Pan2dNodeVersion_2016_1 = 1,
}

pub const PAN2DNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PAN2DNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Pan2dNodeVersion {
    fn type_info() -> &'static TypeInfo {
        PAN2DNODEVERSION_TYPE_INFO
    }
}


pub const PAN2DNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Pan2dNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum Pan2dOutputChannelCount {
    #[default]
    Pan2dOutputChannelCount_Two = 0,
    Pan2dOutputChannelCount_Four = 1,
    Pan2dOutputChannelCount_Six = 2,
    Pan2dOutputChannelCount_Eight = 3,
}

pub const PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dOutputChannelCount",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PAN2DOUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Pan2dOutputChannelCount {
    fn type_info() -> &'static TypeInfo {
        PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO
    }
}


pub const PAN2DOUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dOutputChannelCount-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Pan2dOutputChannelCount-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PhysicsEntry {
    pub distance: AudioGraphNodePort,
    pub azimuth: AudioGraphNodePort,
    pub elevation_angle: AudioGraphNodePort,
    pub output: OutputNodeData,
}

pub const PHYSICSENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsEntry, distance),
            },
            FieldInfoData {
                name: "Azimuth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsEntry, azimuth),
            },
            FieldInfoData {
                name: "ElevationAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PhysicsEntry, elevation_angle),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(PhysicsEntry, output),
            },
        ],
    }),
    array_type: Some(PHYSICSENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsEntry {
    fn type_info() -> &'static TypeInfo {
        PHYSICSENTRY_TYPE_INFO
    }
}


pub const PHYSICSENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PhysicsEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct PeakingIir2NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub q: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const PEAKINGIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PeakingIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PeakingIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PeakingIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PeakingIir2NodeData, amplitude),
            },
            FieldInfoData {
                name: "Q",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PeakingIir2NodeData, q),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(PeakingIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(PeakingIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(PEAKINGIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PeakingIir2NodeData {
    fn type_info() -> &'static TypeInfo {
        PEAKINGIIR2NODEDATA_TYPE_INFO
    }
}


pub const PEAKINGIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PeakingIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PeakingIir2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct OrientationNodeData {
    pub listener_angular_velocity: AudioGraphNodePort,
    pub entries: Vec<OrientationNodeEntry>,
}

pub const ORIENTATIONNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ListenerAngularVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeData, listener_angular_velocity),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeData, entries),
            },
        ],
    }),
    array_type: Some(ORIENTATIONNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrientationNodeData {
    fn type_info() -> &'static TypeInfo {
        ORIENTATIONNODEDATA_TYPE_INFO
    }
}


pub const ORIENTATIONNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrientationNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct OrientationNodeEntry {
    pub listener_relative_yaw: AudioGraphNodePort,
    pub listener_relative_pitch: AudioGraphNodePort,
    pub listener_relative_roll: AudioGraphNodePort,
    pub listener_relative_angle: AudioGraphNodePort,
    pub listener_fov_relative_angle: AudioGraphNodePort,
    pub towards_listener_angle: AudioGraphNodePort,
    pub output: OutputNodeData,
}

pub const ORIENTATIONNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ListenerRelativeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_yaw),
            },
            FieldInfoData {
                name: "ListenerRelativePitch",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_pitch),
            },
            FieldInfoData {
                name: "ListenerRelativeRoll",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_roll),
            },
            FieldInfoData {
                name: "ListenerRelativeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_angle),
            },
            FieldInfoData {
                name: "ListenerFovRelativeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, listener_fov_relative_angle),
            },
            FieldInfoData {
                name: "TowardsListenerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, towards_listener_angle),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(OrientationNodeEntry, output),
            },
        ],
    }),
    array_type: Some(ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrientationNodeEntry {
    fn type_info() -> &'static TypeInfo {
        ORIENTATIONNODEENTRY_TYPE_INFO
    }
}


pub const ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrientationNodeEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ObjectOutputNodeConfigData {
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub inner_angle: f32,
    pub outer_angle: f32,
    pub h_f_damping_angle: f32,
    pub listener_outside_gain: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: super::core::FloatCurve,
    pub reverb_gain: f32,
    pub object_patch: SoundBusPatchAsset,
    pub size: f32,
}

pub const OBJECTOUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, outside_gain),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, bleed_max_distance),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, outer_angle),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, listener_outside_gain),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, reverb_gain),
            },
            FieldInfoData {
                name: "ObjectPatch",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSPATCHASSET_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, object_patch),
            },
            FieldInfoData {
                name: "Size",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeConfigData, size),
            },
        ],
    }),
    array_type: Some(OBJECTOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectOutputNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        OBJECTOUTPUTNODECONFIGDATA_TYPE_INFO
    }
}


pub const OBJECTOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectOutputNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ObjectOutputNodeData {
    pub position_x: AudioGraphNodePort,
    pub position_y: AudioGraphNodePort,
    pub position_z: AudioGraphNodePort,
    pub inner_angle: AudioGraphNodePort,
    pub outer_angle: AudioGraphNodePort,
    pub size: AudioGraphNodePort,
    pub object_patch: SoundBusPatchAsset,
    pub source_positioning: PanSourcePositioning,
    pub channel_based_speaker_angles: bool,
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub listener_inner_angle: AudioGraphNodePort,
    pub listener_outer_angle: AudioGraphNodePort,
    pub listener_outside_gain: f32,
    pub h_f_damping_angle: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: super::core::FloatCurve,
    pub reverb_gain: AudioGraphNodePort,
    pub reverb_mode: OutputReverbMode,
    pub reverb_send: SoundBusData,
    pub reverb_send_plugin: SoundGraphPluginRef,
    pub pan_plugin: SoundGraphPluginRef,
    pub object_send_plugin: SoundGraphPluginRef,
}

pub const OBJECTOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PositionX",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, position_x),
            },
            FieldInfoData {
                name: "PositionY",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, position_y),
            },
            FieldInfoData {
                name: "PositionZ",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, position_z),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, outer_angle),
            },
            FieldInfoData {
                name: "Size",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, size),
            },
            FieldInfoData {
                name: "ObjectPatch",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSPATCHASSET_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, object_patch),
            },
            FieldInfoData {
                name: "SourcePositioning",
                flags: MemberInfoFlags::new(0),
                field_type: PANSOURCEPOSITIONING_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, source_positioning),
            },
            FieldInfoData {
                name: "ChannelBasedSpeakerAngles",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, channel_based_speaker_angles),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, outside_gain),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, bleed_max_distance),
            },
            FieldInfoData {
                name: "ListenerInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, listener_inner_angle),
            },
            FieldInfoData {
                name: "ListenerOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, listener_outer_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, listener_outside_gain),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "ReverbMode",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTREVERBMODE_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_mode),
            },
            FieldInfoData {
                name: "ReverbSend",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSDATA_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_send),
            },
            FieldInfoData {
                name: "ReverbSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_send_plugin),
            },
            FieldInfoData {
                name: "PanPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, pan_plugin),
            },
            FieldInfoData {
                name: "ObjectSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ObjectOutputNodeData, object_send_plugin),
            },
        ],
    }),
    array_type: Some(OBJECTOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectOutputNodeData {
    fn type_info() -> &'static TypeInfo {
        OBJECTOUTPUTNODEDATA_TYPE_INFO
    }
}


pub const OBJECTOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectOutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ConeOutputNodeConfigData {
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub pan_size: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub inner_angle: f32,
    pub outer_angle: f32,
    pub h_f_damping_angle: f32,
    pub listener_outside_gain: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: super::core::FloatCurve,
    pub reverb_gain: f32,
}

pub const CONEOUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, outside_gain),
            },
            FieldInfoData {
                name: "PanSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, pan_size),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, bleed_max_distance),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, outer_angle),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, listener_outside_gain),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeConfigData, reverb_gain),
            },
        ],
    }),
    array_type: Some(CONEOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ConeOutputNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        CONEOUTPUTNODECONFIGDATA_TYPE_INFO
    }
}


pub const CONEOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConeOutputNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ConeOutputNodeData {
    pub position_x: AudioGraphNodePort,
    pub position_y: AudioGraphNodePort,
    pub position_z: AudioGraphNodePort,
    pub inner_angle: AudioGraphNodePort,
    pub outer_angle: AudioGraphNodePort,
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub pan_size: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub listener_inner_angle: AudioGraphNodePort,
    pub listener_outer_angle: AudioGraphNodePort,
    pub listener_outside_gain: f32,
    pub center_level: AudioGraphNodePort,
    pub lfe_level: AudioGraphNodePort,
    pub source_positioning: PanSourcePositioning,
    pub channel_based_speaker_angles: bool,
    pub h_f_damping_angle: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: super::core::FloatCurve,
    pub reverb_gain: AudioGraphNodePort,
    pub reverb_mode: OutputReverbMode,
    pub reverb_send: SoundBusData,
    pub pan_plugin: SoundGraphPluginRef,
    pub reverb_send_plugin: SoundGraphPluginRef,
}

pub const CONEOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "PositionX",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, position_x),
            },
            FieldInfoData {
                name: "PositionY",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, position_y),
            },
            FieldInfoData {
                name: "PositionZ",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, position_z),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, outer_angle),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, outside_gain),
            },
            FieldInfoData {
                name: "PanSize",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, pan_size),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, bleed_max_distance),
            },
            FieldInfoData {
                name: "ListenerInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, listener_inner_angle),
            },
            FieldInfoData {
                name: "ListenerOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, listener_outer_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, listener_outside_gain),
            },
            FieldInfoData {
                name: "CenterLevel",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, center_level),
            },
            FieldInfoData {
                name: "LfeLevel",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, lfe_level),
            },
            FieldInfoData {
                name: "SourcePositioning",
                flags: MemberInfoFlags::new(0),
                field_type: PANSOURCEPOSITIONING_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, source_positioning),
            },
            FieldInfoData {
                name: "ChannelBasedSpeakerAngles",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, channel_based_speaker_angles),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "ReverbMode",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTREVERBMODE_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, reverb_mode),
            },
            FieldInfoData {
                name: "ReverbSend",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSDATA_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, reverb_send),
            },
            FieldInfoData {
                name: "PanPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, pan_plugin),
            },
            FieldInfoData {
                name: "ReverbSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ConeOutputNodeData, reverb_send_plugin),
            },
        ],
    }),
    array_type: Some(CONEOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ConeOutputNodeData {
    fn type_info() -> &'static TypeInfo {
        CONEOUTPUTNODEDATA_TYPE_INFO
    }
}


pub const CONEOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConeOutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FlatOutputNodeConfigData {
    pub is_world_aligned: bool,
    pub world_angle: f32,
    pub angle: f32,
    pub reverb_attenuation_curve: super::core::FloatCurve,
    pub reverb_gain: f32,
}

pub const FLATOUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IsWorldAligned",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeConfigData, is_world_aligned),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeConfigData, world_angle),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeConfigData, angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeConfigData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeConfigData, reverb_gain),
            },
        ],
    }),
    array_type: Some(FLATOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlatOutputNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        FLATOUTPUTNODECONFIGDATA_TYPE_INFO
    }
}


pub const FLATOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FlatOutputNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FlatOutputNodeData {
    pub is_world_aligned: bool,
    pub world_angle: f32,
    pub angle: f32,
    pub angle_input: AudioGraphNodePort,
    pub reverb_attenuation_curve: super::core::FloatCurve,
    pub reverb_gain: AudioGraphNodePort,
    pub reverb_mode: OutputReverbMode,
    pub reverb_send: SoundBusData,
    pub center_level: AudioGraphNodePort,
    pub lfe_level: AudioGraphNodePort,
    pub source_positioning: PanSourcePositioning,
    pub channel_based_speaker_angles: bool,
    pub pan_plugin: SoundGraphPluginRef,
    pub reverb_send_plugin: SoundGraphPluginRef,
}

pub const FLATOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "IsWorldAligned",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, is_world_aligned),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, world_angle),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, angle),
            },
            FieldInfoData {
                name: "AngleInput",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, angle_input),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "ReverbMode",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTREVERBMODE_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, reverb_mode),
            },
            FieldInfoData {
                name: "ReverbSend",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSDATA_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, reverb_send),
            },
            FieldInfoData {
                name: "CenterLevel",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, center_level),
            },
            FieldInfoData {
                name: "LfeLevel",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, lfe_level),
            },
            FieldInfoData {
                name: "SourcePositioning",
                flags: MemberInfoFlags::new(0),
                field_type: PANSOURCEPOSITIONING_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, source_positioning),
            },
            FieldInfoData {
                name: "ChannelBasedSpeakerAngles",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, channel_based_speaker_angles),
            },
            FieldInfoData {
                name: "PanPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, pan_plugin),
            },
            FieldInfoData {
                name: "ReverbSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(FlatOutputNodeData, reverb_send_plugin),
            },
        ],
    }),
    array_type: Some(FLATOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlatOutputNodeData {
    fn type_info() -> &'static TypeInfo {
        FLATOUTPUTNODEDATA_TYPE_INFO
    }
}


pub const FLATOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FlatOutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum PanSourcePositioning {
    #[default]
    PanSourcePositioning_InputChannelBased = 0,
    PanSourcePositioning_FixedPosition = 1,
    PanSourcePositioning_InbetweenSpeaker = 2,
}

pub const PANSOURCEPOSITIONING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanSourcePositioning",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PANSOURCEPOSITIONING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PanSourcePositioning {
    fn type_info() -> &'static TypeInfo {
        PANSOURCEPOSITIONING_TYPE_INFO
    }
}


pub const PANSOURCEPOSITIONING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanSourcePositioning-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PanSourcePositioning-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum OutputReverbMode {
    #[default]
    OutputReverbMode_PostGain = 0,
    OutputReverbMode_PreGain = 1,
}

pub const OUTPUTREVERBMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputReverbMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(OUTPUTREVERBMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OutputReverbMode {
    fn type_info() -> &'static TypeInfo {
        OUTPUTREVERBMODE_TYPE_INFO
    }
}


pub const OUTPUTREVERBMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputReverbMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputReverbMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DirectOutputNodeData {
}

pub const DIRECTOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DirectOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        fields: &[
        ],
    }),
    array_type: Some(DIRECTOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DirectOutputNodeData {
    fn type_info() -> &'static TypeInfo {
        DIRECTOUTPUTNODEDATA_TYPE_INFO
    }
}


pub const DIRECTOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DirectOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DirectOutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct OutputNodeConfigData {
    pub min_distance: f32,
    pub attenuation_curve: super::core::FloatCurve,
    pub h_f_damping_distance: f32,
    pub h_f_damping_obstruction: f32,
    pub h_f_damping_occlusion: f32,
    pub gain: f32,
    pub enable_hdr: bool,
    pub expected_peak_amplitude: f32,
    pub mix_group: MixGroup,
}

pub const OUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, min_distance),
            },
            FieldInfoData {
                name: "AttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, attenuation_curve),
            },
            FieldInfoData {
                name: "HFDampingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, h_f_damping_distance),
            },
            FieldInfoData {
                name: "HFDampingObstruction",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, h_f_damping_obstruction),
            },
            FieldInfoData {
                name: "HFDampingOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, h_f_damping_occlusion),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, gain),
            },
            FieldInfoData {
                name: "EnableHdr",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, enable_hdr),
            },
            FieldInfoData {
                name: "ExpectedPeakAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, expected_peak_amplitude),
            },
            FieldInfoData {
                name: "MixGroup",
                flags: MemberInfoFlags::new(0),
                field_type: MIXGROUP_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeConfigData, mix_group),
            },
        ],
    }),
    array_type: Some(OUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OutputNodeConfigData {
    fn type_info() -> &'static TypeInfo {
        OUTPUTNODECONFIGDATA_TYPE_INFO
    }
}


pub const OUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputNodeConfigData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct OutputNodeData {
    pub r#in: AudioGraphNodePort,
    pub bypass_headroom: AudioGraphNodePort,
    pub min_distance: f32,
    pub attenuation_curve: super::core::FloatCurve,
    pub solo: bool,
    pub h_f_damping_distance: AudioGraphNodePort,
    pub h_f_damping_obstruction: AudioGraphNodePort,
    pub h_f_damping_occlusion: f32,
    pub h_f_damping_filter: LowPassFilterType,
    pub gain: f32,
    pub main_send: SoundBusData,
    pub enable_hdr: bool,
    pub expected_peak_amplitude: f32,
    pub transform_source: OutputTransformSource,
    pub output_name: String,
    pub output_name_hash: u32,
    pub low_pass_plugin: SoundGraphPluginRef,
    pub vu_plugin: SoundGraphPluginRef,
    pub main_send_plugin: SoundGraphPluginRef,
    pub mix_group: MixGroup,
    pub version: OutputNodeVersion,
}

pub const OUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, r#in),
            },
            FieldInfoData {
                name: "BypassHeadroom",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, bypass_headroom),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, min_distance),
            },
            FieldInfoData {
                name: "AttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: FLOATCURVE_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, attenuation_curve),
            },
            FieldInfoData {
                name: "Solo",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, solo),
            },
            FieldInfoData {
                name: "HFDampingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, h_f_damping_distance),
            },
            FieldInfoData {
                name: "HFDampingObstruction",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, h_f_damping_obstruction),
            },
            FieldInfoData {
                name: "HFDampingOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, h_f_damping_occlusion),
            },
            FieldInfoData {
                name: "HFDampingFilter",
                flags: MemberInfoFlags::new(0),
                field_type: LOWPASSFILTERTYPE_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, h_f_damping_filter),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, gain),
            },
            FieldInfoData {
                name: "MainSend",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSDATA_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, main_send),
            },
            FieldInfoData {
                name: "EnableHdr",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, enable_hdr),
            },
            FieldInfoData {
                name: "ExpectedPeakAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, expected_peak_amplitude),
            },
            FieldInfoData {
                name: "TransformSource",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTTRANSFORMSOURCE_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, transform_source),
            },
            FieldInfoData {
                name: "OutputName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, output_name),
            },
            FieldInfoData {
                name: "OutputNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, output_name_hash),
            },
            FieldInfoData {
                name: "LowPassPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, low_pass_plugin),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, vu_plugin),
            },
            FieldInfoData {
                name: "MainSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, main_send_plugin),
            },
            FieldInfoData {
                name: "MixGroup",
                flags: MemberInfoFlags::new(0),
                field_type: MIXGROUP_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, mix_group),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTNODEVERSION_TYPE_INFO,
                rust_offset: offset_of!(OutputNodeData, version),
            },
        ],
    }),
    array_type: Some(OUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OutputNodeData {
    fn type_info() -> &'static TypeInfo {
        OUTPUTNODEDATA_TYPE_INFO
    }
}


pub const OUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum OutputNodeVersion {
    #[default]
    OutputNodeVersion_2010_2 = 0,
    OutputNodeVersion_2016_1 = 1,
}

pub const OUTPUTNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(OUTPUTNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OutputNodeVersion {
    fn type_info() -> &'static TypeInfo {
        OUTPUTNODEVERSION_TYPE_INFO
    }
}


pub const OUTPUTNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputNodeVersion-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum LowPassFilterType {
    #[default]
    LowPassFilterType_None = 0,
    LowPassFilterType_IIR2 = 1,
    LowPassFilterType_Butterworth_Order1 = 2,
    LowPassFilterType_Butterworth_Order2 = 3,
    LowPassFilterType_Butterworth_Order3 = 4,
    LowPassFilterType_Butterworth_Order4 = 5,
}

pub const LOWPASSFILTERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFilterType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LOWPASSFILTERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LowPassFilterType {
    fn type_info() -> &'static TypeInfo {
        LOWPASSFILTERTYPE_TYPE_INFO
    }
}


pub const LOWPASSFILTERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFilterType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassFilterType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum OutputTransformSource {
    #[default]
    OutputTransformSource_Sound = 0,
    OutputTransformSource_Listener = 1,
    OutputTransformSource_Output = 2,
}

pub const OUTPUTTRANSFORMSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputTransformSource",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(OUTPUTTRANSFORMSOURCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OutputTransformSource {
    fn type_info() -> &'static TypeInfo {
        OUTPUTTRANSFORMSOURCE_TYPE_INFO
    }
}


pub const OUTPUTTRANSFORMSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputTransformSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputTransformSource-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ObjectsNodeData {
    pub enable: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub is_object_audio_supported: AudioGraphNodePort,
    pub max_object_count: u32,
    pub bed_clamping_distance: f32,
    pub default_object_patch: SoundBusPatchAsset,
}

pub const OBJECTSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectsNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectsNodeData, enable),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectsNodeData, amplitude),
            },
            FieldInfoData {
                name: "IsObjectAudioSupported",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectsNodeData, is_object_audio_supported),
            },
            FieldInfoData {
                name: "MaxObjectCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectsNodeData, max_object_count),
            },
            FieldInfoData {
                name: "BedClampingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ObjectsNodeData, bed_clamping_distance),
            },
            FieldInfoData {
                name: "DefaultObjectPatch",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDBUSPATCHASSET_TYPE_INFO,
                rust_offset: offset_of!(ObjectsNodeData, default_object_patch),
            },
        ],
    }),
    array_type: Some(OBJECTSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectsNodeData {
    fn type_info() -> &'static TypeInfo {
        OBJECTSNODEDATA_TYPE_INFO
    }
}


pub const OBJECTSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectsNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectsNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ObjectNodeData {
    pub r#in: AudioGraphNodePort,
    pub vu_plugin: SoundGraphPluginRef,
    pub object_plugin: SoundGraphPluginRef,
}

pub const OBJECTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ObjectNodeData, r#in),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ObjectNodeData, vu_plugin),
            },
            FieldInfoData {
                name: "ObjectPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ObjectNodeData, object_plugin),
            },
        ],
    }),
    array_type: Some(OBJECTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectNodeData {
    fn type_info() -> &'static TypeInfo {
        OBJECTNODEDATA_TYPE_INFO
    }
}


pub const OBJECTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerNodeData {
    pub entries: Vec<MixerEntry>,
    pub out: AudioGraphNodePort,
}

pub const MIXERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: MIXERENTRY_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MixerNodeData, entries),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerNodeData, out),
            },
        ],
    }),
    array_type: Some(MIXERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerNodeData {
    fn type_info() -> &'static TypeInfo {
        MIXERNODEDATA_TYPE_INFO
    }
}


pub const MIXERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MixerEntry {
    pub r#in: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const MIXERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerEntry, r#in),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MixerEntry, amplitude),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(MixerEntry, plugin),
            },
        ],
    }),
    array_type: Some(MIXERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerEntry {
    fn type_info() -> &'static TypeInfo {
        MIXERENTRY_TYPE_INFO
    }
}


pub const MIXERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntry-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MatrixPannerNodeData {
    pub r#in: AudioGraphNodePort,
    pub front_left: AudioGraphNodePort,
    pub center: AudioGraphNodePort,
    pub front_right: AudioGraphNodePort,
    pub rear_left: AudioGraphNodePort,
    pub lfe: AudioGraphNodePort,
    pub rear_right: AudioGraphNodePort,
    pub far_rear_left: AudioGraphNodePort,
    pub far_rear_right: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub output_channel_count: MatrixPannerOutputChannelCount,
}

pub const MATRIXPANNERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, r#in),
            },
            FieldInfoData {
                name: "FrontLeft",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, front_left),
            },
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, center),
            },
            FieldInfoData {
                name: "FrontRight",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, front_right),
            },
            FieldInfoData {
                name: "RearLeft",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, rear_left),
            },
            FieldInfoData {
                name: "Lfe",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, lfe),
            },
            FieldInfoData {
                name: "RearRight",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, rear_right),
            },
            FieldInfoData {
                name: "FarRearLeft",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, far_rear_left),
            },
            FieldInfoData {
                name: "FarRearRight",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, far_rear_right),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, out),
            },
            FieldInfoData {
                name: "OutputChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO,
                rust_offset: offset_of!(MatrixPannerNodeData, output_channel_count),
            },
        ],
    }),
    array_type: Some(MATRIXPANNERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MatrixPannerNodeData {
    fn type_info() -> &'static TypeInfo {
        MATRIXPANNERNODEDATA_TYPE_INFO
    }
}


pub const MATRIXPANNERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MatrixPannerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum MatrixPannerOutputChannelCount {
    #[default]
    MatrixPannerOutputChannelCount_Two = 0,
    MatrixPannerOutputChannelCount_Four = 1,
    MatrixPannerOutputChannelCount_Six = 2,
    MatrixPannerOutputChannelCount_Eight = 3,
}

pub const MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerOutputChannelCount",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MATRIXPANNEROUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MatrixPannerOutputChannelCount {
    fn type_info() -> &'static TypeInfo {
        MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO
    }
}


pub const MATRIXPANNEROUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerOutputChannelCount-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MatrixPannerOutputChannelCount-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct MasterUnitNodeData {
    pub settings_index: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub master_gain: AudioGraphNodePort,
    pub master_lfe_gain: AudioGraphNodePort,
    pub master_dialog_gain: AudioGraphNodePort,
    pub main_mix_gain: AudioGraphNodePort,
    pub post_effects_gain: AudioGraphNodePort,
    pub reverb_gain: AudioGraphNodePort,
    pub fade_time: AudioGraphNodePort,
    pub high_pass_freq: AudioGraphNodePort,
    pub low_shelf_freq: AudioGraphNodePort,
    pub low_shelf_gain: AudioGraphNodePort,
    pub high_shelf_freq: AudioGraphNodePort,
    pub high_shelf_gain: AudioGraphNodePort,
    pub comp_threshold: AudioGraphNodePort,
    pub comp_ratio: AudioGraphNodePort,
    pub comp_attack: AudioGraphNodePort,
    pub comp_release: AudioGraphNodePort,
    pub dist_clip_level: AudioGraphNodePort,
    pub parallel_distortion_gain: AudioGraphNodePort,
    pub settings: Vec<MasterUnitSettings>,
}

pub const MASTERUNITNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "SettingsIndex",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, settings_index),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, amplitude),
            },
            FieldInfoData {
                name: "MasterGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, master_gain),
            },
            FieldInfoData {
                name: "MasterLfeGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, master_lfe_gain),
            },
            FieldInfoData {
                name: "MasterDialogGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, master_dialog_gain),
            },
            FieldInfoData {
                name: "MainMixGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, main_mix_gain),
            },
            FieldInfoData {
                name: "PostEffectsGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, post_effects_gain),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, fade_time),
            },
            FieldInfoData {
                name: "HighPassFreq",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, high_pass_freq),
            },
            FieldInfoData {
                name: "LowShelfFreq",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, low_shelf_freq),
            },
            FieldInfoData {
                name: "LowShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, low_shelf_gain),
            },
            FieldInfoData {
                name: "HighShelfFreq",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, high_shelf_freq),
            },
            FieldInfoData {
                name: "HighShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, high_shelf_gain),
            },
            FieldInfoData {
                name: "CompThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, comp_threshold),
            },
            FieldInfoData {
                name: "CompRatio",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, comp_ratio),
            },
            FieldInfoData {
                name: "CompAttack",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, comp_attack),
            },
            FieldInfoData {
                name: "CompRelease",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, comp_release),
            },
            FieldInfoData {
                name: "DistClipLevel",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, dist_clip_level),
            },
            FieldInfoData {
                name: "ParallelDistortionGain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, parallel_distortion_gain),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(144),
                field_type: MASTERUNITSETTINGS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(MasterUnitNodeData, settings),
            },
        ],
    }),
    array_type: Some(MASTERUNITNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MasterUnitNodeData {
    fn type_info() -> &'static TypeInfo {
        MASTERUNITNODEDATA_TYPE_INFO
    }
}


pub const MASTERUNITNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MasterUnitNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LowShelfIir2NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const LOWSHELFIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowShelfIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowShelfIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowShelfIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowShelfIir2NodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowShelfIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(LowShelfIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWSHELFIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowShelfIir2NodeData {
    fn type_info() -> &'static TypeInfo {
        LOWSHELFIIR2NODEDATA_TYPE_INFO
    }
}


pub const LOWSHELFIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowShelfIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowShelfIir2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LowPassIir2NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const LOWPASSIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(LowPassIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWPASSIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowPassIir2NodeData {
    fn type_info() -> &'static TypeInfo {
        LOWPASSIIR2NODEDATA_TYPE_INFO
    }
}


pub const LOWPASSIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassIir2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LowPassFir64NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const LOWPASSFIR64NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFir64NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassFir64NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassFir64NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassFir64NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(LowPassFir64NodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWPASSFIR64NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowPassFir64NodeData {
    fn type_info() -> &'static TypeInfo {
        LOWPASSFIR64NODEDATA_TYPE_INFO
    }
}


pub const LOWPASSFIR64NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFir64NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassFir64NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LowPassButterworthNodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub order: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const LOWPASSBUTTERWORTHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassButterworthNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassButterworthNodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassButterworthNodeData, frequency),
            },
            FieldInfoData {
                name: "Order",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassButterworthNodeData, order),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LowPassButterworthNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(LowPassButterworthNodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowPassButterworthNodeData {
    fn type_info() -> &'static TypeInfo {
        LOWPASSBUTTERWORTHNODEDATA_TYPE_INFO
    }
}


pub const LOWPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassButterworthNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassButterworthNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct LimiterNodeData {
    pub r#in: AudioGraphNodePort,
    pub sidechain: AudioGraphNodePort,
    pub threshold: AudioGraphNodePort,
    pub release_time: AudioGraphNodePort,
    pub use_sidechain: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub channel_mode: LimiterChannelMode,
    pub plugin: SoundGraphPluginRef,
}

pub const LIMITERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, r#in),
            },
            FieldInfoData {
                name: "Sidechain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, sidechain),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, threshold),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, release_time),
            },
            FieldInfoData {
                name: "UseSidechain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, use_sidechain),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, out),
            },
            FieldInfoData {
                name: "ChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: LIMITERCHANNELMODE_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, channel_mode),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(LimiterNodeData, plugin),
            },
        ],
    }),
    array_type: Some(LIMITERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LimiterNodeData {
    fn type_info() -> &'static TypeInfo {
        LIMITERNODEDATA_TYPE_INFO
    }
}


pub const LIMITERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LimiterNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum LimiterChannelMode {
    #[default]
    LimiterChannelMode_Independent = 0,
    LimiterChannelMode_Grouped = 1,
}

pub const LIMITERCHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LIMITERCHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LimiterChannelMode {
    fn type_info() -> &'static TypeInfo {
        LIMITERCHANNELMODE_TYPE_INFO
    }
}


pub const LIMITERCHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LimiterChannelMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HighShelfIir2NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const HIGHSHELFIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighShelfIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighShelfIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighShelfIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighShelfIir2NodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighShelfIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(HighShelfIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHSHELFIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighShelfIir2NodeData {
    fn type_info() -> &'static TypeInfo {
        HIGHSHELFIIR2NODEDATA_TYPE_INFO
    }
}


pub const HIGHSHELFIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighShelfIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighShelfIir2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HighPassIir2NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const HIGHPASSIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(HighPassIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHPASSIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighPassIir2NodeData {
    fn type_info() -> &'static TypeInfo {
        HIGHPASSIIR2NODEDATA_TYPE_INFO
    }
}


pub const HIGHPASSIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighPassIir2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HighPassFir64NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const HIGHPASSFIR64NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassFir64NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassFir64NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassFir64NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassFir64NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(HighPassFir64NodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHPASSFIR64NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighPassFir64NodeData {
    fn type_info() -> &'static TypeInfo {
        HIGHPASSFIR64NODEDATA_TYPE_INFO
    }
}


pub const HIGHPASSFIR64NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassFir64NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighPassFir64NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct HighPassButterworthNodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub order: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const HIGHPASSBUTTERWORTHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassButterworthNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassButterworthNodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassButterworthNodeData, frequency),
            },
            FieldInfoData {
                name: "Order",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassButterworthNodeData, order),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(HighPassButterworthNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(HighPassButterworthNodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighPassButterworthNodeData {
    fn type_info() -> &'static TypeInfo {
        HIGHPASSBUTTERWORTHNODEDATA_TYPE_INFO
    }
}


pub const HIGHPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassButterworthNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighPassButterworthNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct SinePlayerNodeData {
    pub channel_count: u32,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const SINEPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SinePlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: UINT32_TYPE_INFO,
                rust_offset: offset_of!(SinePlayerNodeData, channel_count),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SinePlayerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SinePlayerNodeData, stop),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SinePlayerNodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(SinePlayerNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(SinePlayerNodeData, plugin),
            },
        ],
    }),
    array_type: Some(SINEPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SinePlayerNodeData {
    fn type_info() -> &'static TypeInfo {
        SINEPLAYERNODEDATA_TYPE_INFO
    }
}


pub const SINEPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SinePlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SinePlayerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GainFaderNodeData {
    pub r#in: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub start_time: AudioGraphNodePort,
    pub fade_time: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub fade_type: GainFaderFadeType,
    pub plugin: SoundGraphPluginRef,
}

pub const GAINFADERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, r#in),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, start),
            },
            FieldInfoData {
                name: "StartTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, start_time),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, fade_time),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, out),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: GAINFADERFADETYPE_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, fade_type),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(GainFaderNodeData, plugin),
            },
        ],
    }),
    array_type: Some(GAINFADERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GainFaderNodeData {
    fn type_info() -> &'static TypeInfo {
        GAINFADERNODEDATA_TYPE_INFO
    }
}


pub const GAINFADERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("GainFaderNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum GainFaderFadeType {
    #[default]
    GainFaderFadeType_LinearAmplitude = 0,
    GainFaderFadeType_LinearPower = 1,
    GainFaderFadeType_SineAmplitude = 2,
}

pub const GAINFADERFADETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderFadeType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(GAINFADERFADETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GainFaderFadeType {
    fn type_info() -> &'static TypeInfo {
        GAINFADERFADETYPE_TYPE_INFO
    }
}


pub const GAINFADERFADETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderFadeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("GainFaderFadeType-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct GainNodeData {
    pub r#in: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const GAINNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainNodeData, r#in),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(GainNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(GainNodeData, plugin),
            },
        ],
    }),
    array_type: Some(GAINNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GainNodeData {
    fn type_info() -> &'static TypeInfo {
        GAINNODEDATA_TYPE_INFO
    }
}


pub const GAINNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("GainNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FrequencyShiftSsbNodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub filter: FrequencyShiftSsbFilter,
    pub plugin: SoundGraphPluginRef,
}

pub const FREQUENCYSHIFTSSBNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, out),
            },
            FieldInfoData {
                name: "Filter",
                flags: MemberInfoFlags::new(0),
                field_type: FREQUENCYSHIFTSSBFILTER_TYPE_INFO,
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, filter),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, plugin),
            },
        ],
    }),
    array_type: Some(FREQUENCYSHIFTSSBNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FrequencyShiftSsbNodeData {
    fn type_info() -> &'static TypeInfo {
        FREQUENCYSHIFTSSBNODEDATA_TYPE_INFO
    }
}


pub const FREQUENCYSHIFTSSBNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FrequencyShiftSsbNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum FrequencyShiftSsbFilter {
    #[default]
    FrequencyShiftSsbFilter_None = 0,
    FrequencyShiftSsbFilter_Fir64 = 1,
}

pub const FREQUENCYSHIFTSSBFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbFilter",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FREQUENCYSHIFTSSBFILTER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FrequencyShiftSsbFilter {
    fn type_info() -> &'static TypeInfo {
        FREQUENCYSHIFTSSBFILTER_TYPE_INFO
    }
}


pub const FREQUENCYSHIFTSSBFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FrequencyShiftSsbFilter-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct FlangerNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub max_delay: f32,
    pub max_modulation_depth: f32,
    pub delay_time: AudioGraphNodePort,
    pub modulation_depth: AudioGraphNodePort,
    pub modulation_frequency: AudioGraphNodePort,
}

pub const FLANGERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlangerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, plugin),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, max_delay),
            },
            FieldInfoData {
                name: "MaxModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, max_modulation_depth),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, delay_time),
            },
            FieldInfoData {
                name: "ModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, modulation_depth),
            },
            FieldInfoData {
                name: "ModulationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(FlangerNodeData, modulation_frequency),
            },
        ],
    }),
    array_type: Some(FLANGERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlangerNodeData {
    fn type_info() -> &'static TypeInfo {
        FLANGERNODEDATA_TYPE_INFO
    }
}


pub const FLANGERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlangerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FlangerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct EnvironmentNodeData {
    pub obstruction_value: AudioGraphNodePort,
    pub occlusion_factor: AudioGraphNodePort,
}

pub const ENVIRONMENTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnvironmentNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "ObstructionValue",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EnvironmentNodeData, obstruction_value),
            },
            FieldInfoData {
                name: "OcclusionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(EnvironmentNodeData, occlusion_factor),
            },
        ],
    }),
    array_type: Some(ENVIRONMENTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnvironmentNodeData {
    fn type_info() -> &'static TypeInfo {
        ENVIRONMENTNODEDATA_TYPE_INFO
    }
}


pub const ENVIRONMENTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnvironmentNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EnvironmentNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DivisibleLoopPlayerNodeData {
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub freeze_segment: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub wave: SoundWaveAssetBase,
    pub selection_group: NewWaveSelectionGroup,
    pub external_wave: AudioGraphNodePort,
    pub plugins: Vec<DivisibleLoopPlayerPlugins>,
    pub cross_fade_length: f32,
    pub start_at_random_position: bool,
    pub divisible_loop_player_node_debug: DivisibleLoopPlayerNodeDebugData,
}

pub const DIVISIBLELOOPPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, stop),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, amplitude),
            },
            FieldInfoData {
                name: "FreezeSegment",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, freeze_segment),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, output),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDWAVEASSETBASE_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, wave),
            },
            FieldInfoData {
                name: "SelectionGroup",
                flags: MemberInfoFlags::new(0),
                field_type: NEWWAVESELECTIONGROUP_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, selection_group),
            },
            FieldInfoData {
                name: "ExternalWave",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, external_wave),
            },
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, plugins),
            },
            FieldInfoData {
                name: "CrossFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, cross_fade_length),
            },
            FieldInfoData {
                name: "StartAtRandomPosition",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, start_at_random_position),
            },
            FieldInfoData {
                name: "DivisibleLoopPlayerNodeDebug",
                flags: MemberInfoFlags::new(0),
                field_type: DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, divisible_loop_player_node_debug),
            },
        ],
    }),
    array_type: Some(DIVISIBLELOOPPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DivisibleLoopPlayerNodeData {
    fn type_info() -> &'static TypeInfo {
        DIVISIBLELOOPPLAYERNODEDATA_TYPE_INFO
    }
}


pub const DIVISIBLELOOPPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DivisibleLoopPlayerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Eq, Debug)]
pub struct DivisibleLoopPlayerPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
    pub gain_fader: SoundGraphPluginRef,
}

pub const DIVISIBLELOOPPLAYERPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::Value(ValueTypeInfoData {
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, snd_player),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, gain),
            },
            FieldInfoData {
                name: "GainFader",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, gain_fader),
            },
        ],
    }),
    array_type: Some(DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DivisibleLoopPlayerPlugins {
    fn type_info() -> &'static TypeInfo {
        DIVISIBLELOOPPLAYERPLUGINS_TYPE_INFO
    }
}


pub const DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DivisibleLoopPlayerPlugins-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DivisibleLoopPlayerNodeDebugData {
    pub enable_debug: bool,
    pub debug_input_connections: bool,
    pub debug_text_x_pos: i32,
    pub debug_text_y_pos: i32,
    pub event_display_time: f32,
    pub divisible_loop_player_debug_info_color: super::core::Vec3,
    pub properties_debug_info_color: super::core::Vec3,
    pub events_debug_info_color: super::core::Vec3,
    pub external_wave_debug_info_color: super::core::Vec3,
    pub mute_sampler: bool,
}

pub const DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeDebugData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(DATACONTAINER_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "EnableDebug",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, enable_debug),
            },
            FieldInfoData {
                name: "DebugInputConnections",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, debug_input_connections),
            },
            FieldInfoData {
                name: "DebugTextXPos",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, debug_text_x_pos),
            },
            FieldInfoData {
                name: "DebugTextYPos",
                flags: MemberInfoFlags::new(0),
                field_type: INT32_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, debug_text_y_pos),
            },
            FieldInfoData {
                name: "EventDisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, event_display_time),
            },
            FieldInfoData {
                name: "DivisibleLoopPlayerDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, divisible_loop_player_debug_info_color),
            },
            FieldInfoData {
                name: "PropertiesDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, properties_debug_info_color),
            },
            FieldInfoData {
                name: "EventsDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, events_debug_info_color),
            },
            FieldInfoData {
                name: "ExternalWaveDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: VEC3_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, external_wave_debug_info_color),
            },
            FieldInfoData {
                name: "MuteSampler",
                flags: MemberInfoFlags::new(0),
                field_type: BOOLEAN_TYPE_INFO,
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, mute_sampler),
            },
        ],
    }),
    array_type: Some(DIVISIBLELOOPPLAYERNODEDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DivisibleLoopPlayerNodeDebugData {
    fn type_info() -> &'static TypeInfo {
        DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO
    }
}


pub const DIVISIBLELOOPPLAYERNODEDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DivisibleLoopPlayerNodeDebugData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ExpanderNodeData {
    pub r#in: AudioGraphNodePort,
    pub sidechain: AudioGraphNodePort,
    pub threshold: AudioGraphNodePort,
    pub ratio: AudioGraphNodePort,
    pub attack_time: AudioGraphNodePort,
    pub release_time: AudioGraphNodePort,
    pub use_sidechain: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub channel_mode: ExpanderChannelMode,
    pub plugin: SoundGraphPluginRef,
}

pub const EXPANDERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, r#in),
            },
            FieldInfoData {
                name: "Sidechain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, sidechain),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, threshold),
            },
            FieldInfoData {
                name: "Ratio",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, ratio),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, release_time),
            },
            FieldInfoData {
                name: "UseSidechain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, use_sidechain),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, out),
            },
            FieldInfoData {
                name: "ChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: EXPANDERCHANNELMODE_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, channel_mode),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ExpanderNodeData, plugin),
            },
        ],
    }),
    array_type: Some(EXPANDERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExpanderNodeData {
    fn type_info() -> &'static TypeInfo {
        EXPANDERNODEDATA_TYPE_INFO
    }
}


pub const EXPANDERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ExpanderNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum ExpanderChannelMode {
    #[default]
    ExpanderChannelMode_Independent = 0,
    ExpanderChannelMode_Grouped = 1,
}

pub const EXPANDERCHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(EXPANDERCHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExpanderChannelMode {
    fn type_info() -> &'static TypeInfo {
        EXPANDERCHANNELMODE_TYPE_INFO
    }
}


pub const EXPANDERCHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ExpanderChannelMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DistortionClipNodeData {
    pub r#in: AudioGraphNodePort,
    pub clip_level: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const DISTORTIONCLIPNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistortionClipNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DistortionClipNodeData, r#in),
            },
            FieldInfoData {
                name: "ClipLevel",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DistortionClipNodeData, clip_level),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DistortionClipNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DistortionClipNodeData, plugin),
            },
        ],
    }),
    array_type: Some(DISTORTIONCLIPNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DistortionClipNodeData {
    fn type_info() -> &'static TypeInfo {
        DISTORTIONCLIPNODEDATA_TYPE_INFO
    }
}


pub const DISTORTIONCLIPNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistortionClipNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DistortionClipNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DialogSamplerNodeData {
    pub pitch: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub enable_subtitles: AudioGraphNodePort,
    pub r#continue: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub triggered: AudioGraphNodePort,
    pub finished: AudioGraphNodePort,
    pub snd_player_plugin: SoundGraphPluginRef,
    pub resample_plugin: SoundGraphPluginRef,
    pub pause_plugin: SoundGraphPluginRef,
    pub gain_plugin: SoundGraphPluginRef,
    pub tail_length: f32,
    pub pitch_source: OutputNodeData,
}

pub const DIALOGSAMPLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DialogSamplerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, pitch),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, amplitude),
            },
            FieldInfoData {
                name: "EnableSubtitles",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, enable_subtitles),
            },
            FieldInfoData {
                name: "Continue",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, r#continue),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, output),
            },
            FieldInfoData {
                name: "Triggered",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, triggered),
            },
            FieldInfoData {
                name: "Finished",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, finished),
            },
            FieldInfoData {
                name: "SndPlayerPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, snd_player_plugin),
            },
            FieldInfoData {
                name: "ResamplePlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, resample_plugin),
            },
            FieldInfoData {
                name: "PausePlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, pause_plugin),
            },
            FieldInfoData {
                name: "GainPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, gain_plugin),
            },
            FieldInfoData {
                name: "TailLength",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, tail_length),
            },
            FieldInfoData {
                name: "PitchSource",
                flags: MemberInfoFlags::new(0),
                field_type: OUTPUTNODEDATA_TYPE_INFO,
                rust_offset: offset_of!(DialogSamplerNodeData, pitch_source),
            },
        ],
    }),
    array_type: Some(DIALOGSAMPLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DialogSamplerNodeData {
    fn type_info() -> &'static TypeInfo {
        DIALOGSAMPLERNODEDATA_TYPE_INFO
    }
}


pub const DIALOGSAMPLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DialogSamplerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DialogSamplerNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DelayNodeData {
    pub r#in: AudioGraphNodePort,
    pub delay_time: AudioGraphNodePort,
    pub feedback: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub plugin: SoundGraphPluginRef,
}

pub const DELAYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DelayNodeData, r#in),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DelayNodeData, delay_time),
            },
            FieldInfoData {
                name: "Feedback",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DelayNodeData, feedback),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DelayNodeData, out),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(DelayNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DelayNodeData, plugin),
            },
        ],
    }),
    array_type: Some(DELAYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DelayNodeData {
    fn type_info() -> &'static TypeInfo {
        DELAYNODEDATA_TYPE_INFO
    }
}


pub const DELAYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DelayNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct DacNodeData {
    pub r#in: AudioGraphNodePort,
    pub hrtf: AudioGraphNodePort,
    pub delay_plugin: SoundGraphPluginRef,
    pub vu_plugin: SoundGraphPluginRef,
    pub gain_plugin: SoundGraphPluginRef,
    pub dac_plugin: SoundGraphPluginRef,
}

pub const DACNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DacNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DacNodeData, r#in),
            },
            FieldInfoData {
                name: "Hrtf",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(DacNodeData, hrtf),
            },
            FieldInfoData {
                name: "DelayPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DacNodeData, delay_plugin),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DacNodeData, vu_plugin),
            },
            FieldInfoData {
                name: "GainPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DacNodeData, gain_plugin),
            },
            FieldInfoData {
                name: "DacPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(DacNodeData, dac_plugin),
            },
        ],
    }),
    array_type: Some(DACNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DacNodeData {
    fn type_info() -> &'static TypeInfo {
        DACNODEDATA_TYPE_INFO
    }
}


pub const DACNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DacNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DacNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CrossfaderNodeData {
    pub in1: AudioGraphNodePort,
    pub in2: AudioGraphNodePort,
    pub ctrl: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin1: SoundGraphPluginRef,
    pub plugin2: SoundGraphPluginRef,
}

pub const CROSSFADERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrossfaderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CrossfaderNodeData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CrossfaderNodeData, in2),
            },
            FieldInfoData {
                name: "Ctrl",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CrossfaderNodeData, ctrl),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CrossfaderNodeData, out),
            },
            FieldInfoData {
                name: "Plugin1",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(CrossfaderNodeData, plugin1),
            },
            FieldInfoData {
                name: "Plugin2",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(CrossfaderNodeData, plugin2),
            },
        ],
    }),
    array_type: Some(CROSSFADERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CrossfaderNodeData {
    fn type_info() -> &'static TypeInfo {
        CROSSFADERNODEDATA_TYPE_INFO
    }
}


pub const CROSSFADERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrossfaderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CrossfaderNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ControllerOutputNodeData {
    pub r#in: AudioGraphNodePort,
    pub connected: AudioGraphNodePort,
    pub disconnected: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const CONTROLLEROUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllerOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ControllerOutputNodeData, r#in),
            },
            FieldInfoData {
                name: "Connected",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ControllerOutputNodeData, connected),
            },
            FieldInfoData {
                name: "Disconnected",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ControllerOutputNodeData, disconnected),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ControllerOutputNodeData, plugin),
            },
        ],
    }),
    array_type: Some(CONTROLLEROUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ControllerOutputNodeData {
    fn type_info() -> &'static TypeInfo {
        CONTROLLEROUTPUTNODEDATA_TYPE_INFO
    }
}


pub const CONTROLLEROUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllerOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ControllerOutputNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct CompressorNodeData {
    pub r#in: AudioGraphNodePort,
    pub sidechain: AudioGraphNodePort,
    pub threshold: AudioGraphNodePort,
    pub ratio: AudioGraphNodePort,
    pub attack_time: AudioGraphNodePort,
    pub release_time: AudioGraphNodePort,
    pub use_sidechain: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub channel_mode: CompressorChannelMode,
    pub plugin: SoundGraphPluginRef,
}

pub const COMPRESSORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, r#in),
            },
            FieldInfoData {
                name: "Sidechain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, sidechain),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, threshold),
            },
            FieldInfoData {
                name: "Ratio",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, ratio),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, release_time),
            },
            FieldInfoData {
                name: "UseSidechain",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, use_sidechain),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, out),
            },
            FieldInfoData {
                name: "ChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: COMPRESSORCHANNELMODE_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, channel_mode),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(CompressorNodeData, plugin),
            },
        ],
    }),
    array_type: Some(COMPRESSORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompressorNodeData {
    fn type_info() -> &'static TypeInfo {
        COMPRESSORNODEDATA_TYPE_INFO
    }
}


pub const COMPRESSORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CompressorNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum CompressorChannelMode {
    #[default]
    CompressorChannelMode_Independent = 0,
    CompressorChannelMode_Grouped = 1,
}

pub const COMPRESSORCHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(COMPRESSORCHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CompressorChannelMode {
    fn type_info() -> &'static TypeInfo {
        COMPRESSORCHANNELMODE_TYPE_INFO
    }
}


pub const COMPRESSORCHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CompressorChannelMode-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct ChorusNodeData {
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub max_delay: f32,
    pub max_modulation_depth: f32,
    pub tap_count: AudioGraphNodePort,
    pub delay_time: AudioGraphNodePort,
    pub modulation_depth: AudioGraphNodePort,
    pub modulation_frequency: AudioGraphNodePort,
}

pub const CHORUSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChorusNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, plugin),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, max_delay),
            },
            FieldInfoData {
                name: "MaxModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, max_modulation_depth),
            },
            FieldInfoData {
                name: "TapCount",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, tap_count),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, delay_time),
            },
            FieldInfoData {
                name: "ModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, modulation_depth),
            },
            FieldInfoData {
                name: "ModulationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(ChorusNodeData, modulation_frequency),
            },
        ],
    }),
    array_type: Some(CHORUSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChorusNodeData {
    fn type_info() -> &'static TypeInfo {
        CHORUSNODEDATA_TYPE_INFO
    }
}


pub const CHORUSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChorusNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ChorusNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BusNodeData {
    pub out: AudioGraphNodePort,
    pub vu_plugin: SoundGraphPluginRef,
}

pub const BUSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BusNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDBUSDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BusNodeData, out),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(BusNodeData, vu_plugin),
            },
        ],
    }),
    array_type: Some(BUSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BusNodeData {
    fn type_info() -> &'static TypeInfo {
        BUSNODEDATA_TYPE_INFO
    }
}


pub const BUSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BusNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BusNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BandPassIir2NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub bandwidth: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const BANDPASSIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Bandwidth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassIir2NodeData, bandwidth),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(BandPassIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(BANDPASSIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BandPassIir2NodeData {
    fn type_info() -> &'static TypeInfo {
        BANDPASSIIR2NODEDATA_TYPE_INFO
    }
}


pub const BANDPASSIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BandPassIir2NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct BandPassFir64NodeData {
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub bandwidth: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub const BANDPASSFIR64NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassFir64NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassFir64NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassFir64NodeData, frequency),
            },
            FieldInfoData {
                name: "Bandwidth",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassFir64NodeData, bandwidth),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(BandPassFir64NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(BandPassFir64NodeData, plugin),
            },
        ],
    }),
    array_type: Some(BANDPASSFIR64NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BandPassFir64NodeData {
    fn type_info() -> &'static TypeInfo {
        BANDPASSFIR64NODEDATA_TYPE_INFO
    }
}


pub const BANDPASSFIR64NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassFir64NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BandPassFir64NodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AllPassNodeData {
    pub r#in: AudioGraphNodePort,
    pub delay_time: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub plugin: SoundGraphPluginRef,
}

pub const ALLPASSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllPassNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AllPassNodeData, r#in),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AllPassNodeData, delay_time),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AllPassNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AllPassNodeData, out),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: FLOAT32_TYPE_INFO,
                rust_offset: offset_of!(AllPassNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(AllPassNodeData, plugin),
            },
        ],
    }),
    array_type: Some(ALLPASSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AllPassNodeData {
    fn type_info() -> &'static TypeInfo {
        ALLPASSNODEDATA_TYPE_INFO
    }
}


pub const ALLPASSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllPassNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AllPassNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, PartialEq, Debug)]
pub struct AiffWriterNodeData {
    pub r#in: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub file_name: String,
}

pub const AIFFWRITERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AiffWriterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AiffWriterNodeData, r#in),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AiffWriterNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: AUDIOGRAPHNODEPORT_TYPE_INFO,
                rust_offset: offset_of!(AiffWriterNodeData, stop),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: SOUNDGRAPHPLUGINREF_TYPE_INFO,
                rust_offset: offset_of!(AiffWriterNodeData, plugin),
            },
            FieldInfoData {
                name: "FileName",
                flags: MemberInfoFlags::new(0),
                field_type: CSTRING_TYPE_INFO,
                rust_offset: offset_of!(AiffWriterNodeData, file_name),
            },
        ],
    }),
    array_type: Some(AIFFWRITERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AiffWriterNodeData {
    fn type_info() -> &'static TypeInfo {
        AIFFWRITERNODEDATA_TYPE_INFO
    }
}


pub const AIFFWRITERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AiffWriterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AiffWriterNodeData-Array"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, PartialEq, Eq, Default, Debug)]
#[repr(i32)]
pub enum PanNormalizationMode {
    #[default]
    PanNormalizationMode_One = 0,
    PanNormalizationMode_InputChannelCount = 1,
    PanNormalizationMode_SqrtInputChannelCount = 2,
}

pub const PANNORMALIZATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanNormalizationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PANNORMALIZATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PanNormalizationMode {
    fn type_info() -> &'static TypeInfo {
        PANNORMALIZATIONMODE_TYPE_INFO
    }
}


pub const PANNORMALIZATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanNormalizationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PanNormalizationMode-Array"),
    array_type: None,
    alignment: 8,
};


