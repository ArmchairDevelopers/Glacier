use std::{mem::offset_of, any::Any, option::Option, sync::Arc};
use tokio::sync::Mutex;

use glacier_reflect::{
    member::MemberInfoFlags,
    type_info::{
        ClassInfoData, ValueTypeInfoData, FieldInfoData, TypeInfo, TypeInfoData, TypeObject, TypeFunctions,
    }, type_registry::TypeRegistry,
};

pub(crate) fn register_audio_types(registry: &mut TypeRegistry) {
    registry.register_type(SOUNDMASTERENTITY_TYPE_INFO);
    registry.register_type(SOUNDMASTERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITY_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITY_TYPE_INFO);
    registry.register_type(SOUNDENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITY_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITY_ARRAY_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITY_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITY_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBENTITY_TYPE_INFO);
    registry.register_type(IRREVERBENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACK_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACK_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYER_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYER_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYER_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYER_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITY_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTITY_TYPE_INFO);
    registry.register_type(MIXERENTITY_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVERESOURCE_TYPE_INFO);
    registry.register_type(NEWWAVERESOURCE_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEREPORTINGASSET_TYPE_INFO);
    registry.register_type(NEWWAVEREPORTINGASSET_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEDEBUGASSET_TYPE_INFO);
    registry.register_type(NEWWAVEDEBUGASSET_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEVARIATIONDEBUGDATA_TYPE_INFO);
    registry.register_type(NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOCALIZEDWAVEASSET_TYPE_INFO);
    registry.register_type(LOCALIZEDWAVEASSET_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEASSET_TYPE_INFO);
    registry.register_type(NEWWAVEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSET_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSETBASE_TYPE_INFO);
    registry.register_type(SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVESTREAMINGMODE_TYPE_INFO);
    registry.register_type(SOUNDWAVESTREAMINGMODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVELOCALIZATIONINFO_TYPE_INFO);
    registry.register_type(SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVERUNTIMEVARIATION_TYPE_INFO);
    registry.register_type(SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATION_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVESUBTITLE_TYPE_INFO);
    registry.register_type(SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSEGMENT_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSELECTION_TYPE_INFO);
    registry.register_type(SOUNDWAVEVARIATIONSELECTION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVOICEPRIORITY_TYPE_INFO);
    registry.register_type(SOUNDWAVEVOICEPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAASSET_TYPE_INFO);
    registry.register_type(SOUNDDATAASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAPOLICY_TYPE_INFO);
    registry.register_type(SOUNDDATAPOLICY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREADTARGET_TYPE_INFO);
    registry.register_type(SOUNDDATAREADTARGET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATARELEASEBEHAVIOR_TYPE_INFO);
    registry.register_type(SOUNDDATARELEASEBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATACHUNK_TYPE_INFO);
    registry.register_type(SOUNDDATACHUNK_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATASTATE_TYPE_INFO);
    registry.register_type(SOUNDDATASTATE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTRESULT_TYPE_INFO);
    registry.register_type(SOUNDDATAREQUESTRESULT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAPRIMERESULT_TYPE_INFO);
    registry.register_type(SOUNDDATAPRIMERESULT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREADPRIORITY_TYPE_INFO);
    registry.register_type(SOUNDDATAREADPRIORITY_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSYSTEMASSET_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPTYPE_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTGROUPTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTINTERACTIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(PRIORITYSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(LOGICSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(ORDERSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO);
    registry.register_type(MATHSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(SPATIALSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKEDSOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(LINKEDSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTBINDINGDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(OBSTRUCTIONSOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(EVENTSOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUESOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(VALUESOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOSETTINGS_TYPE_INFO);
    registry.register_type(AUDIOSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONASSET_TYPE_INFO);
    registry.register_type(SOUNDPATCHCONFIGURATIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(SCOPECOLLECTIONASSET_TYPE_INFO);
    registry.register_type(SCOPECOLLECTIONASSET_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMASSET_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLMAPPING_TYPE_INFO);
    registry.register_type(STREAMPOOLMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLPRESET_TYPE_INFO);
    registry.register_type(STREAMPOOLPRESET_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGESETTING_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGEMAPPING_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHASSET_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDMASTERPATCHASSET_TYPE_INFO);
    registry.register_type(SOUNDMASTERPATCHASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHBASEASSET_TYPE_INFO);
    registry.register_type(SOUNDBUSPATCHBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHASSET_TYPE_INFO);
    registry.register_type(SOUNDPATCHASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHDEFAULTEVENT_TYPE_INFO);
    registry.register_type(SOUNDPATCHDEFAULTEVENT_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPATCHPUBLICNODE_TYPE_INFO);
    registry.register_type(SOUNDPATCHPUBLICNODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHASSET_TYPE_INFO);
    registry.register_type(SOUNDGRAPHASSET_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOMATERIALDEFINITIONS_TYPE_INFO);
    registry.register_type(AUDIOMATERIALDEFINITIONS_ARRAY_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEASSET_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEASSET_ARRAY_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEBLOCKSIZE_TYPE_INFO);
    registry.register_type(IMPULSERESPONSEBLOCKSIZE_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUP_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPBEHAVIOR_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO);
    registry.register_type(NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOL_TYPE_INFO);
    registry.register_type(STREAMPOOL_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLSETUP_TYPE_INFO);
    registry.register_type(STREAMPOOLSETUP_ARRAY_TYPE_INFO);
    registry.register_type(STREAMPOOLPROPERTIES_TYPE_INFO);
    registry.register_type(STREAMPOOLPROPERTIES_ARRAY_TYPE_INFO);
    registry.register_type(STREAMSTARVEMODE_TYPE_INFO);
    registry.register_type(STREAMSTARVEMODE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDASSET_TYPE_INFO);
    registry.register_type(SOUNDASSET_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAREFERENCE_TYPE_INFO);
    registry.register_type(SOUNDDATAREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSYSTEMASSET_TYPE_INFO);
    registry.register_type(MIXERSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(MIXERASSET_TYPE_INFO);
    registry.register_type(MIXERASSET_ARRAY_TYPE_INFO);
    registry.register_type(MIXERGRAPHDATA_TYPE_INFO);
    registry.register_type(MIXERGRAPHDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERINPUTINFO_TYPE_INFO);
    registry.register_type(MIXERINPUTINFO_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEACCUMULATEMODE_TYPE_INFO);
    registry.register_type(MIXERVALUEACCUMULATEMODE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERPRESET_TYPE_INFO);
    registry.register_type(MIXERPRESET_ARRAY_TYPE_INFO);
    registry.register_type(MIXERPRESETNODEDATA_TYPE_INFO);
    registry.register_type(MIXERPRESETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERPRESETGROUPDATA_TYPE_INFO);
    registry.register_type(MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYVALUE_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYTYPE_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUP_TYPE_INFO);
    registry.register_type(MIXGROUP_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYPARAMETERS_TYPE_INFO);
    registry.register_type(MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO);
    registry.register_type(MIXGROUPSTATE_TYPE_INFO);
    registry.register_type(MIXGROUPSTATE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUENODEDATA_TYPE_INFO);
    registry.register_type(MIXERVALUENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEUISCALE_TYPE_INFO);
    registry.register_type(MIXERVALUEUISCALE_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEUIORIENTATION_TYPE_INFO);
    registry.register_type(MIXERVALUEUIORIENTATION_ARRAY_TYPE_INFO);
    registry.register_type(MIXERVALUEUI_TYPE_INFO);
    registry.register_type(MIXERVALUEUI_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSENDNODECONFIGDATA_TYPE_INFO);
    registry.register_type(MIXERSENDNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODECONFIGDATA_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTRYCONFIG_TYPE_INFO);
    registry.register_type(MIXERENTRYCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSENDNODEDATA_TYPE_INFO);
    registry.register_type(MIXERSENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSENDENTRY_TYPE_INFO);
    registry.register_type(MIXERSENDENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODEDATA_TYPE_INFO);
    registry.register_type(MIXERRECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERRECEIVEENTRY_TYPE_INFO);
    registry.register_type(MIXERRECEIVEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYNODEDATA_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYENTRY_TYPE_INFO);
    registry.register_type(MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYNODEDATA_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYENTRY_TYPE_INFO);
    registry.register_type(MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERSIMPLEPRESETNODEDATA_TYPE_INFO);
    registry.register_type(MIXERSIMPLEPRESETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXEROUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(MIXEROUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXEROUTPUTENTRY_TYPE_INFO);
    registry.register_type(MIXEROUTPUTENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MIXERINPUTNODEDATA_TYPE_INFO);
    registry.register_type(MIXERINPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERINPUTENTRY_TYPE_INFO);
    registry.register_type(MIXERINPUTENTRY_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHVALUEPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHVALUEPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEDATA_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORTGROUP_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORT_TYPE_INFO);
    registry.register_type(AUDIOGRAPHNODEPORT_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETER_TYPE_INFO);
    registry.register_type(AUDIOGRAPHENUMERATIONPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETER_TYPE_INFO);
    registry.register_type(AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHEVENT_TYPE_INFO);
    registry.register_type(AUDIOGRAPHEVENT_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETER_TYPE_INFO);
    registry.register_type(AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(VALUECURVENODEDATA_TYPE_INFO);
    registry.register_type(VALUECURVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUECURVENODEENTRY_TYPE_INFO);
    registry.register_type(VALUECURVENODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLEANDHOLDNODEDATA_TYPE_INFO);
    registry.register_type(SAMPLEANDHOLDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERROUTERNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERROUTERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERROUTERENTRY_TYPE_INFO);
    registry.register_type(PARAMETERROUTERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(KEEPALIVENODEDATA_TYPE_INFO);
    registry.register_type(KEEPALIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEDATA_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCEROUTEVENT_TYPE_INFO);
    registry.register_type(EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERPLAYBACK_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERPLAYBACK_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEVERSION_TYPE_INFO);
    registry.register_type(EVENTSEQUENCERNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(VALUESELECTORNODEDATA_TYPE_INFO);
    registry.register_type(VALUESELECTORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VALUESELECTORENTRY_TYPE_INFO);
    registry.register_type(VALUESELECTORENTRY_ARRAY_TYPE_INFO);
    registry.register_type(TIMERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(TIMERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(TIMERNODEDATA_TYPE_INFO);
    registry.register_type(TIMERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROGRESSMODE_TYPE_INFO);
    registry.register_type(PROGRESSMODE_ARRAY_TYPE_INFO);
    registry.register_type(TIMERMODE_TYPE_INFO);
    registry.register_type(TIMERMODE_ARRAY_TYPE_INFO);
    registry.register_type(TIMERNODEVERSION_TYPE_INFO);
    registry.register_type(TIMERNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHERNODEDATA_TYPE_INFO);
    registry.register_type(SWITCHERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SWITCHERENTRY_TYPE_INFO);
    registry.register_type(SWITCHERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODECONFIGDATA_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODEDATA_TYPE_INFO);
    registry.register_type(SIMPLEVALUESELECTORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMNODEDATA_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMENTRY_TYPE_INFO);
    registry.register_type(MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMNODEDATA_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ANGLEUNIT_TYPE_INFO);
    registry.register_type(ANGLEUNIT_ARRAY_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMOPERATION_TYPE_INFO);
    registry.register_type(SIMPLETRANSFORMOPERATION_ARRAY_TYPE_INFO);
    registry.register_type(SEQUENCEGENERATORNODEDATA_TYPE_INFO);
    registry.register_type(SEQUENCEGENERATORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENDNODEDATA_TYPE_INFO);
    registry.register_type(SENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SENDENTRY_TYPE_INFO);
    registry.register_type(SENDENTRY_ARRAY_TYPE_INFO);
    registry.register_type(SCALECLAMPNODECONFIGDATA_TYPE_INFO);
    registry.register_type(SCALECLAMPNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SCALECLAMPNODEDATA_TYPE_INFO);
    registry.register_type(SCALECLAMPNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTSENDNODEDATA_TYPE_INFO);
    registry.register_type(CONTEXTSENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSENDENTRY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO);
    registry.register_type(CONTEXTRECEIVENODEDATA_TYPE_INFO);
    registry.register_type(CONTEXTRECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTRECEIVEENTRY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(RECEIVENODEDATA_TYPE_INFO);
    registry.register_type(RECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RECEIVEENTRY_TYPE_INFO);
    registry.register_type(RECEIVEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERCONFIGENTRY_TYPE_INFO);
    registry.register_type(RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODEDATA_TYPE_INFO);
    registry.register_type(RANGEMAPPERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(RANGEMAPPERENTRY_TYPE_INFO);
    registry.register_type(RANGEMAPPERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLINEARNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLINEARNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEVERSION_TYPE_INFO);
    registry.register_type(PARAMETERFILTERLPNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEDATA_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEENTRY_TYPE_INFO);
    registry.register_type(PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODECONFIGDATA_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEDATA_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORMODE_TYPE_INFO);
    registry.register_type(NUMBERGENERATORMODE_ARRAY_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEVERSION_TYPE_INFO);
    registry.register_type(NUMBERGENERATORNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERCONFIGGROUP_TYPE_INFO);
    registry.register_type(MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODEDATA_TYPE_INFO);
    registry.register_type(MULTICROSSFADERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTICROSSFADERGROUP_TYPE_INFO);
    registry.register_type(MULTICROSSFADERGROUP_ARRAY_TYPE_INFO);
    registry.register_type(FADERTYPE_TYPE_INFO);
    registry.register_type(FADERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORNODEDATA_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORENTRY_TYPE_INFO);
    registry.register_type(MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MINMAXNODEDATA_TYPE_INFO);
    registry.register_type(MINMAXNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONNODEDATA_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONOPERATOR_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONOPERATOR_ARRAY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONENTRY_TYPE_INFO);
    registry.register_type(LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDNODEDATA_TYPE_INFO);
    registry.register_type(LINKSENDNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKSENDNODEENTRY_TYPE_INFO);
    registry.register_type(LINKSENDNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEDATA_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEENTRY_TYPE_INFO);
    registry.register_type(LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(LINEARTRANSFORMNODEDATA_TYPE_INFO);
    registry.register_type(LINEARTRANSFORMNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LFONODEDATA_TYPE_INFO);
    registry.register_type(LFONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLLOWENVELOPENODEDATA_TYPE_INFO);
    registry.register_type(FOLLOWENVELOPENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHERNODEDATA_TYPE_INFO);
    registry.register_type(EVENTSWITCHERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTSWITCHERENTRY_TYPE_INFO);
    registry.register_type(EVENTSWITCHERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(EVENTGATENODEDATA_TYPE_INFO);
    registry.register_type(EVENTGATENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEDATA_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEENTRY_TYPE_INFO);
    registry.register_type(EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(DEMUXNODEDATA_TYPE_INFO);
    registry.register_type(DEMUXNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEMUXOUTPUT_TYPE_INFO);
    registry.register_type(DEMUXOUTPUT_ARRAY_TYPE_INFO);
    registry.register_type(DELTANODEDATA_TYPE_INFO);
    registry.register_type(DELTANODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELTAGROUP_TYPE_INFO);
    registry.register_type(DELTAGROUP_ARRAY_TYPE_INFO);
    registry.register_type(EVENTDEBUGNODEDATA_TYPE_INFO);
    registry.register_type(EVENTDEBUGNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGEVENTINPUT_TYPE_INFO);
    registry.register_type(DEBUGEVENTINPUT_ARRAY_TYPE_INFO);
    registry.register_type(VALUEDEBUGNODEDATA_TYPE_INFO);
    registry.register_type(VALUEDEBUGNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGVALUEINPUT_TYPE_INFO);
    registry.register_type(DEBUGVALUEINPUT_ARRAY_TYPE_INFO);
    registry.register_type(DEBUGRENDERTYPE_TYPE_INFO);
    registry.register_type(DEBUGRENDERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(CROSSFADER2NODEDATA_TYPE_INFO);
    registry.register_type(CROSSFADER2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONNODECONFIGDATA_TYPE_INFO);
    registry.register_type(CONDITIONNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONGROUPCONFIG_TYPE_INFO);
    registry.register_type(CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONNODEDATA_TYPE_INFO);
    registry.register_type(CONDITIONNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONGROUP_TYPE_INFO);
    registry.register_type(CONDITIONGROUP_ARRAY_TYPE_INFO);
    registry.register_type(CONDITIONTYPE_TYPE_INFO);
    registry.register_type(CONDITIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(ADSRNODEDATA_TYPE_INFO);
    registry.register_type(ADSRNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELTOVALUENODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELTOVALUENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERSYSTEMASSET_TYPE_INFO);
    registry.register_type(VOICEOVERSYSTEMASSET_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELARRAY_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATION_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO);
    registry.register_type(VOICEOVERPRONUNCIATIONFALLBACK_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_ARRAY_TYPE_INFO);
    registry.register_type(FINALDRAFTMANUSCRIPTASSET_TYPE_INFO);
    registry.register_type(FINALDRAFTMANUSCRIPTASSET_ARRAY_TYPE_INFO);
    registry.register_type(FINALDRAFTLINEINFO_TYPE_INFO);
    registry.register_type(FINALDRAFTLINEINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTASSET_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTASSET_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_TYPE_INFO);
    registry.register_type(VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERWAVENAMETRANSLATION_TYPE_INFO);
    registry.register_type(VOICEOVERWAVENAMETRANSLATION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLANGUAGEROOT_TYPE_INFO);
    registry.register_type(VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICASSET_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICASSET_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGROUP_TYPE_INFO);
    registry.register_type(VOICEOVERGROUP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWCONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOW_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINEROUTPUT_TYPE_INFO);
    registry.register_type(VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERPARAMETER_TYPE_INFO);
    registry.register_type(VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODE_TYPE_INFO);
    registry.register_type(VOICEOVEREVENTNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINFO_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONQUEUEMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONINTERRUPTMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGGROUP_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGOUTPUTEVENT_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETER_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTRACK_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEBEHAVIOR_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEMAPPING_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIP_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGCLIPEVENTS_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKE_TYPE_INFO);
    registry.register_type(VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONTAINERCONDITIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURENODE_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWMODE_TYPE_INFO);
    registry.register_type(VOICEOVERLOGICFLOWMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODE_TYPE_INFO);
    registry.register_type(VOICEOVERVARIABLENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODE_TYPE_INFO);
    registry.register_type(VOICEOVERPROBABILITYNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELCOMPAREMODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELCOMPAREMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCEMODE_TYPE_INFO);
    registry.register_type(VOICEOVERLABELSOURCEMODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODE_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODE_TYPE_INFO);
    registry.register_type(VOICEOVERINFONODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODE_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODE_TYPE_INFO);
    registry.register_type(VOICEOVERDISTANCENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODE_TYPE_INFO);
    registry.register_type(VOICEOVERDEBUGVALUENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVECTORVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVECTORVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTGLOBALVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTGLOBALVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTFLOATVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTFLOATVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTINTEGERVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTINTEGERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTBOOLEANVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTBOOLEANVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERCONSTANTVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODE_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPARENODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO);
    registry.register_type(VOICEOVERCOMPAREEXPRESSIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODE_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO);
    registry.register_type(VOICEOVERARITHMETICEXPRESSIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURECONNECTION_TYPE_INFO);
    registry.register_type(VOICEOVERSTRUCTURECONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERRELATIONSHIPINPUT_TYPE_INFO);
    registry.register_type(VOICEOVERRELATIONSHIPINPUT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUECONNECTION_TYPE_INFO);
    registry.register_type(VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREXPRESSIONNODE_TYPE_INFO);
    registry.register_type(VOICEOVEREXPRESSIONNODE_ARRAY_TYPE_INFO);
    registry.register_type(ENTITYVOICEOVERINFO_TYPE_INFO);
    registry.register_type(ENTITYVOICEOVERINFO_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVAL_TYPE_INFO);
    registry.register_type(VOICEOVERINTERVAL_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERLABEL_TYPE_INFO);
    registry.register_type(VOICEOVERLABEL_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUEREDIRECT_TYPE_INFO);
    registry.register_type(VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERNODE_TYPE_INFO);
    registry.register_type(VOICEOVERNODE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEREVENT_TYPE_INFO);
    registry.register_type(VOICEOVEREVENT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECT_TYPE_INFO);
    registry.register_type(VOICEOVEROBJECT_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERNAMEDVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUE_TYPE_INFO);
    registry.register_type(VOICEOVERVALUE_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERVALUETYPE_TYPE_INFO);
    registry.register_type(VOICEOVERVALUETYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(MUSICPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICLAYERENTRY_TYPE_INFO);
    registry.register_type(MUSICLAYERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERENTRY_TYPE_INFO);
    registry.register_type(MUSICPLAYERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDVOICE_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDTARGETPLUGINS_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDPLUGINS_TYPE_INFO);
    registry.register_type(MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYERPLUGINS_TYPE_INFO);
    registry.register_type(MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(LOADINGMUSICBUNDLEASSET_TYPE_INFO);
    registry.register_type(LOADINGMUSICBUNDLEASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICMARKERTYPE_TYPE_INFO);
    registry.register_type(MUSICMARKERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICFADETYPE_TYPE_INFO);
    registry.register_type(MUSICFADETYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTASSET_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTSELECTOR_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTTYPE_TYPE_INFO);
    registry.register_type(MUSICPLAYLISTTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICASSET_TYPE_INFO);
    registry.register_type(MUSICASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICBASEASSET_TYPE_INFO);
    registry.register_type(MUSICBASEASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICTRANSITION_TYPE_INFO);
    registry.register_type(MUSICTRANSITION_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTORPARAMETER_TYPE_INFO);
    registry.register_type(MUSICSELECTORPARAMETER_ARRAY_TYPE_INFO);
    registry.register_type(PARAMETERBOUNDSELECTOR_TYPE_INFO);
    registry.register_type(PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTOR_TYPE_INFO);
    registry.register_type(MUSICSELECTOR_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTORBASE_TYPE_INFO);
    registry.register_type(MUSICSELECTORBASE_ARRAY_TYPE_INFO);
    registry.register_type(OVERLAYCONTROL_TYPE_INFO);
    registry.register_type(OVERLAYCONTROL_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSELECTORTRIGGERTYPE_TYPE_INFO);
    registry.register_type(MUSICSELECTORTRIGGERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICINTERFACEASSET_TYPE_INFO);
    registry.register_type(MUSICINTERFACEASSET_ARRAY_TYPE_INFO);
    registry.register_type(MUSICOVERLAYDATA_TYPE_INFO);
    registry.register_type(MUSICOVERLAYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICOVERLAYVARIATION_TYPE_INFO);
    registry.register_type(MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPHRASEDATA_TYPE_INFO);
    registry.register_type(MUSICPHRASEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSEGMENTDATA_TYPE_INFO);
    registry.register_type(MUSICSEGMENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTITRACKDATA_TYPE_INFO);
    registry.register_type(MULTITRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(MULTITRACKLAYERDATA_TYPE_INFO);
    registry.register_type(MULTITRACKLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SYNCHEDFADEDATA_TYPE_INFO);
    registry.register_type(SYNCHEDFADEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BASICFADEDATA_TYPE_INFO);
    registry.register_type(BASICFADEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICFADEDATA_TYPE_INFO);
    registry.register_type(MUSICFADEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSYNCTYPE_TYPE_INFO);
    registry.register_type(MUSICSYNCTYPE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICSTREAMABLEDATA_TYPE_INFO);
    registry.register_type(MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPLAYABLEDATA_TYPE_INFO);
    registry.register_type(MUSICPLAYABLEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICMETADATACHANGEDMESSAGE_TYPE_INFO);
    registry.register_type(MUSICMETADATABASE_TYPE_INFO);
    registry.register_type(MUSICMETADATABASE_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPARAMETERDATA_TYPE_INFO);
    registry.register_type(MUSICPARAMETERDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICEVENTDATA_TYPE_INFO);
    registry.register_type(MUSICEVENTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICINPUTDATA_TYPE_INFO);
    registry.register_type(MUSICINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(MUSICPHRASESELECTIONTYPE_TYPE_INFO);
    registry.register_type(MUSICPHRASESELECTIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTLINKENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDCONTEXTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTITYDATA_TYPE_INFO);
    registry.register_type(MIXERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITYDATA_TYPE_INFO);
    registry.register_type(LOADINGMUSICENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDPAUSEENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDHDRENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBENTITYDATA_TYPE_INFO);
    registry.register_type(IRREVERBENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITYDATA_TYPE_INFO);
    registry.register_type(VOICEOVERCONVERSATIONGROUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDDATAENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDMASTERENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDMASTERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDEFFECTENTITYDATA_TYPE_INFO);
    registry.register_type(SOUNDEFFECTENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKPARAMETERLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKTRANSFORMLAYERDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKTRANSFORMLAYERDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO);
    registry.register_type(SOUNDENTITYTRACKKEYFRAMEDATA_ARRAY_TYPE_INFO);
    registry.register_type(NEWWAVEASSETOBSERVERENTITYDATA_TYPE_INFO);
    registry.register_type(NEWWAVEASSETOBSERVERENTITYDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO);
    registry.register_type(PROPERTYSORTSCOPESTAGEORDER_ARRAY_TYPE_INFO);
    registry.register_type(SCOPESTAGESORTPROPERTY_TYPE_INFO);
    registry.register_type(SCOPESTAGESORTPROPERTY_ARRAY_TYPE_INFO);
    registry.register_type(DUPLICATESPAWNSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(DUPLICATESPAWNSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MAXINSTANCESSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(MAXINSTANCESSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYMAPPING_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTAGEDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEINPUTDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDSCOPEDATA_TYPE_INFO);
    registry.register_type(SOUNDSCOPEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EQUALIZERSETTINGS_TYPE_INFO);
    registry.register_type(EQUALIZERSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(COMPRESSORSETTINGS_TYPE_INFO);
    registry.register_type(COMPRESSORSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(MASTERUNITSETTINGS_TYPE_INFO);
    registry.register_type(MASTERUNITSETTINGS_ARRAY_TYPE_INFO);
    registry.register_type(HDRSETTING_TYPE_INFO);
    registry.register_type(HDRSETTING_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHDATA_TYPE_INFO);
    registry.register_type(SOUNDGRAPHDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDBUSDATA_TYPE_INFO);
    registry.register_type(SOUNDBUSDATA_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHINFO_TYPE_INFO);
    registry.register_type(SOUNDGRAPHINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHVOICEINFO_TYPE_INFO);
    registry.register_type(SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHLINKEDPLUGINATTRIBUTE_TYPE_INFO);
    registry.register_type(SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGININFO_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINREF_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONSTRUCTPARAM_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTION_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONTYPE_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONTYPE_ARRAY_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONPARAM_TYPE_INFO);
    registry.register_type(SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO);
    registry.register_type(FADECURVETYPE_TYPE_INFO);
    registry.register_type(FADECURVETYPE_ARRAY_TYPE_INFO);
    registry.register_type(POINTENVELOPE_TYPE_INFO);
    registry.register_type(POINTENVELOPE_ARRAY_TYPE_INFO);
    registry.register_type(POINTENVELOPEPOINT_TYPE_INFO);
    registry.register_type(POINTENVELOPEPOINT_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGE_TYPE_INFO);
    registry.register_type(AUDIOLANGUAGE_ARRAY_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMSPEAKERSETUP_TYPE_INFO);
    registry.register_type(AUDIOSYSTEMSPEAKERSETUP_ARRAY_TYPE_INFO);
    registry.register_type(BEATDETECTNODEDATA_TYPE_INFO);
    registry.register_type(BEATDETECTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BEATDETECTCAUSALITY_TYPE_INFO);
    registry.register_type(BEATDETECTCAUSALITY_ARRAY_TYPE_INFO);
    registry.register_type(BEATDETECTFRAMESIZE_TYPE_INFO);
    registry.register_type(BEATDETECTFRAMESIZE_ARRAY_TYPE_INFO);
    registry.register_type(MODELREVERBNODEDATA_TYPE_INFO);
    registry.register_type(MODELREVERBNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ACTIVATEMIXERNODEDATA_TYPE_INFO);
    registry.register_type(ACTIVATEMIXERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VUMETERNODEDATA_TYPE_INFO);
    registry.register_type(VUMETERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(VUMETERMODE_TYPE_INFO);
    registry.register_type(VUMETERMODE_ARRAY_TYPE_INFO);
    registry.register_type(VIBRATONODEDATA_TYPE_INFO);
    registry.register_type(VIBRATONODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODEDATA_TYPE_INFO);
    registry.register_type(WAVESWITCHERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEDATA_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYWAVEASSETREFERENCE_TYPE_INFO);
    registry.register_type(WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRYTYPE_TYPE_INFO);
    registry.register_type(WAVEQUERYNODEPARAMETERENTRYTYPE_ARRAY_TYPE_INFO);
    registry.register_type(WAVEQUERYCONSTENUM_TYPE_INFO);
    registry.register_type(WAVEQUERYCONSTENUM_ARRAY_TYPE_INFO);
    registry.register_type(VARIATIONSELECTIONOBSERVERNODEDATA_TYPE_INFO);
    registry.register_type(VARIATIONSELECTIONOBSERVERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(USERMUSICCONTROLLERNODEDATA_TYPE_INFO);
    registry.register_type(USERMUSICCONTROLLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(USERMUSICARBITERNODEDATA_TYPE_INFO);
    registry.register_type(USERMUSICARBITERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TIMESTRETCHNODEDATA_TYPE_INFO);
    registry.register_type(TIMESTRETCHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(TIMESTRETCHEFFICIENCY_TYPE_INFO);
    registry.register_type(TIMESTRETCHEFFICIENCY_ARRAY_TYPE_INFO);
    registry.register_type(TIMESTRETCHMULTICHANNELMODE_TYPE_INFO);
    registry.register_type(TIMESTRETCHMULTICHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODECONFIGDATA_TYPE_INFO);
    registry.register_type(SAMPLERNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODEDATA_TYPE_INFO);
    registry.register_type(SAMPLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODEDEBUGDATA_TYPE_INFO);
    registry.register_type(SAMPLERNODEDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERPOSITIONMODE_TYPE_INFO);
    registry.register_type(SAMPLERPOSITIONMODE_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLEROFFSETMODE_TYPE_INFO);
    registry.register_type(SAMPLEROFFSETMODE_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERLEADOUT_TYPE_INFO);
    registry.register_type(SAMPLERLEADOUT_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERPLUGINS_TYPE_INFO);
    registry.register_type(SAMPLERPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(SAMPLERNODEVERSION_TYPE_INFO);
    registry.register_type(SAMPLERNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(ROUTENODEDATA_TYPE_INFO);
    registry.register_type(ROUTENODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ROUTEENTRY_TYPE_INFO);
    registry.register_type(ROUTEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(ROUTECHANNEL_TYPE_INFO);
    registry.register_type(ROUTECHANNEL_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBCONTROLLERNODEDATA_TYPE_INFO);
    registry.register_type(IRREVERBCONTROLLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(IRREVERBNODEDATA_TYPE_INFO);
    registry.register_type(IRREVERBNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PLATFORMFOLDDOWNNODEDATA_TYPE_INFO);
    registry.register_type(PLATFORMFOLDDOWNNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FOLDDOWNMODE_TYPE_INFO);
    registry.register_type(FOLDDOWNMODE_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSNODEDATA_TYPE_INFO);
    registry.register_type(PHYSICSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PAN2DNODEDATA_TYPE_INFO);
    registry.register_type(PAN2DNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PAN2DNODEVERSION_TYPE_INFO);
    registry.register_type(PAN2DNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO);
    registry.register_type(PAN2DOUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO);
    registry.register_type(PHYSICSENTRY_TYPE_INFO);
    registry.register_type(PHYSICSENTRY_ARRAY_TYPE_INFO);
    registry.register_type(PEAKINGIIR2NODEDATA_TYPE_INFO);
    registry.register_type(PEAKINGIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEDATA_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEENTRY_TYPE_INFO);
    registry.register_type(ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(OBJECTOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(CONEOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(FLATOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PANSOURCEPOSITIONING_TYPE_INFO);
    registry.register_type(PANSOURCEPOSITIONING_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTREVERBMODE_TYPE_INFO);
    registry.register_type(OUTPUTREVERBMODE_ARRAY_TYPE_INFO);
    registry.register_type(DIRECTOUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(DIRECTOUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTNODECONFIGDATA_TYPE_INFO);
    registry.register_type(OUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(OUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTNODEVERSION_TYPE_INFO);
    registry.register_type(OUTPUTNODEVERSION_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSFILTERTYPE_TYPE_INFO);
    registry.register_type(LOWPASSFILTERTYPE_ARRAY_TYPE_INFO);
    registry.register_type(OUTPUTTRANSFORMSOURCE_TYPE_INFO);
    registry.register_type(OUTPUTTRANSFORMSOURCE_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTSNODEDATA_TYPE_INFO);
    registry.register_type(OBJECTSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(OBJECTNODEDATA_TYPE_INFO);
    registry.register_type(OBJECTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERNODEDATA_TYPE_INFO);
    registry.register_type(MIXERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MIXERENTRY_TYPE_INFO);
    registry.register_type(MIXERENTRY_ARRAY_TYPE_INFO);
    registry.register_type(MATRIXPANNERNODEDATA_TYPE_INFO);
    registry.register_type(MATRIXPANNERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO);
    registry.register_type(MATRIXPANNEROUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO);
    registry.register_type(MASTERUNITNODEDATA_TYPE_INFO);
    registry.register_type(MASTERUNITNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWSHELFIIR2NODEDATA_TYPE_INFO);
    registry.register_type(LOWSHELFIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSIIR2NODEDATA_TYPE_INFO);
    registry.register_type(LOWPASSIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSFIR64NODEDATA_TYPE_INFO);
    registry.register_type(LOWPASSFIR64NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LOWPASSBUTTERWORTHNODEDATA_TYPE_INFO);
    registry.register_type(LOWPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIMITERNODEDATA_TYPE_INFO);
    registry.register_type(LIMITERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(LIMITERCHANNELMODE_TYPE_INFO);
    registry.register_type(LIMITERCHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(HIGHSHELFIIR2NODEDATA_TYPE_INFO);
    registry.register_type(HIGHSHELFIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHPASSIIR2NODEDATA_TYPE_INFO);
    registry.register_type(HIGHPASSIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHPASSFIR64NODEDATA_TYPE_INFO);
    registry.register_type(HIGHPASSFIR64NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(HIGHPASSBUTTERWORTHNODEDATA_TYPE_INFO);
    registry.register_type(HIGHPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(SINEPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(SINEPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAINFADERNODEDATA_TYPE_INFO);
    registry.register_type(GAINFADERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(GAINFADERFADETYPE_TYPE_INFO);
    registry.register_type(GAINFADERFADETYPE_ARRAY_TYPE_INFO);
    registry.register_type(GAINNODEDATA_TYPE_INFO);
    registry.register_type(GAINNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBNODEDATA_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBFILTER_TYPE_INFO);
    registry.register_type(FREQUENCYSHIFTSSBFILTER_ARRAY_TYPE_INFO);
    registry.register_type(FLANGERNODEDATA_TYPE_INFO);
    registry.register_type(FLANGERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ENVIRONMENTNODEDATA_TYPE_INFO);
    registry.register_type(ENVIRONMENTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDATA_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERPLUGINS_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO);
    registry.register_type(DIVISIBLELOOPPLAYERNODEDEBUGDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPANDERNODEDATA_TYPE_INFO);
    registry.register_type(EXPANDERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(EXPANDERCHANNELMODE_TYPE_INFO);
    registry.register_type(EXPANDERCHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(DISTORTIONCLIPNODEDATA_TYPE_INFO);
    registry.register_type(DISTORTIONCLIPNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DIALOGSAMPLERNODEDATA_TYPE_INFO);
    registry.register_type(DIALOGSAMPLERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DELAYNODEDATA_TYPE_INFO);
    registry.register_type(DELAYNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(DACNODEDATA_TYPE_INFO);
    registry.register_type(DACNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CROSSFADERNODEDATA_TYPE_INFO);
    registry.register_type(CROSSFADERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(CONTROLLEROUTPUTNODEDATA_TYPE_INFO);
    registry.register_type(CONTROLLEROUTPUTNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPRESSORNODEDATA_TYPE_INFO);
    registry.register_type(COMPRESSORNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(COMPRESSORCHANNELMODE_TYPE_INFO);
    registry.register_type(COMPRESSORCHANNELMODE_ARRAY_TYPE_INFO);
    registry.register_type(CHORUSNODEDATA_TYPE_INFO);
    registry.register_type(CHORUSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BUSNODEDATA_TYPE_INFO);
    registry.register_type(BUSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANDPASSIIR2NODEDATA_TYPE_INFO);
    registry.register_type(BANDPASSIIR2NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(BANDPASSFIR64NODEDATA_TYPE_INFO);
    registry.register_type(BANDPASSFIR64NODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(ALLPASSNODEDATA_TYPE_INFO);
    registry.register_type(ALLPASSNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(AIFFWRITERNODEDATA_TYPE_INFO);
    registry.register_type(AIFFWRITERNODEDATA_ARRAY_TYPE_INFO);
    registry.register_type(PANNORMALIZATIONMODE_TYPE_INFO);
    registry.register_type(PANNORMALIZATIONMODE_ARRAY_TYPE_INFO);
}

#[derive(Clone, Debug, Default)]
pub struct SoundMasterEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundMasterEntityTrait: super::entity::EntityTrait {
}

impl SoundMasterEntityTrait for SoundMasterEntity {
}

impl super::entity::EntityTrait for SoundMasterEntity {
}

impl super::entity::EntityBusPeerTrait for SoundMasterEntity {
}

pub static SOUNDMASTERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundMasterEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDMASTERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundMasterEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDMASTERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDMASTERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundMasterEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundHdrEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundHdrEntityTrait: super::entity::EntityTrait {
}

impl SoundHdrEntityTrait for SoundHdrEntity {
}

impl super::entity::EntityTrait for SoundHdrEntity {
}

impl super::entity::EntityBusPeerTrait for SoundHdrEntity {
}

pub static SOUNDHDRENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundHdrEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDHDRENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundHdrEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDHDRENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDHDRENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundHdrEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundEntityTrait: super::entity::EntityTrait {
}

impl SoundEntityTrait for SoundEntity {
}

impl super::entity::EntityTrait for SoundEntity {
}

impl super::entity::EntityBusPeerTrait for SoundEntity {
}

pub static SOUNDENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundDataEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundDataEntityTrait: super::entity::EntityTrait {
}

impl SoundDataEntityTrait for SoundDataEntity {
}

impl super::entity::EntityTrait for SoundDataEntity {
}

impl super::entity::EntityBusPeerTrait for SoundDataEntity {
}

pub static SOUNDDATAENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundDataEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDDATAENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundDataEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDDATAENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextLinkEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundContextLinkEntityTrait: super::entity::EntityTrait {
}

impl SoundContextLinkEntityTrait for SoundContextLinkEntity {
}

impl super::entity::EntityTrait for SoundContextLinkEntity {
}

impl super::entity::EntityBusPeerTrait for SoundContextLinkEntity {
}

pub static SOUNDCONTEXTLINKENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextLinkEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTLINKENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundContextLinkEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTLINKENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTLINKENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextLinkEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundContextEntityTrait: super::entity::EntityTrait {
}

impl SoundContextEntityTrait for SoundContextEntity {
}

impl super::entity::EntityTrait for SoundContextEntity {
}

impl super::entity::EntityBusPeerTrait for SoundContextEntity {
}

pub static SOUNDCONTEXTENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundContextEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LoadingMusicEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait LoadingMusicEntityTrait: super::entity::EntityTrait {
}

impl LoadingMusicEntityTrait for LoadingMusicEntity {
}

impl super::entity::EntityTrait for LoadingMusicEntity {
}

impl super::entity::EntityBusPeerTrait for LoadingMusicEntity {
}

pub static LOADINGMUSICENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LoadingMusicEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOADINGMUSICENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for LoadingMusicEntity {
    fn type_info(&self) -> &'static TypeInfo {
        LOADINGMUSICENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOADINGMUSICENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LoadingMusicEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IrReverbEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait IrReverbEntityTrait: super::entity::EntityTrait {
}

impl IrReverbEntityTrait for IrReverbEntity {
}

impl super::entity::EntityTrait for IrReverbEntity {
}

impl super::entity::EntityBusPeerTrait for IrReverbEntity {
}

pub static IRREVERBENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IrReverbEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(IRREVERBENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for IrReverbEntity {
    fn type_info(&self) -> &'static TypeInfo {
        IRREVERBENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IRREVERBENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrack {
    pub _glacier_base: super::timeline::TimelineTrack,
}

pub trait SoundEntityTrackTrait: super::timeline::TimelineTrackTrait {
}

impl SoundEntityTrackTrait for SoundEntityTrack {
}

impl super::timeline::TimelineTrackTrait for SoundEntityTrack {
}

pub static SOUNDENTITYTRACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrack",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACK_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrack as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACK_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrack {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrack-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrack"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackParameterLayer {
    pub _glacier_base: SoundEntityTrackLayer,
}

pub trait SoundEntityTrackParameterLayerTrait: SoundEntityTrackLayerTrait {
}

impl SoundEntityTrackParameterLayerTrait for SoundEntityTrackParameterLayer {
}

impl SoundEntityTrackLayerTrait for SoundEntityTrackParameterLayer {
}

impl super::timeline::TimelineTrackTrait for SoundEntityTrackParameterLayer {
}

pub static SOUNDENTITYTRACKPARAMETERLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackParameterLayer as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKPARAMETERLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackParameterLayer {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKPARAMETERLAYER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKPARAMETERLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackParameterLayer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackAssetLayer {
    pub _glacier_base: SoundEntityTrackLayer,
}

pub trait SoundEntityTrackAssetLayerTrait: SoundEntityTrackLayerTrait {
}

impl SoundEntityTrackAssetLayerTrait for SoundEntityTrackAssetLayer {
}

impl SoundEntityTrackLayerTrait for SoundEntityTrackAssetLayer {
}

impl super::timeline::TimelineTrackTrait for SoundEntityTrackAssetLayer {
}

pub static SOUNDENTITYTRACKASSETLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackAssetLayer as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKASSETLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackAssetLayer {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKASSETLAYER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKASSETLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackAssetLayer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackEventLayer {
    pub _glacier_base: SoundEntityTrackLayer,
}

pub trait SoundEntityTrackEventLayerTrait: SoundEntityTrackLayerTrait {
}

impl SoundEntityTrackEventLayerTrait for SoundEntityTrackEventLayer {
}

impl SoundEntityTrackLayerTrait for SoundEntityTrackEventLayer {
}

impl super::timeline::TimelineTrackTrait for SoundEntityTrackEventLayer {
}

pub static SOUNDENTITYTRACKEVENTLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackEventLayer as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKEVENTLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackEventLayer {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKEVENTLAYER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKEVENTLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackEventLayer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackLayer {
    pub _glacier_base: super::timeline::TimelineTrack,
}

pub trait SoundEntityTrackLayerTrait: super::timeline::TimelineTrackTrait {
}

impl SoundEntityTrackLayerTrait for SoundEntityTrackLayer {
}

impl super::timeline::TimelineTrackTrait for SoundEntityTrackLayer {
}

pub static SOUNDENTITYTRACKLAYER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayer",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACK_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackLayer as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKLAYER_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundEntityTrackLayer {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKLAYER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKLAYER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayer-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackLayer"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationGroupEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait VoiceOverConversationGroupEntityTrait: super::entity::EntityTrait {
}

impl VoiceOverConversationGroupEntityTrait for VoiceOverConversationGroupEntity {
}

impl super::entity::EntityTrait for VoiceOverConversationGroupEntity {
}

impl super::entity::EntityBusPeerTrait for VoiceOverConversationGroupEntity {
}

pub static VOICEOVERCONVERSATIONGROUPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationGroupEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONGROUPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for VoiceOverConversationGroupEntity {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONGROUPENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONGROUPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationGroupEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeSetupEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundScopeSetupEntityTrait: super::entity::EntityTrait {
}

impl SoundScopeSetupEntityTrait for SoundScopeSetupEntity {
}

impl super::entity::EntityTrait for SoundScopeSetupEntity {
}

impl super::entity::EntityBusPeerTrait for SoundScopeSetupEntity {
}

pub static SOUNDSCOPESETUPENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeSetupEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDSCOPESETUPENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundScopeSetupEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPESETUPENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPESETUPENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeSetupEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundPauseEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait SoundPauseEntityTrait: super::entity::EntityTrait {
}

impl SoundPauseEntityTrait for SoundPauseEntity {
}

impl super::entity::EntityTrait for SoundPauseEntity {
}

impl super::entity::EntityBusPeerTrait for SoundPauseEntity {
}

pub static SOUNDPAUSEENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundPauseEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDPAUSEENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for SoundPauseEntity {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPAUSEENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDPAUSEENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPauseEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerEntity {
    pub _glacier_base: super::entity::Entity,
}

pub trait MixerEntityTrait: super::entity::EntityTrait {
}

impl MixerEntityTrait for MixerEntity {
}

impl super::entity::EntityTrait for MixerEntity {
}

impl super::entity::EntityBusPeerTrait for MixerEntity {
}

pub static MIXERENTITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntity",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITY_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerEntity as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MIXERENTITY_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MixerEntity {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERENTITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERENTITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntity-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntity"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveResource {
}

pub trait NewWaveResourceTrait: TypeObject {
}

impl NewWaveResourceTrait for NewWaveResource {
}

pub static NEWWAVERESOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveResource",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: None,
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveResource as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(NEWWAVERESOURCE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for NewWaveResource {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVERESOURCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NEWWAVERESOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveResource-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveResource"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveReportingAsset {
    pub _glacier_base: super::core::Asset,
    pub new_wave_debug_asset_uri: String,
}

pub trait NewWaveReportingAssetTrait: super::core::AssetTrait {
    fn new_wave_debug_asset_uri(&self) -> &String;
    fn new_wave_debug_asset_uri_mut(&mut self) -> &mut String;
}

impl NewWaveReportingAssetTrait for NewWaveReportingAsset {
    fn new_wave_debug_asset_uri(&self) -> &String {
        &self.new_wave_debug_asset_uri
    }
    fn new_wave_debug_asset_uri_mut(&mut self) -> &mut String {
        &mut self.new_wave_debug_asset_uri
    }
}

impl super::core::AssetTrait for NewWaveReportingAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for NewWaveReportingAsset {
}

pub static NEWWAVEREPORTINGASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveReportingAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveReportingAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NewWaveDebugAssetUri",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(NewWaveReportingAsset, new_wave_debug_asset_uri),
            },
        ],
    }),
    array_type: Some(NEWWAVEREPORTINGASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveReportingAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVEREPORTINGASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NEWWAVEREPORTINGASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveReportingAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveReportingAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveDebugAsset {
    pub _glacier_base: super::core::Asset,
    pub variations: Vec<NewWaveVariationDebugData>,
}

pub trait NewWaveDebugAssetTrait: super::core::AssetTrait {
    fn variations(&self) -> &Vec<NewWaveVariationDebugData>;
    fn variations_mut(&mut self) -> &mut Vec<NewWaveVariationDebugData>;
}

impl NewWaveDebugAssetTrait for NewWaveDebugAsset {
    fn variations(&self) -> &Vec<NewWaveVariationDebugData> {
        &self.variations
    }
    fn variations_mut(&mut self) -> &mut Vec<NewWaveVariationDebugData> {
        &mut self.variations
    }
}

impl super::core::AssetTrait for NewWaveDebugAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for NewWaveDebugAsset {
}

pub static NEWWAVEDEBUGASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveDebugAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveDebugAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Variations",
                flags: MemberInfoFlags::new(144),
                field_type: "NewWaveVariationDebugData-Array",
                rust_offset: offset_of!(NewWaveDebugAsset, variations),
            },
        ],
    }),
    array_type: Some(NEWWAVEDEBUGASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveDebugAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVEDEBUGASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NEWWAVEDEBUGASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveDebugAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveDebugAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveVariationDebugData {
    pub id: u32,
    pub partition_guid: glacier_util::guid::Guid,
    pub instance_guid: glacier_util::guid::Guid,
}

pub trait NewWaveVariationDebugDataTrait: TypeObject {
    fn id(&self) -> &u32;
    fn id_mut(&mut self) -> &mut u32;
    fn partition_guid(&self) -> &glacier_util::guid::Guid;
    fn partition_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn instance_guid(&self) -> &glacier_util::guid::Guid;
    fn instance_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
}

impl NewWaveVariationDebugDataTrait for NewWaveVariationDebugData {
    fn id(&self) -> &u32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut u32 {
        &mut self.id
    }
    fn partition_guid(&self) -> &glacier_util::guid::Guid {
        &self.partition_guid
    }
    fn partition_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.partition_guid
    }
    fn instance_guid(&self) -> &glacier_util::guid::Guid {
        &self.instance_guid
    }
    fn instance_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.instance_guid
    }
}

pub static NEWWAVEVARIATIONDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveVariationDebugData",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveVariationDebugData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NewWaveVariationDebugData, id),
            },
            FieldInfoData {
                name: "PartitionGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(NewWaveVariationDebugData, partition_guid),
            },
            FieldInfoData {
                name: "InstanceGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(NewWaveVariationDebugData, instance_guid),
            },
        ],
    }),
    array_type: Some(NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for NewWaveVariationDebugData {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVEVARIATIONDEBUGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NEWWAVEVARIATIONDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveVariationDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveVariationDebugData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LocalizedWaveAsset {
    pub _glacier_base: NewWaveAsset,
}

pub trait LocalizedWaveAssetTrait: NewWaveAssetTrait {
}

impl LocalizedWaveAssetTrait for LocalizedWaveAsset {
}

impl NewWaveAssetTrait for LocalizedWaveAsset {
    fn default_selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        self._glacier_base.default_selection_group()
    }
    fn default_selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        self._glacier_base.default_selection_group_mut()
    }
    fn is_seekable(&self) -> &bool {
        self._glacier_base.is_seekable()
    }
    fn is_seekable_mut(&mut self) -> &mut bool {
        self._glacier_base.is_seekable_mut()
    }
    fn selection_parameter_count(&self) -> &u8 {
        self._glacier_base.selection_parameter_count()
    }
    fn selection_parameter_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.selection_parameter_count_mut()
    }
    fn control_parameter_count(&self) -> &u8 {
        self._glacier_base.control_parameter_count()
    }
    fn control_parameter_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.control_parameter_count_mut()
    }
}

impl SoundWaveAssetBaseTrait for LocalizedWaveAsset {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        self._glacier_base.stream_pool()
    }
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        self._glacier_base.stream_pool_mut()
    }
    fn prefer_available_variations(&self) -> &bool {
        self._glacier_base.prefer_available_variations()
    }
    fn prefer_available_variations_mut(&mut self) -> &mut bool {
        self._glacier_base.prefer_available_variations_mut()
    }
    fn streaming_mode(&self) -> &u8 {
        self._glacier_base.streaming_mode()
    }
    fn streaming_mode_mut(&mut self) -> &mut u8 {
        self._glacier_base.streaming_mode_mut()
    }
    fn voice_priority(&self) -> &u8 {
        self._glacier_base.voice_priority()
    }
    fn voice_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.voice_priority_mut()
    }
    fn channel_count(&self) -> &u8 {
        self._glacier_base.channel_count()
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.channel_count_mut()
    }
}

impl SoundDataAssetTrait for LocalizedWaveAsset {
    fn chunks(&self) -> &Vec<SoundDataChunk> {
        self._glacier_base.chunks()
    }
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk> {
        self._glacier_base.chunks_mut()
    }
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy()
    }
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy_mut()
    }
    fn prime_priority(&self) -> &u8 {
        self._glacier_base.prime_priority()
    }
    fn prime_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.prime_priority_mut()
    }
    fn request_priority(&self) -> &u8 {
        self._glacier_base.request_priority()
    }
    fn request_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.request_priority_mut()
    }
}

impl super::core::AssetTrait for LocalizedWaveAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LocalizedWaveAsset {
}

pub static LOCALIZEDWAVEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalizedWaveAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(NEWWAVEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LocalizedWaveAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LOCALIZEDWAVEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LocalizedWaveAsset {
    fn type_info(&self) -> &'static TypeInfo {
        LOCALIZEDWAVEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOCALIZEDWAVEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LocalizedWaveAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LocalizedWaveAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveAsset {
    pub _glacier_base: SoundWaveAssetBase,
    pub default_selection_group: Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>,
    pub is_seekable: bool,
    pub selection_parameter_count: u8,
    pub control_parameter_count: u8,
}

pub trait NewWaveAssetTrait: SoundWaveAssetBaseTrait {
    fn default_selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>;
    fn default_selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>;
    fn is_seekable(&self) -> &bool;
    fn is_seekable_mut(&mut self) -> &mut bool;
    fn selection_parameter_count(&self) -> &u8;
    fn selection_parameter_count_mut(&mut self) -> &mut u8;
    fn control_parameter_count(&self) -> &u8;
    fn control_parameter_count_mut(&mut self) -> &mut u8;
}

impl NewWaveAssetTrait for NewWaveAsset {
    fn default_selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        &self.default_selection_group
    }
    fn default_selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        &mut self.default_selection_group
    }
    fn is_seekable(&self) -> &bool {
        &self.is_seekable
    }
    fn is_seekable_mut(&mut self) -> &mut bool {
        &mut self.is_seekable
    }
    fn selection_parameter_count(&self) -> &u8 {
        &self.selection_parameter_count
    }
    fn selection_parameter_count_mut(&mut self) -> &mut u8 {
        &mut self.selection_parameter_count
    }
    fn control_parameter_count(&self) -> &u8 {
        &self.control_parameter_count
    }
    fn control_parameter_count_mut(&mut self) -> &mut u8 {
        &mut self.control_parameter_count
    }
}

impl SoundWaveAssetBaseTrait for NewWaveAsset {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        self._glacier_base.stream_pool()
    }
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        self._glacier_base.stream_pool_mut()
    }
    fn prefer_available_variations(&self) -> &bool {
        self._glacier_base.prefer_available_variations()
    }
    fn prefer_available_variations_mut(&mut self) -> &mut bool {
        self._glacier_base.prefer_available_variations_mut()
    }
    fn streaming_mode(&self) -> &u8 {
        self._glacier_base.streaming_mode()
    }
    fn streaming_mode_mut(&mut self) -> &mut u8 {
        self._glacier_base.streaming_mode_mut()
    }
    fn voice_priority(&self) -> &u8 {
        self._glacier_base.voice_priority()
    }
    fn voice_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.voice_priority_mut()
    }
    fn channel_count(&self) -> &u8 {
        self._glacier_base.channel_count()
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.channel_count_mut()
    }
}

impl SoundDataAssetTrait for NewWaveAsset {
    fn chunks(&self) -> &Vec<SoundDataChunk> {
        self._glacier_base.chunks()
    }
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk> {
        self._glacier_base.chunks_mut()
    }
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy()
    }
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy_mut()
    }
    fn prime_priority(&self) -> &u8 {
        self._glacier_base.prime_priority()
    }
    fn prime_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.prime_priority_mut()
    }
    fn request_priority(&self) -> &u8 {
        self._glacier_base.request_priority()
    }
    fn request_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.request_priority_mut()
    }
}

impl super::core::AssetTrait for NewWaveAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for NewWaveAsset {
}

pub static NEWWAVEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDWAVEASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultSelectionGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveSelectionGroup",
                rust_offset: offset_of!(NewWaveAsset, default_selection_group),
            },
            FieldInfoData {
                name: "IsSeekable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NewWaveAsset, is_seekable),
            },
            FieldInfoData {
                name: "SelectionParameterCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NewWaveAsset, selection_parameter_count),
            },
            FieldInfoData {
                name: "ControlParameterCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NewWaveAsset, control_parameter_count),
            },
        ],
    }),
    array_type: Some(NEWWAVEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveAsset {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NEWWAVEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveAsset {
    pub _glacier_base: SoundWaveAssetBase,
    pub runtime_variations: Vec<SoundWaveRuntimeVariation>,
    pub localization: Vec<SoundWaveLocalizationInfo>,
    pub subtitle_string_ids: Vec<String>,
    pub subtitles: Vec<SoundWaveSubtitle>,
    pub selection: SoundWaveVariationSelection,
    pub seekable: bool,
    pub variation_history_count: u8,
    pub persistent_variation_count: u8,
    pub additional_subtitle_info_type: i32,
    pub segments: Vec<SoundWaveVariationSegment>,
}

pub trait SoundWaveAssetTrait: SoundWaveAssetBaseTrait {
    fn runtime_variations(&self) -> &Vec<SoundWaveRuntimeVariation>;
    fn runtime_variations_mut(&mut self) -> &mut Vec<SoundWaveRuntimeVariation>;
    fn localization(&self) -> &Vec<SoundWaveLocalizationInfo>;
    fn localization_mut(&mut self) -> &mut Vec<SoundWaveLocalizationInfo>;
    fn subtitle_string_ids(&self) -> &Vec<String>;
    fn subtitle_string_ids_mut(&mut self) -> &mut Vec<String>;
    fn subtitles(&self) -> &Vec<SoundWaveSubtitle>;
    fn subtitles_mut(&mut self) -> &mut Vec<SoundWaveSubtitle>;
    fn selection(&self) -> &SoundWaveVariationSelection;
    fn selection_mut(&mut self) -> &mut SoundWaveVariationSelection;
    fn seekable(&self) -> &bool;
    fn seekable_mut(&mut self) -> &mut bool;
    fn variation_history_count(&self) -> &u8;
    fn variation_history_count_mut(&mut self) -> &mut u8;
    fn persistent_variation_count(&self) -> &u8;
    fn persistent_variation_count_mut(&mut self) -> &mut u8;
    fn additional_subtitle_info_type(&self) -> &i32;
    fn additional_subtitle_info_type_mut(&mut self) -> &mut i32;
    fn segments(&self) -> &Vec<SoundWaveVariationSegment>;
    fn segments_mut(&mut self) -> &mut Vec<SoundWaveVariationSegment>;
}

impl SoundWaveAssetTrait for SoundWaveAsset {
    fn runtime_variations(&self) -> &Vec<SoundWaveRuntimeVariation> {
        &self.runtime_variations
    }
    fn runtime_variations_mut(&mut self) -> &mut Vec<SoundWaveRuntimeVariation> {
        &mut self.runtime_variations
    }
    fn localization(&self) -> &Vec<SoundWaveLocalizationInfo> {
        &self.localization
    }
    fn localization_mut(&mut self) -> &mut Vec<SoundWaveLocalizationInfo> {
        &mut self.localization
    }
    fn subtitle_string_ids(&self) -> &Vec<String> {
        &self.subtitle_string_ids
    }
    fn subtitle_string_ids_mut(&mut self) -> &mut Vec<String> {
        &mut self.subtitle_string_ids
    }
    fn subtitles(&self) -> &Vec<SoundWaveSubtitle> {
        &self.subtitles
    }
    fn subtitles_mut(&mut self) -> &mut Vec<SoundWaveSubtitle> {
        &mut self.subtitles
    }
    fn selection(&self) -> &SoundWaveVariationSelection {
        &self.selection
    }
    fn selection_mut(&mut self) -> &mut SoundWaveVariationSelection {
        &mut self.selection
    }
    fn seekable(&self) -> &bool {
        &self.seekable
    }
    fn seekable_mut(&mut self) -> &mut bool {
        &mut self.seekable
    }
    fn variation_history_count(&self) -> &u8 {
        &self.variation_history_count
    }
    fn variation_history_count_mut(&mut self) -> &mut u8 {
        &mut self.variation_history_count
    }
    fn persistent_variation_count(&self) -> &u8 {
        &self.persistent_variation_count
    }
    fn persistent_variation_count_mut(&mut self) -> &mut u8 {
        &mut self.persistent_variation_count
    }
    fn additional_subtitle_info_type(&self) -> &i32 {
        &self.additional_subtitle_info_type
    }
    fn additional_subtitle_info_type_mut(&mut self) -> &mut i32 {
        &mut self.additional_subtitle_info_type
    }
    fn segments(&self) -> &Vec<SoundWaveVariationSegment> {
        &self.segments
    }
    fn segments_mut(&mut self) -> &mut Vec<SoundWaveVariationSegment> {
        &mut self.segments
    }
}

impl SoundWaveAssetBaseTrait for SoundWaveAsset {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        self._glacier_base.stream_pool()
    }
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        self._glacier_base.stream_pool_mut()
    }
    fn prefer_available_variations(&self) -> &bool {
        self._glacier_base.prefer_available_variations()
    }
    fn prefer_available_variations_mut(&mut self) -> &mut bool {
        self._glacier_base.prefer_available_variations_mut()
    }
    fn streaming_mode(&self) -> &u8 {
        self._glacier_base.streaming_mode()
    }
    fn streaming_mode_mut(&mut self) -> &mut u8 {
        self._glacier_base.streaming_mode_mut()
    }
    fn voice_priority(&self) -> &u8 {
        self._glacier_base.voice_priority()
    }
    fn voice_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.voice_priority_mut()
    }
    fn channel_count(&self) -> &u8 {
        self._glacier_base.channel_count()
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.channel_count_mut()
    }
}

impl SoundDataAssetTrait for SoundWaveAsset {
    fn chunks(&self) -> &Vec<SoundDataChunk> {
        self._glacier_base.chunks()
    }
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk> {
        self._glacier_base.chunks_mut()
    }
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy()
    }
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy_mut()
    }
    fn prime_priority(&self) -> &u8 {
        self._glacier_base.prime_priority()
    }
    fn prime_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.prime_priority_mut()
    }
    fn request_priority(&self) -> &u8 {
        self._glacier_base.request_priority()
    }
    fn request_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.request_priority_mut()
    }
}

impl super::core::AssetTrait for SoundWaveAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundWaveAsset {
}

pub static SOUNDWAVEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDWAVEASSETBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RuntimeVariations",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveRuntimeVariation-Array",
                rust_offset: offset_of!(SoundWaveAsset, runtime_variations),
            },
            FieldInfoData {
                name: "Localization",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveLocalizationInfo-Array",
                rust_offset: offset_of!(SoundWaveAsset, localization),
            },
            FieldInfoData {
                name: "SubtitleStringIds",
                flags: MemberInfoFlags::new(144),
                field_type: "CString-Array",
                rust_offset: offset_of!(SoundWaveAsset, subtitle_string_ids),
            },
            FieldInfoData {
                name: "Subtitles",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveSubtitle-Array",
                rust_offset: offset_of!(SoundWaveAsset, subtitles),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveVariationSelection",
                rust_offset: offset_of!(SoundWaveAsset, selection),
            },
            FieldInfoData {
                name: "Seekable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundWaveAsset, seekable),
            },
            FieldInfoData {
                name: "VariationHistoryCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveAsset, variation_history_count),
            },
            FieldInfoData {
                name: "PersistentVariationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveAsset, persistent_variation_count),
            },
            FieldInfoData {
                name: "AdditionalSubtitleInfoType",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoundWaveAsset, additional_subtitle_info_type),
            },
            FieldInfoData {
                name: "Segments",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveVariationSegment-Array",
                rust_offset: offset_of!(SoundWaveAsset, segments),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDWAVEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveAssetBase {
    pub _glacier_base: SoundDataAsset,
    pub stream_pool: Option<Arc<Mutex<dyn StreamPoolTrait>>>,
    pub prefer_available_variations: bool,
    pub streaming_mode: u8,
    pub voice_priority: u8,
    pub channel_count: u8,
}

pub trait SoundWaveAssetBaseTrait: SoundDataAssetTrait {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>>;
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>>;
    fn prefer_available_variations(&self) -> &bool;
    fn prefer_available_variations_mut(&mut self) -> &mut bool;
    fn streaming_mode(&self) -> &u8;
    fn streaming_mode_mut(&mut self) -> &mut u8;
    fn voice_priority(&self) -> &u8;
    fn voice_priority_mut(&mut self) -> &mut u8;
    fn channel_count(&self) -> &u8;
    fn channel_count_mut(&mut self) -> &mut u8;
}

impl SoundWaveAssetBaseTrait for SoundWaveAssetBase {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        &self.stream_pool
    }
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        &mut self.stream_pool
    }
    fn prefer_available_variations(&self) -> &bool {
        &self.prefer_available_variations
    }
    fn prefer_available_variations_mut(&mut self) -> &mut bool {
        &mut self.prefer_available_variations
    }
    fn streaming_mode(&self) -> &u8 {
        &self.streaming_mode
    }
    fn streaming_mode_mut(&mut self) -> &mut u8 {
        &mut self.streaming_mode
    }
    fn voice_priority(&self) -> &u8 {
        &self.voice_priority
    }
    fn voice_priority_mut(&mut self) -> &mut u8 {
        &mut self.voice_priority
    }
    fn channel_count(&self) -> &u8 {
        &self.channel_count
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        &mut self.channel_count
    }
}

impl SoundDataAssetTrait for SoundWaveAssetBase {
    fn chunks(&self) -> &Vec<SoundDataChunk> {
        self._glacier_base.chunks()
    }
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk> {
        self._glacier_base.chunks_mut()
    }
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy()
    }
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy_mut()
    }
    fn prime_priority(&self) -> &u8 {
        self._glacier_base.prime_priority()
    }
    fn prime_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.prime_priority_mut()
    }
    fn request_priority(&self) -> &u8 {
        self._glacier_base.request_priority()
    }
    fn request_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.request_priority_mut()
    }
}

impl super::core::AssetTrait for SoundWaveAssetBase {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundWaveAssetBase {
}

pub static SOUNDWAVEASSETBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAssetBase",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDDATAASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveAssetBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StreamPool",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamPool",
                rust_offset: offset_of!(SoundWaveAssetBase, stream_pool),
            },
            FieldInfoData {
                name: "PreferAvailableVariations",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundWaveAssetBase, prefer_available_variations),
            },
            FieldInfoData {
                name: "StreamingMode",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveAssetBase, streaming_mode),
            },
            FieldInfoData {
                name: "VoicePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveAssetBase, voice_priority),
            },
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveAssetBase, channel_count),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveAssetBase {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVEASSETBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDWAVEASSETBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveAssetBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveAssetBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundWaveStreamingMode {
    #[default]
    SoundWaveStreamingMode_Normal = 0,
    SoundWaveStreamingMode_ZeroLatency = 1,
    SoundWaveStreamingMode_LowLatency = 2,
}

pub static SOUNDWAVESTREAMINGMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveStreamingMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDWAVESTREAMINGMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundWaveStreamingMode {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVESTREAMINGMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVESTREAMINGMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveStreamingMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveStreamingMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveLocalizationInfo {
    pub language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub first_variation_index: u16,
    pub variation_count: u16,
}

pub trait SoundWaveLocalizationInfoTrait: TypeObject {
    fn language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn first_variation_index(&self) -> &u16;
    fn first_variation_index_mut(&mut self) -> &mut u16;
    fn variation_count(&self) -> &u16;
    fn variation_count_mut(&mut self) -> &mut u16;
}

impl SoundWaveLocalizationInfoTrait for SoundWaveLocalizationInfo {
    fn language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.language
    }
    fn language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.language
    }
    fn first_variation_index(&self) -> &u16 {
        &self.first_variation_index
    }
    fn first_variation_index_mut(&mut self) -> &mut u16 {
        &mut self.first_variation_index
    }
    fn variation_count(&self) -> &u16 {
        &self.variation_count
    }
    fn variation_count_mut(&mut self) -> &mut u16 {
        &mut self.variation_count
    }
}

pub static SOUNDWAVELOCALIZATIONINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveLocalizationInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveLocalizationInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Language",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(SoundWaveLocalizationInfo, language),
            },
            FieldInfoData {
                name: "FirstVariationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SoundWaveLocalizationInfo, first_variation_index),
            },
            FieldInfoData {
                name: "VariationCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SoundWaveLocalizationInfo, variation_count),
            },
        ],
    }),
    array_type: Some(SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveLocalizationInfo {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVELOCALIZATIONINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVELOCALIZATIONINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveLocalizationInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveLocalizationInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveRuntimeVariation {
    pub persistent_data_size: u32,
    pub first_subtitle_index: u8,
    pub subtitle_count: u8,
    pub first_segment_index: u16,
    pub segment_count: u8,
    pub chunk_index: u8,
    pub first_loop_segment_index: u8,
    pub last_loop_segment_index: u8,
    pub weight: u8,
}

pub trait SoundWaveRuntimeVariationTrait: TypeObject {
    fn persistent_data_size(&self) -> &u32;
    fn persistent_data_size_mut(&mut self) -> &mut u32;
    fn first_subtitle_index(&self) -> &u8;
    fn first_subtitle_index_mut(&mut self) -> &mut u8;
    fn subtitle_count(&self) -> &u8;
    fn subtitle_count_mut(&mut self) -> &mut u8;
    fn first_segment_index(&self) -> &u16;
    fn first_segment_index_mut(&mut self) -> &mut u16;
    fn segment_count(&self) -> &u8;
    fn segment_count_mut(&mut self) -> &mut u8;
    fn chunk_index(&self) -> &u8;
    fn chunk_index_mut(&mut self) -> &mut u8;
    fn first_loop_segment_index(&self) -> &u8;
    fn first_loop_segment_index_mut(&mut self) -> &mut u8;
    fn last_loop_segment_index(&self) -> &u8;
    fn last_loop_segment_index_mut(&mut self) -> &mut u8;
    fn weight(&self) -> &u8;
    fn weight_mut(&mut self) -> &mut u8;
}

impl SoundWaveRuntimeVariationTrait for SoundWaveRuntimeVariation {
    fn persistent_data_size(&self) -> &u32 {
        &self.persistent_data_size
    }
    fn persistent_data_size_mut(&mut self) -> &mut u32 {
        &mut self.persistent_data_size
    }
    fn first_subtitle_index(&self) -> &u8 {
        &self.first_subtitle_index
    }
    fn first_subtitle_index_mut(&mut self) -> &mut u8 {
        &mut self.first_subtitle_index
    }
    fn subtitle_count(&self) -> &u8 {
        &self.subtitle_count
    }
    fn subtitle_count_mut(&mut self) -> &mut u8 {
        &mut self.subtitle_count
    }
    fn first_segment_index(&self) -> &u16 {
        &self.first_segment_index
    }
    fn first_segment_index_mut(&mut self) -> &mut u16 {
        &mut self.first_segment_index
    }
    fn segment_count(&self) -> &u8 {
        &self.segment_count
    }
    fn segment_count_mut(&mut self) -> &mut u8 {
        &mut self.segment_count
    }
    fn chunk_index(&self) -> &u8 {
        &self.chunk_index
    }
    fn chunk_index_mut(&mut self) -> &mut u8 {
        &mut self.chunk_index
    }
    fn first_loop_segment_index(&self) -> &u8 {
        &self.first_loop_segment_index
    }
    fn first_loop_segment_index_mut(&mut self) -> &mut u8 {
        &mut self.first_loop_segment_index
    }
    fn last_loop_segment_index(&self) -> &u8 {
        &self.last_loop_segment_index
    }
    fn last_loop_segment_index_mut(&mut self) -> &mut u8 {
        &mut self.last_loop_segment_index
    }
    fn weight(&self) -> &u8 {
        &self.weight
    }
    fn weight_mut(&mut self) -> &mut u8 {
        &mut self.weight
    }
}

pub static SOUNDWAVERUNTIMEVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveRuntimeVariation",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveRuntimeVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PersistentDataSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, persistent_data_size),
            },
            FieldInfoData {
                name: "FirstSubtitleIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, first_subtitle_index),
            },
            FieldInfoData {
                name: "SubtitleCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, subtitle_count),
            },
            FieldInfoData {
                name: "FirstSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, first_segment_index),
            },
            FieldInfoData {
                name: "SegmentCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, segment_count),
            },
            FieldInfoData {
                name: "ChunkIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, chunk_index),
            },
            FieldInfoData {
                name: "FirstLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, first_loop_segment_index),
            },
            FieldInfoData {
                name: "LastLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, last_loop_segment_index),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveRuntimeVariation, weight),
            },
        ],
    }),
    array_type: Some(SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundWaveRuntimeVariation {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVERUNTIMEVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVERUNTIMEVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveRuntimeVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveRuntimeVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveVariation {
    pub _glacier_base: super::core::DataContainer,
    pub subtitles: Vec<SoundWaveSubtitle>,
    pub weight: u8,
    pub segments: Vec<SoundWaveVariationSegment>,
    pub persistent_data_size: u32,
    pub chunk_index: u8,
    pub first_loop_segment_index: u8,
    pub last_loop_segment_index: u8,
}

pub trait SoundWaveVariationTrait: super::core::DataContainerTrait {
    fn subtitles(&self) -> &Vec<SoundWaveSubtitle>;
    fn subtitles_mut(&mut self) -> &mut Vec<SoundWaveSubtitle>;
    fn weight(&self) -> &u8;
    fn weight_mut(&mut self) -> &mut u8;
    fn segments(&self) -> &Vec<SoundWaveVariationSegment>;
    fn segments_mut(&mut self) -> &mut Vec<SoundWaveVariationSegment>;
    fn persistent_data_size(&self) -> &u32;
    fn persistent_data_size_mut(&mut self) -> &mut u32;
    fn chunk_index(&self) -> &u8;
    fn chunk_index_mut(&mut self) -> &mut u8;
    fn first_loop_segment_index(&self) -> &u8;
    fn first_loop_segment_index_mut(&mut self) -> &mut u8;
    fn last_loop_segment_index(&self) -> &u8;
    fn last_loop_segment_index_mut(&mut self) -> &mut u8;
}

impl SoundWaveVariationTrait for SoundWaveVariation {
    fn subtitles(&self) -> &Vec<SoundWaveSubtitle> {
        &self.subtitles
    }
    fn subtitles_mut(&mut self) -> &mut Vec<SoundWaveSubtitle> {
        &mut self.subtitles
    }
    fn weight(&self) -> &u8 {
        &self.weight
    }
    fn weight_mut(&mut self) -> &mut u8 {
        &mut self.weight
    }
    fn segments(&self) -> &Vec<SoundWaveVariationSegment> {
        &self.segments
    }
    fn segments_mut(&mut self) -> &mut Vec<SoundWaveVariationSegment> {
        &mut self.segments
    }
    fn persistent_data_size(&self) -> &u32 {
        &self.persistent_data_size
    }
    fn persistent_data_size_mut(&mut self) -> &mut u32 {
        &mut self.persistent_data_size
    }
    fn chunk_index(&self) -> &u8 {
        &self.chunk_index
    }
    fn chunk_index_mut(&mut self) -> &mut u8 {
        &mut self.chunk_index
    }
    fn first_loop_segment_index(&self) -> &u8 {
        &self.first_loop_segment_index
    }
    fn first_loop_segment_index_mut(&mut self) -> &mut u8 {
        &mut self.first_loop_segment_index
    }
    fn last_loop_segment_index(&self) -> &u8 {
        &self.last_loop_segment_index
    }
    fn last_loop_segment_index_mut(&mut self) -> &mut u8 {
        &mut self.last_loop_segment_index
    }
}

impl super::core::DataContainerTrait for SoundWaveVariation {
}

pub static SOUNDWAVEVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariation",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Subtitles",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveSubtitle-Array",
                rust_offset: offset_of!(SoundWaveVariation, subtitles),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveVariation, weight),
            },
            FieldInfoData {
                name: "Segments",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveVariationSegment-Array",
                rust_offset: offset_of!(SoundWaveVariation, segments),
            },
            FieldInfoData {
                name: "PersistentDataSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundWaveVariation, persistent_data_size),
            },
            FieldInfoData {
                name: "ChunkIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveVariation, chunk_index),
            },
            FieldInfoData {
                name: "FirstLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveVariation, first_loop_segment_index),
            },
            FieldInfoData {
                name: "LastLoopSegmentIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveVariation, last_loop_segment_index),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundWaveVariation {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVEVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDWAVEVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveSubtitle {
    pub string_index: u8,
    pub time: f32,
    pub additional_subtitle_info_type: i32,
}

pub trait SoundWaveSubtitleTrait: TypeObject {
    fn string_index(&self) -> &u8;
    fn string_index_mut(&mut self) -> &mut u8;
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn additional_subtitle_info_type(&self) -> &i32;
    fn additional_subtitle_info_type_mut(&mut self) -> &mut i32;
}

impl SoundWaveSubtitleTrait for SoundWaveSubtitle {
    fn string_index(&self) -> &u8 {
        &self.string_index
    }
    fn string_index_mut(&mut self) -> &mut u8 {
        &mut self.string_index
    }
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn additional_subtitle_info_type(&self) -> &i32 {
        &self.additional_subtitle_info_type
    }
    fn additional_subtitle_info_type_mut(&mut self) -> &mut i32 {
        &mut self.additional_subtitle_info_type
    }
}

pub static SOUNDWAVESUBTITLE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveSubtitle",
    flags: MemberInfoFlags::new(32841),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveSubtitle as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StringIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundWaveSubtitle, string_index),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundWaveSubtitle, time),
            },
            FieldInfoData {
                name: "AdditionalSubtitleInfoType",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoundWaveSubtitle, additional_subtitle_info_type),
            },
        ],
    }),
    array_type: Some(SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundWaveSubtitle {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVESUBTITLE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVESUBTITLE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveSubtitle-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveSubtitle"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundWaveVariationSegment {
    pub samples_offset: u32,
    pub seek_table_offset: u32,
    pub segment_length: f32,
}

pub trait SoundWaveVariationSegmentTrait: TypeObject {
    fn samples_offset(&self) -> &u32;
    fn samples_offset_mut(&mut self) -> &mut u32;
    fn seek_table_offset(&self) -> &u32;
    fn seek_table_offset_mut(&mut self) -> &mut u32;
    fn segment_length(&self) -> &f32;
    fn segment_length_mut(&mut self) -> &mut f32;
}

impl SoundWaveVariationSegmentTrait for SoundWaveVariationSegment {
    fn samples_offset(&self) -> &u32 {
        &self.samples_offset
    }
    fn samples_offset_mut(&mut self) -> &mut u32 {
        &mut self.samples_offset
    }
    fn seek_table_offset(&self) -> &u32 {
        &self.seek_table_offset
    }
    fn seek_table_offset_mut(&mut self) -> &mut u32 {
        &mut self.seek_table_offset
    }
    fn segment_length(&self) -> &f32 {
        &self.segment_length
    }
    fn segment_length_mut(&mut self) -> &mut f32 {
        &mut self.segment_length
    }
}

pub static SOUNDWAVEVARIATIONSEGMENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSegment",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundWaveVariationSegment as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SamplesOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundWaveVariationSegment, samples_offset),
            },
            FieldInfoData {
                name: "SeekTableOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundWaveVariationSegment, seek_table_offset),
            },
            FieldInfoData {
                name: "SegmentLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundWaveVariationSegment, segment_length),
            },
        ],
    }),
    array_type: Some(SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundWaveVariationSegment {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVEVARIATIONSEGMENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVEVARIATIONSEGMENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSegment-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVariationSegment"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundWaveVariationSelection {
    #[default]
    SoundWaveVariationSelection_Sequential = 0,
    SoundWaveVariationSelection_Random = 1,
    SoundWaveVariationSelection_Shuffle = 2,
    SoundWaveVariationSelection_WeightedShuffle = 3,
    SoundWaveVariationSelection_WeightedRandom = 4,
}

pub static SOUNDWAVEVARIATIONSELECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSelection",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDWAVEVARIATIONSELECTION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundWaveVariationSelection {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVEVARIATIONSELECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVEVARIATIONSELECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVariationSelection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVariationSelection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundWaveVoicePriority {
    #[default]
    SoundWaveVoicePriority_Low = 0,
    SoundWaveVoicePriority_Medium = 1,
    SoundWaveVoicePriority_Normal = 2,
    SoundWaveVoicePriority_High = 3,
    SoundWaveVoicePriority_Permanent = 4,
}

pub static SOUNDWAVEVOICEPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVoicePriority",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDWAVEVOICEPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundWaveVoicePriority {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDWAVEVOICEPRIORITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDWAVEVOICEPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundWaveVoicePriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundWaveVoicePriority"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundDataAsset {
    pub _glacier_base: super::core::Asset,
    pub chunks: Vec<SoundDataChunk>,
    pub policy: Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>,
    pub prime_priority: u8,
    pub request_priority: u8,
}

pub trait SoundDataAssetTrait: super::core::AssetTrait {
    fn chunks(&self) -> &Vec<SoundDataChunk>;
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk>;
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>;
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>;
    fn prime_priority(&self) -> &u8;
    fn prime_priority_mut(&mut self) -> &mut u8;
    fn request_priority(&self) -> &u8;
    fn request_priority_mut(&mut self) -> &mut u8;
}

impl SoundDataAssetTrait for SoundDataAsset {
    fn chunks(&self) -> &Vec<SoundDataChunk> {
        &self.chunks
    }
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk> {
        &mut self.chunks
    }
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        &self.policy
    }
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        &mut self.policy
    }
    fn prime_priority(&self) -> &u8 {
        &self.prime_priority
    }
    fn prime_priority_mut(&mut self) -> &mut u8 {
        &mut self.prime_priority
    }
    fn request_priority(&self) -> &u8 {
        &self.request_priority
    }
    fn request_priority_mut(&mut self) -> &mut u8 {
        &mut self.request_priority
    }
}

impl super::core::AssetTrait for SoundDataAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundDataAsset {
}

pub static SOUNDDATAASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundDataAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Chunks",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundDataChunk-Array",
                rust_offset: offset_of!(SoundDataAsset, chunks),
            },
            FieldInfoData {
                name: "Policy",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundDataPolicy",
                rust_offset: offset_of!(SoundDataAsset, policy),
            },
            FieldInfoData {
                name: "PrimePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundDataAsset, prime_priority),
            },
            FieldInfoData {
                name: "RequestPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundDataAsset, request_priority),
            },
        ],
    }),
    array_type: Some(SOUNDDATAASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDDATAASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundDataPolicy {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub request_behavior: SoundDataRequestBehavior,
    pub release_behavior: SoundDataReleaseBehavior,
    pub prime_target: SoundDataReadTarget,
    pub request_target: SoundDataReadTarget,
}

pub trait SoundDataPolicyTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn request_behavior(&self) -> &SoundDataRequestBehavior;
    fn request_behavior_mut(&mut self) -> &mut SoundDataRequestBehavior;
    fn release_behavior(&self) -> &SoundDataReleaseBehavior;
    fn release_behavior_mut(&mut self) -> &mut SoundDataReleaseBehavior;
    fn prime_target(&self) -> &SoundDataReadTarget;
    fn prime_target_mut(&mut self) -> &mut SoundDataReadTarget;
    fn request_target(&self) -> &SoundDataReadTarget;
    fn request_target_mut(&mut self) -> &mut SoundDataReadTarget;
}

impl SoundDataPolicyTrait for SoundDataPolicy {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn request_behavior(&self) -> &SoundDataRequestBehavior {
        &self.request_behavior
    }
    fn request_behavior_mut(&mut self) -> &mut SoundDataRequestBehavior {
        &mut self.request_behavior
    }
    fn release_behavior(&self) -> &SoundDataReleaseBehavior {
        &self.release_behavior
    }
    fn release_behavior_mut(&mut self) -> &mut SoundDataReleaseBehavior {
        &mut self.release_behavior
    }
    fn prime_target(&self) -> &SoundDataReadTarget {
        &self.prime_target
    }
    fn prime_target_mut(&mut self) -> &mut SoundDataReadTarget {
        &mut self.prime_target
    }
    fn request_target(&self) -> &SoundDataReadTarget {
        &self.request_target
    }
    fn request_target_mut(&mut self) -> &mut SoundDataReadTarget {
        &mut self.request_target
    }
}

impl super::core::DataContainerTrait for SoundDataPolicy {
}

pub static SOUNDDATAPOLICY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPolicy",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundDataPolicy as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundDataPolicy, name),
            },
            FieldInfoData {
                name: "RequestBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundDataRequestBehavior",
                rust_offset: offset_of!(SoundDataPolicy, request_behavior),
            },
            FieldInfoData {
                name: "ReleaseBehavior",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundDataReleaseBehavior",
                rust_offset: offset_of!(SoundDataPolicy, release_behavior),
            },
            FieldInfoData {
                name: "PrimeTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundDataReadTarget",
                rust_offset: offset_of!(SoundDataPolicy, prime_target),
            },
            FieldInfoData {
                name: "RequestTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundDataReadTarget",
                rust_offset: offset_of!(SoundDataPolicy, request_target),
            },
        ],
    }),
    array_type: Some(SOUNDDATAPOLICY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataPolicy {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAPOLICY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDDATAPOLICY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPolicy-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataPolicy"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataReadTarget {
    #[default]
    SoundDataReadTarget_Primary = 0,
    SoundDataReadTarget_Secondary = 1,
}

pub static SOUNDDATAREADTARGET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadTarget",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREADTARGET_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataReadTarget {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAREADTARGET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATAREADTARGET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadTarget-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReadTarget"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataReleaseBehavior {
    #[default]
    SoundDataReleaseBehavior_Explicit = 0,
    SoundDataReleaseBehavior_Bundle = 1,
    SoundDataReleaseBehavior_Inactive = 2,
}

pub static SOUNDDATARELEASEBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReleaseBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATARELEASEBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataReleaseBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATARELEASEBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATARELEASEBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReleaseBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReleaseBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataRequestBehavior {
    #[default]
    SoundDataRequestBehavior_Explicit = 0,
    SoundDataRequestBehavior_Bundle = 1,
}

pub static SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREQUESTBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataRequestBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAREQUESTBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATAREQUESTBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataRequestBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundDataChunk {
    pub chunk_id: glacier_util::guid::Guid,
    pub chunk_size: u32,
}

pub trait SoundDataChunkTrait: TypeObject {
    fn chunk_id(&self) -> &glacier_util::guid::Guid;
    fn chunk_id_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn chunk_size(&self) -> &u32;
    fn chunk_size_mut(&mut self) -> &mut u32;
}

impl SoundDataChunkTrait for SoundDataChunk {
    fn chunk_id(&self) -> &glacier_util::guid::Guid {
        &self.chunk_id
    }
    fn chunk_id_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.chunk_id
    }
    fn chunk_size(&self) -> &u32 {
        &self.chunk_size
    }
    fn chunk_size_mut(&mut self) -> &mut u32 {
        &mut self.chunk_size
    }
}

pub static SOUNDDATACHUNK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataChunk",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundDataChunk as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChunkId",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(SoundDataChunk, chunk_id),
            },
            FieldInfoData {
                name: "ChunkSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundDataChunk, chunk_size),
            },
        ],
    }),
    array_type: Some(SOUNDDATACHUNK_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundDataChunk {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATACHUNK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATACHUNK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataChunk-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataChunk"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataState {
    #[default]
    SoundDataState_Unavailable = 0,
    SoundDataState_Pending = 1,
    SoundDataState_Cancelled = 2,
    SoundDataState_Lost = 3,
    SoundDataState_Valid = 4,
}

pub static SOUNDDATASTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataState",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATASTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataState {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATASTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATASTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataState-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataState"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataRequestResult {
    #[default]
    SoundDataRequestResult_NotRequested = 0,
    SoundDataRequestResult_Requested = 1,
    SoundDataRequestResult_Available = 2,
}

pub static SOUNDDATAREQUESTRESULT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestResult",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREQUESTRESULT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataRequestResult {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAREQUESTRESULT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATAREQUESTRESULT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataRequestResult-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataRequestResult"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataPrimeResult {
    #[default]
    SoundDataPrimeResult_Failed = 0,
    SoundDataPrimeResult_NoData = 1,
    SoundDataPrimeResult_Requested = 2,
    SoundDataPrimeResult_Available = 3,
}

pub static SOUNDDATAPRIMERESULT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPrimeResult",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAPRIMERESULT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataPrimeResult {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAPRIMERESULT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATAPRIMERESULT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataPrimeResult-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataPrimeResult"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundDataReadPriority {
    #[default]
    SoundDataReadPriority_Low = 0,
    SoundDataReadPriority_Medium = 1,
    SoundDataReadPriority_Normal = 2,
    SoundDataReadPriority_High = 3,
}

pub static SOUNDDATAREADPRIORITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadPriority",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDDATAREADPRIORITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundDataReadPriority {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAREADPRIORITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATAREADPRIORITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReadPriority-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReadPriority"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextSystemAsset {
    pub _glacier_base: super::core::Asset,
    pub contexts: Vec<Option<Arc<Mutex<dyn SoundContextDataTrait>>>>,
    pub context_groups: Vec<Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>>,
}

pub trait SoundContextSystemAssetTrait: super::core::AssetTrait {
    fn contexts(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextDataTrait>>>>;
    fn contexts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextDataTrait>>>>;
    fn context_groups(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>>;
    fn context_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>>;
}

impl SoundContextSystemAssetTrait for SoundContextSystemAsset {
    fn contexts(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextDataTrait>>>> {
        &self.contexts
    }
    fn contexts_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextDataTrait>>>> {
        &mut self.contexts
    }
    fn context_groups(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>> {
        &self.context_groups
    }
    fn context_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>> {
        &mut self.context_groups
    }
}

impl super::core::AssetTrait for SoundContextSystemAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundContextSystemAsset {
}

pub static SOUNDCONTEXTSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextSystemAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Contexts",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundContextData-Array",
                rust_offset: offset_of!(SoundContextSystemAsset, contexts),
            },
            FieldInfoData {
                name: "ContextGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundContextGroupData-Array",
                rust_offset: offset_of!(SoundContextSystemAsset, context_groups),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextSystemAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTSYSTEMASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextSystemAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextGroupData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub interactions: Vec<Option<Arc<Mutex<dyn SoundContextInteractionDataTrait>>>>,
    pub group_type: SoundContextGroupType,
    pub geometry_id: Vec<u32>,
    pub radius: f32,
    pub render_debug: bool,
}

pub trait SoundContextGroupDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn interactions(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextInteractionDataTrait>>>>;
    fn interactions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextInteractionDataTrait>>>>;
    fn group_type(&self) -> &SoundContextGroupType;
    fn group_type_mut(&mut self) -> &mut SoundContextGroupType;
    fn geometry_id(&self) -> &Vec<u32>;
    fn geometry_id_mut(&mut self) -> &mut Vec<u32>;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn render_debug(&self) -> &bool;
    fn render_debug_mut(&mut self) -> &mut bool;
}

impl SoundContextGroupDataTrait for SoundContextGroupData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn interactions(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextInteractionDataTrait>>>> {
        &self.interactions
    }
    fn interactions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextInteractionDataTrait>>>> {
        &mut self.interactions
    }
    fn group_type(&self) -> &SoundContextGroupType {
        &self.group_type
    }
    fn group_type_mut(&mut self) -> &mut SoundContextGroupType {
        &mut self.group_type
    }
    fn geometry_id(&self) -> &Vec<u32> {
        &self.geometry_id
    }
    fn geometry_id_mut(&mut self) -> &mut Vec<u32> {
        &mut self.geometry_id
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn render_debug(&self) -> &bool {
        &self.render_debug
    }
    fn render_debug_mut(&mut self) -> &mut bool {
        &mut self.render_debug
    }
}

impl super::core::DataContainerTrait for SoundContextGroupData {
}

pub static SOUNDCONTEXTGROUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextGroupData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundContextGroupData, name),
            },
            FieldInfoData {
                name: "Interactions",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundContextInteractionData-Array",
                rust_offset: offset_of!(SoundContextGroupData, interactions),
            },
            FieldInfoData {
                name: "GroupType",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextGroupType",
                rust_offset: offset_of!(SoundContextGroupData, group_type),
            },
            FieldInfoData {
                name: "GeometryId",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(SoundContextGroupData, geometry_id),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundContextGroupData, radius),
            },
            FieldInfoData {
                name: "RenderDebug",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundContextGroupData, render_debug),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextGroupData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTGROUPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTGROUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextGroupData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundContextGroupType {
    #[default]
    SoundContextGroupType_Global = 0,
    SoundContextGroupType_Point = 1,
    SoundContextGroupType_Simple = 2,
    SoundContextGroupType_Geometric = 3,
    SoundContextGroupType_Count = 4,
}

pub static SOUNDCONTEXTGROUPTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDCONTEXTGROUPTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundContextGroupType {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTGROUPTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDCONTEXTGROUPTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextGroupType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextGroupType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextInteractionData {
    pub _glacier_base: super::core::DataContainer,
    pub context: Option<Arc<Mutex<dyn SoundContextDataTrait>>>,
    pub interaction_mode: SoundContextInteractionMode,
    pub accumulation: Option<Arc<Mutex<dyn SoundContextAccumulationDataTrait>>>,
    pub bindings: Vec<Option<Arc<Mutex<dyn SoundContextBindingDataTrait>>>>,
    pub execute_all_bindings: bool,
    pub relevance_decay: f32,
    pub priority: u32,
    pub keep_last_value: bool,
}

pub trait SoundContextInteractionDataTrait: super::core::DataContainerTrait {
    fn context(&self) -> &Option<Arc<Mutex<dyn SoundContextDataTrait>>>;
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextDataTrait>>>;
    fn interaction_mode(&self) -> &SoundContextInteractionMode;
    fn interaction_mode_mut(&mut self) -> &mut SoundContextInteractionMode;
    fn accumulation(&self) -> &Option<Arc<Mutex<dyn SoundContextAccumulationDataTrait>>>;
    fn accumulation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextAccumulationDataTrait>>>;
    fn bindings(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextBindingDataTrait>>>>;
    fn bindings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextBindingDataTrait>>>>;
    fn execute_all_bindings(&self) -> &bool;
    fn execute_all_bindings_mut(&mut self) -> &mut bool;
    fn relevance_decay(&self) -> &f32;
    fn relevance_decay_mut(&mut self) -> &mut f32;
    fn priority(&self) -> &u32;
    fn priority_mut(&mut self) -> &mut u32;
    fn keep_last_value(&self) -> &bool;
    fn keep_last_value_mut(&mut self) -> &mut bool;
}

impl SoundContextInteractionDataTrait for SoundContextInteractionData {
    fn context(&self) -> &Option<Arc<Mutex<dyn SoundContextDataTrait>>> {
        &self.context
    }
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextDataTrait>>> {
        &mut self.context
    }
    fn interaction_mode(&self) -> &SoundContextInteractionMode {
        &self.interaction_mode
    }
    fn interaction_mode_mut(&mut self) -> &mut SoundContextInteractionMode {
        &mut self.interaction_mode
    }
    fn accumulation(&self) -> &Option<Arc<Mutex<dyn SoundContextAccumulationDataTrait>>> {
        &self.accumulation
    }
    fn accumulation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextAccumulationDataTrait>>> {
        &mut self.accumulation
    }
    fn bindings(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextBindingDataTrait>>>> {
        &self.bindings
    }
    fn bindings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextBindingDataTrait>>>> {
        &mut self.bindings
    }
    fn execute_all_bindings(&self) -> &bool {
        &self.execute_all_bindings
    }
    fn execute_all_bindings_mut(&mut self) -> &mut bool {
        &mut self.execute_all_bindings
    }
    fn relevance_decay(&self) -> &f32 {
        &self.relevance_decay
    }
    fn relevance_decay_mut(&mut self) -> &mut f32 {
        &mut self.relevance_decay
    }
    fn priority(&self) -> &u32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut u32 {
        &mut self.priority
    }
    fn keep_last_value(&self) -> &bool {
        &self.keep_last_value
    }
    fn keep_last_value_mut(&mut self) -> &mut bool {
        &mut self.keep_last_value
    }
}

impl super::core::DataContainerTrait for SoundContextInteractionData {
}

pub static SOUNDCONTEXTINTERACTIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextInteractionData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextData",
                rust_offset: offset_of!(SoundContextInteractionData, context),
            },
            FieldInfoData {
                name: "InteractionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextInteractionMode",
                rust_offset: offset_of!(SoundContextInteractionData, interaction_mode),
            },
            FieldInfoData {
                name: "Accumulation",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextAccumulationData",
                rust_offset: offset_of!(SoundContextInteractionData, accumulation),
            },
            FieldInfoData {
                name: "Bindings",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundContextBindingData-Array",
                rust_offset: offset_of!(SoundContextInteractionData, bindings),
            },
            FieldInfoData {
                name: "ExecuteAllBindings",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundContextInteractionData, execute_all_bindings),
            },
            FieldInfoData {
                name: "RelevanceDecay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundContextInteractionData, relevance_decay),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundContextInteractionData, priority),
            },
            FieldInfoData {
                name: "KeepLastValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundContextInteractionData, keep_last_value),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextInteractionData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTINTERACTIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTINTERACTIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextInteractionData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundContextInteractionMode {
    #[default]
    SoundContextInteractionMode_Import = 0,
    SoundContextInteractionMode_Export = 1,
    SoundContextInteractionMode_Dynamic = 2,
}

pub static SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDCONTEXTINTERACTIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundContextInteractionMode {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTINTERACTIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDCONTEXTINTERACTIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextInteractionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextInteractionMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PrioritySoundContextAccumulationData {
    pub _glacier_base: SoundContextAccumulationData,
    pub mode: PrioritySoundContextAccumulationMode,
}

pub trait PrioritySoundContextAccumulationDataTrait: SoundContextAccumulationDataTrait {
    fn mode(&self) -> &PrioritySoundContextAccumulationMode;
    fn mode_mut(&mut self) -> &mut PrioritySoundContextAccumulationMode;
}

impl PrioritySoundContextAccumulationDataTrait for PrioritySoundContextAccumulationData {
    fn mode(&self) -> &PrioritySoundContextAccumulationMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut PrioritySoundContextAccumulationMode {
        &mut self.mode
    }
}

impl SoundContextAccumulationDataTrait for PrioritySoundContextAccumulationData {
}

impl super::core::DataContainerTrait for PrioritySoundContextAccumulationData {
}

pub static PRIORITYSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PrioritySoundContextAccumulationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "PrioritySoundContextAccumulationMode",
                rust_offset: offset_of!(PrioritySoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(PRIORITYSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PrioritySoundContextAccumulationData {
    fn type_info(&self) -> &'static TypeInfo {
        PRIORITYSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PRIORITYSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PrioritySoundContextAccumulationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PrioritySoundContextAccumulationMode {
    #[default]
    PrioritySoundContextAccumulationMode_Highest = 0,
    PrioritySoundContextAccumulationMode_Lowest = 1,
}

pub static PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PRIORITYSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PrioritySoundContextAccumulationMode {
    fn type_info(&self) -> &'static TypeInfo {
        PRIORITYSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PRIORITYSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PrioritySoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PrioritySoundContextAccumulationMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicSoundContextAccumulationData {
    pub _glacier_base: SoundContextAccumulationData,
    pub mode: LogicSoundContextAccumulationMode,
}

pub trait LogicSoundContextAccumulationDataTrait: SoundContextAccumulationDataTrait {
    fn mode(&self) -> &LogicSoundContextAccumulationMode;
    fn mode_mut(&mut self) -> &mut LogicSoundContextAccumulationMode;
}

impl LogicSoundContextAccumulationDataTrait for LogicSoundContextAccumulationData {
    fn mode(&self) -> &LogicSoundContextAccumulationMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut LogicSoundContextAccumulationMode {
        &mut self.mode
    }
}

impl SoundContextAccumulationDataTrait for LogicSoundContextAccumulationData {
}

impl super::core::DataContainerTrait for LogicSoundContextAccumulationData {
}

pub static LOGICSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicSoundContextAccumulationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "LogicSoundContextAccumulationMode",
                rust_offset: offset_of!(LogicSoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(LOGICSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicSoundContextAccumulationData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicSoundContextAccumulationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum LogicSoundContextAccumulationMode {
    #[default]
    LogicSoundContextAccumulationMode_Or = 0,
    LogicSoundContextAccumulationMode_And = 1,
}

pub static LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LOGICSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LogicSoundContextAccumulationMode {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LOGICSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicSoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicSoundContextAccumulationMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OrderSoundContextAccumulationData {
    pub _glacier_base: SoundContextAccumulationData,
    pub mode: OrderSoundContextAccumulationMode,
}

pub trait OrderSoundContextAccumulationDataTrait: SoundContextAccumulationDataTrait {
    fn mode(&self) -> &OrderSoundContextAccumulationMode;
    fn mode_mut(&mut self) -> &mut OrderSoundContextAccumulationMode;
}

impl OrderSoundContextAccumulationDataTrait for OrderSoundContextAccumulationData {
    fn mode(&self) -> &OrderSoundContextAccumulationMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut OrderSoundContextAccumulationMode {
        &mut self.mode
    }
}

impl SoundContextAccumulationDataTrait for OrderSoundContextAccumulationData {
}

impl super::core::DataContainerTrait for OrderSoundContextAccumulationData {
}

pub static ORDERSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrderSoundContextAccumulationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "OrderSoundContextAccumulationMode",
                rust_offset: offset_of!(OrderSoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(ORDERSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrderSoundContextAccumulationData {
    fn type_info(&self) -> &'static TypeInfo {
        ORDERSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ORDERSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrderSoundContextAccumulationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum OrderSoundContextAccumulationMode {
    #[default]
    OrderSoundContextAccumulationMode_Newest = 0,
    OrderSoundContextAccumulationMode_Oldest = 1,
}

pub static ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(ORDERSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OrderSoundContextAccumulationMode {
    fn type_info(&self) -> &'static TypeInfo {
        ORDERSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ORDERSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrderSoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrderSoundContextAccumulationMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MathSoundContextAccumulationData {
    pub _glacier_base: SoundContextAccumulationData,
    pub mode: MathSoundContextAccumulationMode,
}

pub trait MathSoundContextAccumulationDataTrait: SoundContextAccumulationDataTrait {
    fn mode(&self) -> &MathSoundContextAccumulationMode;
    fn mode_mut(&mut self) -> &mut MathSoundContextAccumulationMode;
}

impl MathSoundContextAccumulationDataTrait for MathSoundContextAccumulationData {
    fn mode(&self) -> &MathSoundContextAccumulationMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut MathSoundContextAccumulationMode {
        &mut self.mode
    }
}

impl SoundContextAccumulationDataTrait for MathSoundContextAccumulationData {
}

impl super::core::DataContainerTrait for MathSoundContextAccumulationData {
}

pub static MATHSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MathSoundContextAccumulationData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "MathSoundContextAccumulationMode",
                rust_offset: offset_of!(MathSoundContextAccumulationData, mode),
            },
        ],
    }),
    array_type: Some(MATHSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MathSoundContextAccumulationData {
    fn type_info(&self) -> &'static TypeInfo {
        MATHSOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATHSOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MathSoundContextAccumulationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MathSoundContextAccumulationMode {
    #[default]
    MathSoundContextAccumulationMode_Multiply = 0,
    MathSoundContextAccumulationMode_Add = 1,
    MathSoundContextAccumulationMode_Min = 2,
    MathSoundContextAccumulationMode_Max = 3,
}

pub static MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MATHSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MathSoundContextAccumulationMode {
    fn type_info(&self) -> &'static TypeInfo {
        MATHSOUNDCONTEXTACCUMULATIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATHSOUNDCONTEXTACCUMULATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MathSoundContextAccumulationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MathSoundContextAccumulationMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextAccumulationData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SoundContextAccumulationDataTrait: super::core::DataContainerTrait {
}

impl SoundContextAccumulationDataTrait for SoundContextAccumulationData {
}

impl super::core::DataContainerTrait for SoundContextAccumulationData {
}

pub static SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextAccumulationData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextAccumulationData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextAccumulationData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTACCUMULATIONDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTACCUMULATIONDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextAccumulationData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextAccumulationData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObstructionSoundContextBindingData {
    pub _glacier_base: SpatialSoundContextBindingData,
}

pub trait ObstructionSoundContextBindingDataTrait: SpatialSoundContextBindingDataTrait {
}

impl ObstructionSoundContextBindingDataTrait for ObstructionSoundContextBindingData {
}

impl SpatialSoundContextBindingDataTrait for ObstructionSoundContextBindingData {
    fn must_encapsulate(&self) -> &bool {
        self._glacier_base.must_encapsulate()
    }
    fn must_encapsulate_mut(&mut self) -> &mut bool {
        self._glacier_base.must_encapsulate_mut()
    }
}

impl SoundContextBindingDataTrait for ObstructionSoundContextBindingData {
}

impl super::core::DataContainerTrait for ObstructionSoundContextBindingData {
}

pub static OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObstructionSoundContextBindingData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObstructionSoundContextBindingData {
    fn type_info(&self) -> &'static TypeInfo {
        OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBSTRUCTIONSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObstructionSoundContextBindingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SpatialSoundContextBindingData {
    pub _glacier_base: SoundContextBindingData,
    pub must_encapsulate: bool,
}

pub trait SpatialSoundContextBindingDataTrait: SoundContextBindingDataTrait {
    fn must_encapsulate(&self) -> &bool;
    fn must_encapsulate_mut(&mut self) -> &mut bool;
}

impl SpatialSoundContextBindingDataTrait for SpatialSoundContextBindingData {
    fn must_encapsulate(&self) -> &bool {
        &self.must_encapsulate
    }
    fn must_encapsulate_mut(&mut self) -> &mut bool {
        &mut self.must_encapsulate
    }
}

impl SoundContextBindingDataTrait for SpatialSoundContextBindingData {
}

impl super::core::DataContainerTrait for SpatialSoundContextBindingData {
}

pub static SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialSoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTBINDINGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SpatialSoundContextBindingData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MustEncapsulate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SpatialSoundContextBindingData, must_encapsulate),
            },
        ],
    }),
    array_type: Some(SPATIALSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SpatialSoundContextBindingData {
    fn type_info(&self) -> &'static TypeInfo {
        SPATIALSOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SPATIALSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SpatialSoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SpatialSoundContextBindingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkedSoundContextBindingData {
    pub _glacier_base: SoundContextBindingData,
}

pub trait LinkedSoundContextBindingDataTrait: SoundContextBindingDataTrait {
}

impl LinkedSoundContextBindingDataTrait for LinkedSoundContextBindingData {
}

impl SoundContextBindingDataTrait for LinkedSoundContextBindingData {
}

impl super::core::DataContainerTrait for LinkedSoundContextBindingData {
}

pub static LINKEDSOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedSoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTBINDINGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkedSoundContextBindingData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(LINKEDSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkedSoundContextBindingData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKEDSOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKEDSOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkedSoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkedSoundContextBindingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextBindingData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SoundContextBindingDataTrait: super::core::DataContainerTrait {
}

impl SoundContextBindingDataTrait for SoundContextBindingData {
}

impl super::core::DataContainerTrait for SoundContextBindingData {
}

pub static SOUNDCONTEXTBINDINGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextBindingData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextBindingData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextBindingData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTBINDINGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTBINDINGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextBindingData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextBindingData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObstructionSoundContextData {
    pub _glacier_base: SoundContextData,
}

pub trait ObstructionSoundContextDataTrait: SoundContextDataTrait {
}

impl ObstructionSoundContextDataTrait for ObstructionSoundContextData {
}

impl SoundContextDataTrait for ObstructionSoundContextData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ObstructionSoundContextData {
}

pub static OBSTRUCTIONSOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObstructionSoundContextData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(OBSTRUCTIONSOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObstructionSoundContextData {
    fn type_info(&self) -> &'static TypeInfo {
        OBSTRUCTIONSOUNDCONTEXTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBSTRUCTIONSOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObstructionSoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObstructionSoundContextData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSoundContextData {
    pub _glacier_base: SoundContextData,
}

pub trait EventSoundContextDataTrait: SoundContextDataTrait {
}

impl EventSoundContextDataTrait for EventSoundContextData {
}

impl SoundContextDataTrait for EventSoundContextData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for EventSoundContextData {
}

pub static EVENTSOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSoundContextData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(EVENTSOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSoundContextData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSOUNDCONTEXTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSoundContextData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueSoundContextData {
    pub _glacier_base: SoundContextData,
    pub default_value: f32,
}

pub trait ValueSoundContextDataTrait: SoundContextDataTrait {
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
}

impl ValueSoundContextDataTrait for ValueSoundContextData {
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
}

impl SoundContextDataTrait for ValueSoundContextData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ValueSoundContextData {
}

pub static VALUESOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDCONTEXTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueSoundContextData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ValueSoundContextData, default_value),
            },
        ],
    }),
    array_type: Some(VALUESOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueSoundContextData {
    fn type_info(&self) -> &'static TypeInfo {
        VALUESOUNDCONTEXTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUESOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueSoundContextData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
}

pub trait SoundContextDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
}

impl SoundContextDataTrait for SoundContextData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
}

impl super::core::DataContainerTrait for SoundContextData {
}

pub static SOUNDCONTEXTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundContextData, name),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioSettings {
    pub _glacier_base: super::core::DataContainer,
    pub enable: bool,
    pub data_manager_cache_size: u32,
    pub data_manager_cache_rsx_size: u32,
    pub data_manager_max_read_issue_count: u32,
    pub data_manager_max_read_active_count: u32,
    pub data_manager_max_trim_size: u32,
    pub data_manager_allow_chunk_loads_while_load_screen_active: bool,
    pub data_manager_allow_chunk_loads_while_loading_bundles: bool,
    pub audio_core_cpu_load_limit: f32,
    pub audio_core_cpu_load_recovery: f32,
    pub audio_core_thread: i32,
    pub audio_core_thread_priority: i32,
    pub audio_core_mix_job_thread_count: i32,
    pub audio_core_max_mix_job_thread_count: i32,
    pub audio_core_multiple_mix_jobs_enabled: bool,
    pub audio_core_min_proc_stage_voices_to_go_wide: i32,
    pub audio_core_apu_heap_size_cached: u32,
    pub audio_core_apu_heap_size_non_cached: u32,
    pub audio_core_minium_mix_ahead: f32,
    pub audio_core_target_mix_ahead: f32,
    pub audio_core_max_channel_count: u32,
    pub delay_line_alloc_size: u32,
    pub reverb_alloc_size: u32,
    pub hdr_suspension_threshold: f32,
    pub hdr_zombie_threshold: f32,
    pub hdr_enable_suspension_threshold: f32,
    pub sound_speed: f32,
    pub sound_doppler_factor: f32,
    pub sound_pitch_smooth_factor: f32,
    pub pan_distance_clamp: bool,
    pub pan_distance_clamp_value: f32,
    pub music_request_buffer_time: f32,
    pub dac_delay: u32,
    pub dac_amplitude: f32,
    pub max_expected_wave_asset_count: u32,
}

pub trait AudioSettingsTrait: super::core::DataContainerTrait {
    fn enable(&self) -> &bool;
    fn enable_mut(&mut self) -> &mut bool;
    fn data_manager_cache_size(&self) -> &u32;
    fn data_manager_cache_size_mut(&mut self) -> &mut u32;
    fn data_manager_cache_rsx_size(&self) -> &u32;
    fn data_manager_cache_rsx_size_mut(&mut self) -> &mut u32;
    fn data_manager_max_read_issue_count(&self) -> &u32;
    fn data_manager_max_read_issue_count_mut(&mut self) -> &mut u32;
    fn data_manager_max_read_active_count(&self) -> &u32;
    fn data_manager_max_read_active_count_mut(&mut self) -> &mut u32;
    fn data_manager_max_trim_size(&self) -> &u32;
    fn data_manager_max_trim_size_mut(&mut self) -> &mut u32;
    fn data_manager_allow_chunk_loads_while_load_screen_active(&self) -> &bool;
    fn data_manager_allow_chunk_loads_while_load_screen_active_mut(&mut self) -> &mut bool;
    fn data_manager_allow_chunk_loads_while_loading_bundles(&self) -> &bool;
    fn data_manager_allow_chunk_loads_while_loading_bundles_mut(&mut self) -> &mut bool;
    fn audio_core_cpu_load_limit(&self) -> &f32;
    fn audio_core_cpu_load_limit_mut(&mut self) -> &mut f32;
    fn audio_core_cpu_load_recovery(&self) -> &f32;
    fn audio_core_cpu_load_recovery_mut(&mut self) -> &mut f32;
    fn audio_core_thread(&self) -> &i32;
    fn audio_core_thread_mut(&mut self) -> &mut i32;
    fn audio_core_thread_priority(&self) -> &i32;
    fn audio_core_thread_priority_mut(&mut self) -> &mut i32;
    fn audio_core_mix_job_thread_count(&self) -> &i32;
    fn audio_core_mix_job_thread_count_mut(&mut self) -> &mut i32;
    fn audio_core_max_mix_job_thread_count(&self) -> &i32;
    fn audio_core_max_mix_job_thread_count_mut(&mut self) -> &mut i32;
    fn audio_core_multiple_mix_jobs_enabled(&self) -> &bool;
    fn audio_core_multiple_mix_jobs_enabled_mut(&mut self) -> &mut bool;
    fn audio_core_min_proc_stage_voices_to_go_wide(&self) -> &i32;
    fn audio_core_min_proc_stage_voices_to_go_wide_mut(&mut self) -> &mut i32;
    fn audio_core_apu_heap_size_cached(&self) -> &u32;
    fn audio_core_apu_heap_size_cached_mut(&mut self) -> &mut u32;
    fn audio_core_apu_heap_size_non_cached(&self) -> &u32;
    fn audio_core_apu_heap_size_non_cached_mut(&mut self) -> &mut u32;
    fn audio_core_minium_mix_ahead(&self) -> &f32;
    fn audio_core_minium_mix_ahead_mut(&mut self) -> &mut f32;
    fn audio_core_target_mix_ahead(&self) -> &f32;
    fn audio_core_target_mix_ahead_mut(&mut self) -> &mut f32;
    fn audio_core_max_channel_count(&self) -> &u32;
    fn audio_core_max_channel_count_mut(&mut self) -> &mut u32;
    fn delay_line_alloc_size(&self) -> &u32;
    fn delay_line_alloc_size_mut(&mut self) -> &mut u32;
    fn reverb_alloc_size(&self) -> &u32;
    fn reverb_alloc_size_mut(&mut self) -> &mut u32;
    fn hdr_suspension_threshold(&self) -> &f32;
    fn hdr_suspension_threshold_mut(&mut self) -> &mut f32;
    fn hdr_zombie_threshold(&self) -> &f32;
    fn hdr_zombie_threshold_mut(&mut self) -> &mut f32;
    fn hdr_enable_suspension_threshold(&self) -> &f32;
    fn hdr_enable_suspension_threshold_mut(&mut self) -> &mut f32;
    fn sound_speed(&self) -> &f32;
    fn sound_speed_mut(&mut self) -> &mut f32;
    fn sound_doppler_factor(&self) -> &f32;
    fn sound_doppler_factor_mut(&mut self) -> &mut f32;
    fn sound_pitch_smooth_factor(&self) -> &f32;
    fn sound_pitch_smooth_factor_mut(&mut self) -> &mut f32;
    fn pan_distance_clamp(&self) -> &bool;
    fn pan_distance_clamp_mut(&mut self) -> &mut bool;
    fn pan_distance_clamp_value(&self) -> &f32;
    fn pan_distance_clamp_value_mut(&mut self) -> &mut f32;
    fn music_request_buffer_time(&self) -> &f32;
    fn music_request_buffer_time_mut(&mut self) -> &mut f32;
    fn dac_delay(&self) -> &u32;
    fn dac_delay_mut(&mut self) -> &mut u32;
    fn dac_amplitude(&self) -> &f32;
    fn dac_amplitude_mut(&mut self) -> &mut f32;
    fn max_expected_wave_asset_count(&self) -> &u32;
    fn max_expected_wave_asset_count_mut(&mut self) -> &mut u32;
}

impl AudioSettingsTrait for AudioSettings {
    fn enable(&self) -> &bool {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut bool {
        &mut self.enable
    }
    fn data_manager_cache_size(&self) -> &u32 {
        &self.data_manager_cache_size
    }
    fn data_manager_cache_size_mut(&mut self) -> &mut u32 {
        &mut self.data_manager_cache_size
    }
    fn data_manager_cache_rsx_size(&self) -> &u32 {
        &self.data_manager_cache_rsx_size
    }
    fn data_manager_cache_rsx_size_mut(&mut self) -> &mut u32 {
        &mut self.data_manager_cache_rsx_size
    }
    fn data_manager_max_read_issue_count(&self) -> &u32 {
        &self.data_manager_max_read_issue_count
    }
    fn data_manager_max_read_issue_count_mut(&mut self) -> &mut u32 {
        &mut self.data_manager_max_read_issue_count
    }
    fn data_manager_max_read_active_count(&self) -> &u32 {
        &self.data_manager_max_read_active_count
    }
    fn data_manager_max_read_active_count_mut(&mut self) -> &mut u32 {
        &mut self.data_manager_max_read_active_count
    }
    fn data_manager_max_trim_size(&self) -> &u32 {
        &self.data_manager_max_trim_size
    }
    fn data_manager_max_trim_size_mut(&mut self) -> &mut u32 {
        &mut self.data_manager_max_trim_size
    }
    fn data_manager_allow_chunk_loads_while_load_screen_active(&self) -> &bool {
        &self.data_manager_allow_chunk_loads_while_load_screen_active
    }
    fn data_manager_allow_chunk_loads_while_load_screen_active_mut(&mut self) -> &mut bool {
        &mut self.data_manager_allow_chunk_loads_while_load_screen_active
    }
    fn data_manager_allow_chunk_loads_while_loading_bundles(&self) -> &bool {
        &self.data_manager_allow_chunk_loads_while_loading_bundles
    }
    fn data_manager_allow_chunk_loads_while_loading_bundles_mut(&mut self) -> &mut bool {
        &mut self.data_manager_allow_chunk_loads_while_loading_bundles
    }
    fn audio_core_cpu_load_limit(&self) -> &f32 {
        &self.audio_core_cpu_load_limit
    }
    fn audio_core_cpu_load_limit_mut(&mut self) -> &mut f32 {
        &mut self.audio_core_cpu_load_limit
    }
    fn audio_core_cpu_load_recovery(&self) -> &f32 {
        &self.audio_core_cpu_load_recovery
    }
    fn audio_core_cpu_load_recovery_mut(&mut self) -> &mut f32 {
        &mut self.audio_core_cpu_load_recovery
    }
    fn audio_core_thread(&self) -> &i32 {
        &self.audio_core_thread
    }
    fn audio_core_thread_mut(&mut self) -> &mut i32 {
        &mut self.audio_core_thread
    }
    fn audio_core_thread_priority(&self) -> &i32 {
        &self.audio_core_thread_priority
    }
    fn audio_core_thread_priority_mut(&mut self) -> &mut i32 {
        &mut self.audio_core_thread_priority
    }
    fn audio_core_mix_job_thread_count(&self) -> &i32 {
        &self.audio_core_mix_job_thread_count
    }
    fn audio_core_mix_job_thread_count_mut(&mut self) -> &mut i32 {
        &mut self.audio_core_mix_job_thread_count
    }
    fn audio_core_max_mix_job_thread_count(&self) -> &i32 {
        &self.audio_core_max_mix_job_thread_count
    }
    fn audio_core_max_mix_job_thread_count_mut(&mut self) -> &mut i32 {
        &mut self.audio_core_max_mix_job_thread_count
    }
    fn audio_core_multiple_mix_jobs_enabled(&self) -> &bool {
        &self.audio_core_multiple_mix_jobs_enabled
    }
    fn audio_core_multiple_mix_jobs_enabled_mut(&mut self) -> &mut bool {
        &mut self.audio_core_multiple_mix_jobs_enabled
    }
    fn audio_core_min_proc_stage_voices_to_go_wide(&self) -> &i32 {
        &self.audio_core_min_proc_stage_voices_to_go_wide
    }
    fn audio_core_min_proc_stage_voices_to_go_wide_mut(&mut self) -> &mut i32 {
        &mut self.audio_core_min_proc_stage_voices_to_go_wide
    }
    fn audio_core_apu_heap_size_cached(&self) -> &u32 {
        &self.audio_core_apu_heap_size_cached
    }
    fn audio_core_apu_heap_size_cached_mut(&mut self) -> &mut u32 {
        &mut self.audio_core_apu_heap_size_cached
    }
    fn audio_core_apu_heap_size_non_cached(&self) -> &u32 {
        &self.audio_core_apu_heap_size_non_cached
    }
    fn audio_core_apu_heap_size_non_cached_mut(&mut self) -> &mut u32 {
        &mut self.audio_core_apu_heap_size_non_cached
    }
    fn audio_core_minium_mix_ahead(&self) -> &f32 {
        &self.audio_core_minium_mix_ahead
    }
    fn audio_core_minium_mix_ahead_mut(&mut self) -> &mut f32 {
        &mut self.audio_core_minium_mix_ahead
    }
    fn audio_core_target_mix_ahead(&self) -> &f32 {
        &self.audio_core_target_mix_ahead
    }
    fn audio_core_target_mix_ahead_mut(&mut self) -> &mut f32 {
        &mut self.audio_core_target_mix_ahead
    }
    fn audio_core_max_channel_count(&self) -> &u32 {
        &self.audio_core_max_channel_count
    }
    fn audio_core_max_channel_count_mut(&mut self) -> &mut u32 {
        &mut self.audio_core_max_channel_count
    }
    fn delay_line_alloc_size(&self) -> &u32 {
        &self.delay_line_alloc_size
    }
    fn delay_line_alloc_size_mut(&mut self) -> &mut u32 {
        &mut self.delay_line_alloc_size
    }
    fn reverb_alloc_size(&self) -> &u32 {
        &self.reverb_alloc_size
    }
    fn reverb_alloc_size_mut(&mut self) -> &mut u32 {
        &mut self.reverb_alloc_size
    }
    fn hdr_suspension_threshold(&self) -> &f32 {
        &self.hdr_suspension_threshold
    }
    fn hdr_suspension_threshold_mut(&mut self) -> &mut f32 {
        &mut self.hdr_suspension_threshold
    }
    fn hdr_zombie_threshold(&self) -> &f32 {
        &self.hdr_zombie_threshold
    }
    fn hdr_zombie_threshold_mut(&mut self) -> &mut f32 {
        &mut self.hdr_zombie_threshold
    }
    fn hdr_enable_suspension_threshold(&self) -> &f32 {
        &self.hdr_enable_suspension_threshold
    }
    fn hdr_enable_suspension_threshold_mut(&mut self) -> &mut f32 {
        &mut self.hdr_enable_suspension_threshold
    }
    fn sound_speed(&self) -> &f32 {
        &self.sound_speed
    }
    fn sound_speed_mut(&mut self) -> &mut f32 {
        &mut self.sound_speed
    }
    fn sound_doppler_factor(&self) -> &f32 {
        &self.sound_doppler_factor
    }
    fn sound_doppler_factor_mut(&mut self) -> &mut f32 {
        &mut self.sound_doppler_factor
    }
    fn sound_pitch_smooth_factor(&self) -> &f32 {
        &self.sound_pitch_smooth_factor
    }
    fn sound_pitch_smooth_factor_mut(&mut self) -> &mut f32 {
        &mut self.sound_pitch_smooth_factor
    }
    fn pan_distance_clamp(&self) -> &bool {
        &self.pan_distance_clamp
    }
    fn pan_distance_clamp_mut(&mut self) -> &mut bool {
        &mut self.pan_distance_clamp
    }
    fn pan_distance_clamp_value(&self) -> &f32 {
        &self.pan_distance_clamp_value
    }
    fn pan_distance_clamp_value_mut(&mut self) -> &mut f32 {
        &mut self.pan_distance_clamp_value
    }
    fn music_request_buffer_time(&self) -> &f32 {
        &self.music_request_buffer_time
    }
    fn music_request_buffer_time_mut(&mut self) -> &mut f32 {
        &mut self.music_request_buffer_time
    }
    fn dac_delay(&self) -> &u32 {
        &self.dac_delay
    }
    fn dac_delay_mut(&mut self) -> &mut u32 {
        &mut self.dac_delay
    }
    fn dac_amplitude(&self) -> &f32 {
        &self.dac_amplitude
    }
    fn dac_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.dac_amplitude
    }
    fn max_expected_wave_asset_count(&self) -> &u32 {
        &self.max_expected_wave_asset_count
    }
    fn max_expected_wave_asset_count_mut(&mut self) -> &mut u32 {
        &mut self.max_expected_wave_asset_count
    }
}

impl super::core::DataContainerTrait for AudioSettings {
}

pub static AUDIOSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioSettings, enable),
            },
            FieldInfoData {
                name: "DataManagerCacheSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, data_manager_cache_size),
            },
            FieldInfoData {
                name: "DataManagerCacheRsxSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, data_manager_cache_rsx_size),
            },
            FieldInfoData {
                name: "DataManagerMaxReadIssueCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, data_manager_max_read_issue_count),
            },
            FieldInfoData {
                name: "DataManagerMaxReadActiveCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, data_manager_max_read_active_count),
            },
            FieldInfoData {
                name: "DataManagerMaxTrimSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, data_manager_max_trim_size),
            },
            FieldInfoData {
                name: "DataManagerAllowChunkLoadsWhileLoadScreenActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioSettings, data_manager_allow_chunk_loads_while_load_screen_active),
            },
            FieldInfoData {
                name: "DataManagerAllowChunkLoadsWhileLoadingBundles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioSettings, data_manager_allow_chunk_loads_while_loading_bundles),
            },
            FieldInfoData {
                name: "AudioCoreCpuLoadLimit",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, audio_core_cpu_load_limit),
            },
            FieldInfoData {
                name: "AudioCoreCpuLoadRecovery",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, audio_core_cpu_load_recovery),
            },
            FieldInfoData {
                name: "AudioCoreThread",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AudioSettings, audio_core_thread),
            },
            FieldInfoData {
                name: "AudioCoreThreadPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AudioSettings, audio_core_thread_priority),
            },
            FieldInfoData {
                name: "AudioCoreMixJobThreadCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AudioSettings, audio_core_mix_job_thread_count),
            },
            FieldInfoData {
                name: "AudioCoreMaxMixJobThreadCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AudioSettings, audio_core_max_mix_job_thread_count),
            },
            FieldInfoData {
                name: "AudioCoreMultipleMixJobsEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioSettings, audio_core_multiple_mix_jobs_enabled),
            },
            FieldInfoData {
                name: "AudioCoreMinProcStageVoicesToGoWide",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(AudioSettings, audio_core_min_proc_stage_voices_to_go_wide),
            },
            FieldInfoData {
                name: "AudioCoreApuHeapSizeCached",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, audio_core_apu_heap_size_cached),
            },
            FieldInfoData {
                name: "AudioCoreApuHeapSizeNonCached",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, audio_core_apu_heap_size_non_cached),
            },
            FieldInfoData {
                name: "AudioCoreMiniumMixAhead",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, audio_core_minium_mix_ahead),
            },
            FieldInfoData {
                name: "AudioCoreTargetMixAhead",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, audio_core_target_mix_ahead),
            },
            FieldInfoData {
                name: "AudioCoreMaxChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, audio_core_max_channel_count),
            },
            FieldInfoData {
                name: "DelayLineAllocSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, delay_line_alloc_size),
            },
            FieldInfoData {
                name: "ReverbAllocSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, reverb_alloc_size),
            },
            FieldInfoData {
                name: "HdrSuspensionThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, hdr_suspension_threshold),
            },
            FieldInfoData {
                name: "HdrZombieThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, hdr_zombie_threshold),
            },
            FieldInfoData {
                name: "HdrEnableSuspensionThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, hdr_enable_suspension_threshold),
            },
            FieldInfoData {
                name: "SoundSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, sound_speed),
            },
            FieldInfoData {
                name: "SoundDopplerFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, sound_doppler_factor),
            },
            FieldInfoData {
                name: "SoundPitchSmoothFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, sound_pitch_smooth_factor),
            },
            FieldInfoData {
                name: "PanDistanceClamp",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioSettings, pan_distance_clamp),
            },
            FieldInfoData {
                name: "PanDistanceClampValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, pan_distance_clamp_value),
            },
            FieldInfoData {
                name: "MusicRequestBufferTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, music_request_buffer_time),
            },
            FieldInfoData {
                name: "DacDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, dac_delay),
            },
            FieldInfoData {
                name: "DacAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioSettings, dac_amplitude),
            },
            FieldInfoData {
                name: "MaxExpectedWaveAssetCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSettings, max_expected_wave_asset_count),
            },
        ],
    }),
    array_type: Some(AUDIOSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioSettings {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundPatchConfigurationDebugData {
    pub _glacier_base: super::core::DataContainer,
    pub solo_output_nodes: Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>,
}

pub trait SoundPatchConfigurationDebugDataTrait: super::core::DataContainerTrait {
    fn solo_output_nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
    fn solo_output_nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
}

impl SoundPatchConfigurationDebugDataTrait for SoundPatchConfigurationDebugData {
    fn solo_output_nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &self.solo_output_nodes
    }
    fn solo_output_nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &mut self.solo_output_nodes
    }
}

impl super::core::DataContainerTrait for SoundPatchConfigurationDebugData {
}

pub static SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationDebugData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundPatchConfigurationDebugData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoloOutputNodes",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphNodeData-Array",
                rust_offset: offset_of!(SoundPatchConfigurationDebugData, solo_output_nodes),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHCONFIGURATIONDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchConfigurationDebugData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPATCHCONFIGURATIONDEBUGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDPATCHCONFIGURATIONDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchConfigurationDebugData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundPatchConfigurationAsset {
    pub _glacier_base: SoundAsset,
    pub sound: Option<Arc<Mutex<dyn SoundPatchAssetTrait>>>,
    pub loudness: f32,
    pub scope: Option<Arc<Mutex<dyn SoundScopeDataTrait>>>,
    pub radius: f32,
    pub doppler_factor: f32,
    pub master_pitch: f32,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
    pub node_configs: Vec<Option<Arc<Mutex<dyn AudioGraphNodeConfigDataTrait>>>>,
    pub parameter_configs: Vec<Option<Arc<Mutex<dyn AudioGraphParameterConfigDataTrait>>>>,
    pub debug_data: Option<Arc<Mutex<dyn SoundPatchConfigurationDebugDataTrait>>>,
    pub is_loudness_configured: bool,
    pub is_scope_configured: bool,
    pub is_radius_configured: bool,
    pub is_doppler_factor_configured: bool,
    pub is_master_pitch_configured: bool,
    pub is_mixer_configured: bool,
}

pub trait SoundPatchConfigurationAssetTrait: SoundAssetTrait {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundPatchAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundPatchAssetTrait>>>;
    fn loudness(&self) -> &f32;
    fn loudness_mut(&mut self) -> &mut f32;
    fn scope(&self) -> &Option<Arc<Mutex<dyn SoundScopeDataTrait>>>;
    fn scope_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeDataTrait>>>;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn doppler_factor(&self) -> &f32;
    fn doppler_factor_mut(&mut self) -> &mut f32;
    fn master_pitch(&self) -> &f32;
    fn master_pitch_mut(&mut self) -> &mut f32;
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn node_configs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeConfigDataTrait>>>>;
    fn node_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeConfigDataTrait>>>>;
    fn parameter_configs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterConfigDataTrait>>>>;
    fn parameter_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterConfigDataTrait>>>>;
    fn debug_data(&self) -> &Option<Arc<Mutex<dyn SoundPatchConfigurationDebugDataTrait>>>;
    fn debug_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundPatchConfigurationDebugDataTrait>>>;
    fn is_loudness_configured(&self) -> &bool;
    fn is_loudness_configured_mut(&mut self) -> &mut bool;
    fn is_scope_configured(&self) -> &bool;
    fn is_scope_configured_mut(&mut self) -> &mut bool;
    fn is_radius_configured(&self) -> &bool;
    fn is_radius_configured_mut(&mut self) -> &mut bool;
    fn is_doppler_factor_configured(&self) -> &bool;
    fn is_doppler_factor_configured_mut(&mut self) -> &mut bool;
    fn is_master_pitch_configured(&self) -> &bool;
    fn is_master_pitch_configured_mut(&mut self) -> &mut bool;
    fn is_mixer_configured(&self) -> &bool;
    fn is_mixer_configured_mut(&mut self) -> &mut bool;
}

impl SoundPatchConfigurationAssetTrait for SoundPatchConfigurationAsset {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundPatchAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundPatchAssetTrait>>> {
        &mut self.sound
    }
    fn loudness(&self) -> &f32 {
        &self.loudness
    }
    fn loudness_mut(&mut self) -> &mut f32 {
        &mut self.loudness
    }
    fn scope(&self) -> &Option<Arc<Mutex<dyn SoundScopeDataTrait>>> {
        &self.scope
    }
    fn scope_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeDataTrait>>> {
        &mut self.scope
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn doppler_factor(&self) -> &f32 {
        &self.doppler_factor
    }
    fn doppler_factor_mut(&mut self) -> &mut f32 {
        &mut self.doppler_factor
    }
    fn master_pitch(&self) -> &f32 {
        &self.master_pitch
    }
    fn master_pitch_mut(&mut self) -> &mut f32 {
        &mut self.master_pitch
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
    fn node_configs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeConfigDataTrait>>>> {
        &self.node_configs
    }
    fn node_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeConfigDataTrait>>>> {
        &mut self.node_configs
    }
    fn parameter_configs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterConfigDataTrait>>>> {
        &self.parameter_configs
    }
    fn parameter_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterConfigDataTrait>>>> {
        &mut self.parameter_configs
    }
    fn debug_data(&self) -> &Option<Arc<Mutex<dyn SoundPatchConfigurationDebugDataTrait>>> {
        &self.debug_data
    }
    fn debug_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundPatchConfigurationDebugDataTrait>>> {
        &mut self.debug_data
    }
    fn is_loudness_configured(&self) -> &bool {
        &self.is_loudness_configured
    }
    fn is_loudness_configured_mut(&mut self) -> &mut bool {
        &mut self.is_loudness_configured
    }
    fn is_scope_configured(&self) -> &bool {
        &self.is_scope_configured
    }
    fn is_scope_configured_mut(&mut self) -> &mut bool {
        &mut self.is_scope_configured
    }
    fn is_radius_configured(&self) -> &bool {
        &self.is_radius_configured
    }
    fn is_radius_configured_mut(&mut self) -> &mut bool {
        &mut self.is_radius_configured
    }
    fn is_doppler_factor_configured(&self) -> &bool {
        &self.is_doppler_factor_configured
    }
    fn is_doppler_factor_configured_mut(&mut self) -> &mut bool {
        &mut self.is_doppler_factor_configured
    }
    fn is_master_pitch_configured(&self) -> &bool {
        &self.is_master_pitch_configured
    }
    fn is_master_pitch_configured_mut(&mut self) -> &mut bool {
        &mut self.is_master_pitch_configured
    }
    fn is_mixer_configured(&self) -> &bool {
        &self.is_mixer_configured
    }
    fn is_mixer_configured_mut(&mut self) -> &mut bool {
        &mut self.is_mixer_configured
    }
}

impl SoundAssetTrait for SoundPatchConfigurationAsset {
    fn referenced_data(&self) -> &Vec<SoundDataReference> {
        self._glacier_base.referenced_data()
    }
    fn referenced_data_mut(&mut self) -> &mut Vec<SoundDataReference> {
        self._glacier_base.referenced_data_mut()
    }
}

impl super::core::AssetTrait for SoundPatchConfigurationAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundPatchConfigurationAsset {
}

pub static SOUNDPATCHCONFIGURATIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundPatchConfigurationAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundPatchAsset",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, sound),
            },
            FieldInfoData {
                name: "Loudness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, loudness),
            },
            FieldInfoData {
                name: "Scope",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeData",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, scope),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, radius),
            },
            FieldInfoData {
                name: "DopplerFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, doppler_factor),
            },
            FieldInfoData {
                name: "MasterPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, master_pitch),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, mixer),
            },
            FieldInfoData {
                name: "NodeConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphNodeConfigData-Array",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, node_configs),
            },
            FieldInfoData {
                name: "ParameterConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphParameterConfigData-Array",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, parameter_configs),
            },
            FieldInfoData {
                name: "DebugData",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundPatchConfigurationDebugData",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, debug_data),
            },
            FieldInfoData {
                name: "IsLoudnessConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_loudness_configured),
            },
            FieldInfoData {
                name: "IsScopeConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_scope_configured),
            },
            FieldInfoData {
                name: "IsRadiusConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_radius_configured),
            },
            FieldInfoData {
                name: "IsDopplerFactorConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_doppler_factor_configured),
            },
            FieldInfoData {
                name: "IsMasterPitchConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_master_pitch_configured),
            },
            FieldInfoData {
                name: "IsMixerConfigured",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchConfigurationAsset, is_mixer_configured),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHCONFIGURATIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchConfigurationAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPATCHCONFIGURATIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDPATCHCONFIGURATIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchConfigurationAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchConfigurationAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScopeCollectionAsset {
    pub _glacier_base: super::core::Asset,
    pub scopes: Vec<Option<Arc<Mutex<dyn SoundScopeDataTrait>>>>,
    pub aggregates: Vec<Option<Arc<Mutex<dyn SoundScopeAggregateDataTrait>>>>,
    pub scope_strategies: Vec<Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>>,
    pub scope_setups: Vec<Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>>,
}

pub trait ScopeCollectionAssetTrait: super::core::AssetTrait {
    fn scopes(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeDataTrait>>>>;
    fn scopes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeDataTrait>>>>;
    fn aggregates(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeAggregateDataTrait>>>>;
    fn aggregates_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeAggregateDataTrait>>>>;
    fn scope_strategies(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>>;
    fn scope_strategies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>>;
    fn scope_setups(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>>;
    fn scope_setups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>>;
}

impl ScopeCollectionAssetTrait for ScopeCollectionAsset {
    fn scopes(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeDataTrait>>>> {
        &self.scopes
    }
    fn scopes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeDataTrait>>>> {
        &mut self.scopes
    }
    fn aggregates(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeAggregateDataTrait>>>> {
        &self.aggregates
    }
    fn aggregates_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeAggregateDataTrait>>>> {
        &mut self.aggregates
    }
    fn scope_strategies(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>> {
        &self.scope_strategies
    }
    fn scope_strategies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>> {
        &mut self.scope_strategies
    }
    fn scope_setups(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>> {
        &self.scope_setups
    }
    fn scope_setups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>> {
        &mut self.scope_setups
    }
}

impl super::core::AssetTrait for ScopeCollectionAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ScopeCollectionAsset {
}

pub static SCOPECOLLECTIONASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeCollectionAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScopeCollectionAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Scopes",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeData-Array",
                rust_offset: offset_of!(ScopeCollectionAsset, scopes),
            },
            FieldInfoData {
                name: "Aggregates",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeAggregateData-Array",
                rust_offset: offset_of!(ScopeCollectionAsset, aggregates),
            },
            FieldInfoData {
                name: "ScopeStrategies",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeStrategyData-Array",
                rust_offset: offset_of!(ScopeCollectionAsset, scope_strategies),
            },
            FieldInfoData {
                name: "ScopeSetups",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeSetupData-Array",
                rust_offset: offset_of!(ScopeCollectionAsset, scope_setups),
            },
        ],
    }),
    array_type: Some(SCOPECOLLECTIONASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScopeCollectionAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SCOPECOLLECTIONASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCOPECOLLECTIONASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeCollectionAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScopeCollectionAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioSystemAsset {
    pub _glacier_base: super::core::Asset,
    pub master_patch: Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>>,
    pub stream_pools: Vec<Option<Arc<Mutex<dyn StreamPoolTrait>>>>,
    pub global_stream_pools: Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>>,
    pub stream_pool_presets: Vec<Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>>,
    pub default_stream_pool_preset: Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>,
    pub data_policies: Vec<Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>>,
    pub sample_rate: u32,
    pub mixer_system: Option<Arc<Mutex<dyn MixerSystemAssetTrait>>>,
    pub languages: Vec<Option<Arc<Mutex<dyn AudioLanguageTrait>>>>,
    pub language_settings: Vec<Option<Arc<Mutex<dyn AudioLanguageSettingTrait>>>>,
    pub default_language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub scope_collection: Option<Arc<Mutex<dyn ScopeCollectionAssetTrait>>>,
    pub hdr_settings: Vec<Option<Arc<Mutex<dyn HdrSettingTrait>>>>,
    pub default_hdr_setting: Option<Arc<Mutex<dyn HdrSettingTrait>>>,
    pub selection_group_categories: Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>>,
    pub selection_groups: Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>>,
    pub sound_context_system: Option<Arc<Mutex<dyn SoundContextSystemAssetTrait>>>,
}

pub trait AudioSystemAssetTrait: super::core::AssetTrait {
    fn master_patch(&self) -> &Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>>;
    fn master_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>>;
    fn stream_pools(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolTrait>>>>;
    fn stream_pools_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolTrait>>>>;
    fn global_stream_pools(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>>;
    fn global_stream_pools_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>>;
    fn stream_pool_presets(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>>;
    fn stream_pool_presets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>>;
    fn default_stream_pool_preset(&self) -> &Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>;
    fn default_stream_pool_preset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>;
    fn data_policies(&self) -> &Vec<Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>>;
    fn data_policies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>>;
    fn sample_rate(&self) -> &u32;
    fn sample_rate_mut(&mut self) -> &mut u32;
    fn mixer_system(&self) -> &Option<Arc<Mutex<dyn MixerSystemAssetTrait>>>;
    fn mixer_system_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerSystemAssetTrait>>>;
    fn languages(&self) -> &Vec<Option<Arc<Mutex<dyn AudioLanguageTrait>>>>;
    fn languages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioLanguageTrait>>>>;
    fn language_settings(&self) -> &Vec<Option<Arc<Mutex<dyn AudioLanguageSettingTrait>>>>;
    fn language_settings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioLanguageSettingTrait>>>>;
    fn default_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn default_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn scope_collection(&self) -> &Option<Arc<Mutex<dyn ScopeCollectionAssetTrait>>>;
    fn scope_collection_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ScopeCollectionAssetTrait>>>;
    fn hdr_settings(&self) -> &Vec<Option<Arc<Mutex<dyn HdrSettingTrait>>>>;
    fn hdr_settings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn HdrSettingTrait>>>>;
    fn default_hdr_setting(&self) -> &Option<Arc<Mutex<dyn HdrSettingTrait>>>;
    fn default_hdr_setting_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HdrSettingTrait>>>;
    fn selection_group_categories(&self) -> &Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>>;
    fn selection_group_categories_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>>;
    fn selection_groups(&self) -> &Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>>;
    fn selection_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>>;
    fn sound_context_system(&self) -> &Option<Arc<Mutex<dyn SoundContextSystemAssetTrait>>>;
    fn sound_context_system_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextSystemAssetTrait>>>;
}

impl AudioSystemAssetTrait for AudioSystemAsset {
    fn master_patch(&self) -> &Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>> {
        &self.master_patch
    }
    fn master_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>> {
        &mut self.master_patch
    }
    fn stream_pools(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolTrait>>>> {
        &self.stream_pools
    }
    fn stream_pools_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolTrait>>>> {
        &mut self.stream_pools
    }
    fn global_stream_pools(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>> {
        &self.global_stream_pools
    }
    fn global_stream_pools_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>> {
        &mut self.global_stream_pools
    }
    fn stream_pool_presets(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>> {
        &self.stream_pool_presets
    }
    fn stream_pool_presets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolPresetTrait>>>> {
        &mut self.stream_pool_presets
    }
    fn default_stream_pool_preset(&self) -> &Option<Arc<Mutex<dyn StreamPoolPresetTrait>>> {
        &self.default_stream_pool_preset
    }
    fn default_stream_pool_preset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolPresetTrait>>> {
        &mut self.default_stream_pool_preset
    }
    fn data_policies(&self) -> &Vec<Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>> {
        &self.data_policies
    }
    fn data_policies_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundDataPolicyTrait>>>> {
        &mut self.data_policies
    }
    fn sample_rate(&self) -> &u32 {
        &self.sample_rate
    }
    fn sample_rate_mut(&mut self) -> &mut u32 {
        &mut self.sample_rate
    }
    fn mixer_system(&self) -> &Option<Arc<Mutex<dyn MixerSystemAssetTrait>>> {
        &self.mixer_system
    }
    fn mixer_system_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerSystemAssetTrait>>> {
        &mut self.mixer_system
    }
    fn languages(&self) -> &Vec<Option<Arc<Mutex<dyn AudioLanguageTrait>>>> {
        &self.languages
    }
    fn languages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioLanguageTrait>>>> {
        &mut self.languages
    }
    fn language_settings(&self) -> &Vec<Option<Arc<Mutex<dyn AudioLanguageSettingTrait>>>> {
        &self.language_settings
    }
    fn language_settings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioLanguageSettingTrait>>>> {
        &mut self.language_settings
    }
    fn default_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.default_language
    }
    fn default_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.default_language
    }
    fn scope_collection(&self) -> &Option<Arc<Mutex<dyn ScopeCollectionAssetTrait>>> {
        &self.scope_collection
    }
    fn scope_collection_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ScopeCollectionAssetTrait>>> {
        &mut self.scope_collection
    }
    fn hdr_settings(&self) -> &Vec<Option<Arc<Mutex<dyn HdrSettingTrait>>>> {
        &self.hdr_settings
    }
    fn hdr_settings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn HdrSettingTrait>>>> {
        &mut self.hdr_settings
    }
    fn default_hdr_setting(&self) -> &Option<Arc<Mutex<dyn HdrSettingTrait>>> {
        &self.default_hdr_setting
    }
    fn default_hdr_setting_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HdrSettingTrait>>> {
        &mut self.default_hdr_setting
    }
    fn selection_group_categories(&self) -> &Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>> {
        &self.selection_group_categories
    }
    fn selection_group_categories_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>> {
        &mut self.selection_group_categories
    }
    fn selection_groups(&self) -> &Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>> {
        &self.selection_groups
    }
    fn selection_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>> {
        &mut self.selection_groups
    }
    fn sound_context_system(&self) -> &Option<Arc<Mutex<dyn SoundContextSystemAssetTrait>>> {
        &self.sound_context_system
    }
    fn sound_context_system_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextSystemAssetTrait>>> {
        &mut self.sound_context_system
    }
}

impl super::core::AssetTrait for AudioSystemAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AudioSystemAsset {
}

pub static AUDIOSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioSystemAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MasterPatch",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundMasterPatchAsset",
                rust_offset: offset_of!(AudioSystemAsset, master_patch),
            },
            FieldInfoData {
                name: "StreamPools",
                flags: MemberInfoFlags::new(144),
                field_type: "StreamPool-Array",
                rust_offset: offset_of!(AudioSystemAsset, stream_pools),
            },
            FieldInfoData {
                name: "GlobalStreamPools",
                flags: MemberInfoFlags::new(144),
                field_type: "StreamPoolMapping-Array",
                rust_offset: offset_of!(AudioSystemAsset, global_stream_pools),
            },
            FieldInfoData {
                name: "StreamPoolPresets",
                flags: MemberInfoFlags::new(144),
                field_type: "StreamPoolPreset-Array",
                rust_offset: offset_of!(AudioSystemAsset, stream_pool_presets),
            },
            FieldInfoData {
                name: "DefaultStreamPoolPreset",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamPoolPreset",
                rust_offset: offset_of!(AudioSystemAsset, default_stream_pool_preset),
            },
            FieldInfoData {
                name: "DataPolicies",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundDataPolicy-Array",
                rust_offset: offset_of!(AudioSystemAsset, data_policies),
            },
            FieldInfoData {
                name: "SampleRate",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioSystemAsset, sample_rate),
            },
            FieldInfoData {
                name: "MixerSystem",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerSystemAsset",
                rust_offset: offset_of!(AudioSystemAsset, mixer_system),
            },
            FieldInfoData {
                name: "Languages",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioLanguage-Array",
                rust_offset: offset_of!(AudioSystemAsset, languages),
            },
            FieldInfoData {
                name: "LanguageSettings",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioLanguageSetting-Array",
                rust_offset: offset_of!(AudioSystemAsset, language_settings),
            },
            FieldInfoData {
                name: "DefaultLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(AudioSystemAsset, default_language),
            },
            FieldInfoData {
                name: "ScopeCollection",
                flags: MemberInfoFlags::new(0),
                field_type: "ScopeCollectionAsset",
                rust_offset: offset_of!(AudioSystemAsset, scope_collection),
            },
            FieldInfoData {
                name: "HdrSettings",
                flags: MemberInfoFlags::new(144),
                field_type: "HdrSetting-Array",
                rust_offset: offset_of!(AudioSystemAsset, hdr_settings),
            },
            FieldInfoData {
                name: "DefaultHdrSetting",
                flags: MemberInfoFlags::new(0),
                field_type: "HdrSetting",
                rust_offset: offset_of!(AudioSystemAsset, default_hdr_setting),
            },
            FieldInfoData {
                name: "SelectionGroupCategories",
                flags: MemberInfoFlags::new(144),
                field_type: "NewWaveSelectionGroupCategory-Array",
                rust_offset: offset_of!(AudioSystemAsset, selection_group_categories),
            },
            FieldInfoData {
                name: "SelectionGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "NewWaveSelectionGroup-Array",
                rust_offset: offset_of!(AudioSystemAsset, selection_groups),
            },
            FieldInfoData {
                name: "SoundContextSystem",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextSystemAsset",
                rust_offset: offset_of!(AudioSystemAsset, sound_context_system),
            },
        ],
    }),
    array_type: Some(AUDIOSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioSystemAsset {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOSYSTEMASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioSystemAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StreamPoolMapping {
    pub _glacier_base: super::core::DataContainer,
    pub stream_pool: Option<Arc<Mutex<dyn StreamPoolTrait>>>,
    pub stream_pool_setup: Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>,
}

pub trait StreamPoolMappingTrait: super::core::DataContainerTrait {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>>;
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>>;
    fn stream_pool_setup(&self) -> &Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>;
    fn stream_pool_setup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>;
}

impl StreamPoolMappingTrait for StreamPoolMapping {
    fn stream_pool(&self) -> &Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        &self.stream_pool
    }
    fn stream_pool_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolTrait>>> {
        &mut self.stream_pool
    }
    fn stream_pool_setup(&self) -> &Option<Arc<Mutex<dyn StreamPoolSetupTrait>>> {
        &self.stream_pool_setup
    }
    fn stream_pool_setup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn StreamPoolSetupTrait>>> {
        &mut self.stream_pool_setup
    }
}

impl super::core::DataContainerTrait for StreamPoolMapping {
}

pub static STREAMPOOLMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolMapping",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamPoolMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StreamPool",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamPool",
                rust_offset: offset_of!(StreamPoolMapping, stream_pool),
            },
            FieldInfoData {
                name: "StreamPoolSetup",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamPoolSetup",
                rust_offset: offset_of!(StreamPoolMapping, stream_pool_setup),
            },
        ],
    }),
    array_type: Some(STREAMPOOLMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPoolMapping {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMPOOLMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STREAMPOOLMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StreamPoolPreset {
    pub _glacier_base: super::core::DataContainer,
    pub mappings: Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>>,
}

pub trait StreamPoolPresetTrait: super::core::DataContainerTrait {
    fn mappings(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>>;
    fn mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>>;
}

impl StreamPoolPresetTrait for StreamPoolPreset {
    fn mappings(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>> {
        &self.mappings
    }
    fn mappings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolMappingTrait>>>> {
        &mut self.mappings
    }
}

impl super::core::DataContainerTrait for StreamPoolPreset {
}

pub static STREAMPOOLPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolPreset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamPoolPreset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mappings",
                flags: MemberInfoFlags::new(144),
                field_type: "StreamPoolMapping-Array",
                rust_offset: offset_of!(StreamPoolPreset, mappings),
            },
        ],
    }),
    array_type: Some(STREAMPOOLPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPoolPreset {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMPOOLPRESET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STREAMPOOLPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolPreset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolPreset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioLanguageSetting {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub name_hash: u32,
    pub display_name: String,
    pub is_default: bool,
    pub mappings: Vec<AudioLanguageMapping>,
}

pub trait AudioLanguageSettingTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn display_name(&self) -> &String;
    fn display_name_mut(&mut self) -> &mut String;
    fn is_default(&self) -> &bool;
    fn is_default_mut(&mut self) -> &mut bool;
    fn mappings(&self) -> &Vec<AudioLanguageMapping>;
    fn mappings_mut(&mut self) -> &mut Vec<AudioLanguageMapping>;
}

impl AudioLanguageSettingTrait for AudioLanguageSetting {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn display_name(&self) -> &String {
        &self.display_name
    }
    fn display_name_mut(&mut self) -> &mut String {
        &mut self.display_name
    }
    fn is_default(&self) -> &bool {
        &self.is_default
    }
    fn is_default_mut(&mut self) -> &mut bool {
        &mut self.is_default
    }
    fn mappings(&self) -> &Vec<AudioLanguageMapping> {
        &self.mappings
    }
    fn mappings_mut(&mut self) -> &mut Vec<AudioLanguageMapping> {
        &mut self.mappings
    }
}

impl super::core::DataContainerTrait for AudioLanguageSetting {
}

pub static AUDIOLANGUAGESETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageSetting",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioLanguageSetting as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AudioLanguageSetting, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioLanguageSetting, name_hash),
            },
            FieldInfoData {
                name: "DisplayName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AudioLanguageSetting, display_name),
            },
            FieldInfoData {
                name: "IsDefault",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioLanguageSetting, is_default),
            },
            FieldInfoData {
                name: "Mappings",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioLanguageMapping-Array",
                rust_offset: offset_of!(AudioLanguageSetting, mappings),
            },
        ],
    }),
    array_type: Some(AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioLanguageSetting {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOLANGUAGESETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOLANGUAGESETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioLanguageSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioLanguageMapping {
    pub source: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub target: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
}

pub trait AudioLanguageMappingTrait: TypeObject {
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
}

impl AudioLanguageMappingTrait for AudioLanguageMapping {
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.source
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.target
    }
}

pub static AUDIOLANGUAGEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageMapping",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioLanguageMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(AudioLanguageMapping, source),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(AudioLanguageMapping, target),
            },
        ],
    }),
    array_type: Some(AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioLanguageMapping {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOLANGUAGEMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AUDIOLANGUAGEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguageMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioLanguageMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundBusPatchAsset {
    pub _glacier_base: SoundBusPatchBaseAsset,
    pub output_nodes: Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>,
}

pub trait SoundBusPatchAssetTrait: SoundBusPatchBaseAssetTrait {
    fn output_nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
    fn output_nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
}

impl SoundBusPatchAssetTrait for SoundBusPatchAsset {
    fn output_nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &self.output_nodes
    }
    fn output_nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &mut self.output_nodes
    }
}

impl SoundBusPatchBaseAssetTrait for SoundBusPatchAsset {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        self._glacier_base.graph()
    }
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        self._glacier_base.graph_mut()
    }
    fn busses(&self) -> &Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>> {
        self._glacier_base.busses()
    }
    fn busses_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>> {
        self._glacier_base.busses_mut()
    }
}

impl super::core::AssetTrait for SoundBusPatchAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundBusPatchAsset {
}

pub static SOUNDBUSPATCHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDBUSPATCHBASEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundBusPatchAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutputNodes",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphNodeData-Array",
                rust_offset: offset_of!(SoundBusPatchAsset, output_nodes),
            },
        ],
    }),
    array_type: Some(SOUNDBUSPATCHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundBusPatchAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDBUSPATCHASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDBUSPATCHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundBusPatchAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundMasterPatchAsset {
    pub _glacier_base: SoundBusPatchBaseAsset,
    pub rw_movie_bus: Option<Arc<Mutex<dyn SoundBusDataTrait>>>,
}

pub trait SoundMasterPatchAssetTrait: SoundBusPatchBaseAssetTrait {
    fn rw_movie_bus(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn rw_movie_bus_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
}

impl SoundMasterPatchAssetTrait for SoundMasterPatchAsset {
    fn rw_movie_bus(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &self.rw_movie_bus
    }
    fn rw_movie_bus_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &mut self.rw_movie_bus
    }
}

impl SoundBusPatchBaseAssetTrait for SoundMasterPatchAsset {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        self._glacier_base.graph()
    }
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        self._glacier_base.graph_mut()
    }
    fn busses(&self) -> &Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>> {
        self._glacier_base.busses()
    }
    fn busses_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>> {
        self._glacier_base.busses_mut()
    }
}

impl super::core::AssetTrait for SoundMasterPatchAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundMasterPatchAsset {
}

pub static SOUNDMASTERPATCHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterPatchAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDBUSPATCHBASEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundMasterPatchAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RwMovieBus",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusData",
                rust_offset: offset_of!(SoundMasterPatchAsset, rw_movie_bus),
            },
        ],
    }),
    array_type: Some(SOUNDMASTERPATCHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundMasterPatchAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDMASTERPATCHASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDMASTERPATCHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterPatchAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundMasterPatchAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundBusPatchBaseAsset {
    pub _glacier_base: super::core::Asset,
    pub graph: Option<Arc<Mutex<dyn SoundGraphDataTrait>>>,
    pub busses: Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>>,
}

pub trait SoundBusPatchBaseAssetTrait: super::core::AssetTrait {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>>;
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>>;
    fn busses(&self) -> &Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>>;
    fn busses_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>>;
}

impl SoundBusPatchBaseAssetTrait for SoundBusPatchBaseAsset {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        &self.graph
    }
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        &mut self.graph
    }
    fn busses(&self) -> &Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>> {
        &self.busses
    }
    fn busses_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundBusDataTrait>>>> {
        &mut self.busses
    }
}

impl super::core::AssetTrait for SoundBusPatchBaseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundBusPatchBaseAsset {
}

pub static SOUNDBUSPATCHBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchBaseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundBusPatchBaseAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Graph",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphData",
                rust_offset: offset_of!(SoundBusPatchBaseAsset, graph),
            },
            FieldInfoData {
                name: "Busses",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundBusData-Array",
                rust_offset: offset_of!(SoundBusPatchBaseAsset, busses),
            },
        ],
    }),
    array_type: Some(SOUNDBUSPATCHBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundBusPatchBaseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDBUSPATCHBASEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDBUSPATCHBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusPatchBaseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundBusPatchBaseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundPatchAsset {
    pub _glacier_base: SoundGraphAsset,
    pub output_nodes: Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>,
    pub loudness: f32,
    pub scope: Option<Arc<Mutex<dyn SoundScopeDataTrait>>>,
    pub radius: f32,
    pub obstruction_outer_distance_multiplier: f32,
    pub doppler_factor: f32,
    pub master_pitch: f32,
    pub is_looping: bool,
    pub is_persistent: bool,
    pub default_start_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub default_stop_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub default_enter_scope_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub default_force_init_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub context_group: Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>,
}

pub trait SoundPatchAssetTrait: SoundGraphAssetTrait {
    fn output_nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
    fn output_nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
    fn loudness(&self) -> &f32;
    fn loudness_mut(&mut self) -> &mut f32;
    fn scope(&self) -> &Option<Arc<Mutex<dyn SoundScopeDataTrait>>>;
    fn scope_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeDataTrait>>>;
    fn radius(&self) -> &f32;
    fn radius_mut(&mut self) -> &mut f32;
    fn obstruction_outer_distance_multiplier(&self) -> &f32;
    fn obstruction_outer_distance_multiplier_mut(&mut self) -> &mut f32;
    fn doppler_factor(&self) -> &f32;
    fn doppler_factor_mut(&mut self) -> &mut f32;
    fn master_pitch(&self) -> &f32;
    fn master_pitch_mut(&mut self) -> &mut f32;
    fn is_looping(&self) -> &bool;
    fn is_looping_mut(&mut self) -> &mut bool;
    fn is_persistent(&self) -> &bool;
    fn is_persistent_mut(&mut self) -> &mut bool;
    fn default_start_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_start_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_stop_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_stop_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_enter_scope_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_enter_scope_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_force_init_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn default_force_init_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn context_group(&self) -> &Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>;
    fn context_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>;
}

impl SoundPatchAssetTrait for SoundPatchAsset {
    fn output_nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &self.output_nodes
    }
    fn output_nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &mut self.output_nodes
    }
    fn loudness(&self) -> &f32 {
        &self.loudness
    }
    fn loudness_mut(&mut self) -> &mut f32 {
        &mut self.loudness
    }
    fn scope(&self) -> &Option<Arc<Mutex<dyn SoundScopeDataTrait>>> {
        &self.scope
    }
    fn scope_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeDataTrait>>> {
        &mut self.scope
    }
    fn radius(&self) -> &f32 {
        &self.radius
    }
    fn radius_mut(&mut self) -> &mut f32 {
        &mut self.radius
    }
    fn obstruction_outer_distance_multiplier(&self) -> &f32 {
        &self.obstruction_outer_distance_multiplier
    }
    fn obstruction_outer_distance_multiplier_mut(&mut self) -> &mut f32 {
        &mut self.obstruction_outer_distance_multiplier
    }
    fn doppler_factor(&self) -> &f32 {
        &self.doppler_factor
    }
    fn doppler_factor_mut(&mut self) -> &mut f32 {
        &mut self.doppler_factor
    }
    fn master_pitch(&self) -> &f32 {
        &self.master_pitch
    }
    fn master_pitch_mut(&mut self) -> &mut f32 {
        &mut self.master_pitch
    }
    fn is_looping(&self) -> &bool {
        &self.is_looping
    }
    fn is_looping_mut(&mut self) -> &mut bool {
        &mut self.is_looping
    }
    fn is_persistent(&self) -> &bool {
        &self.is_persistent
    }
    fn is_persistent_mut(&mut self) -> &mut bool {
        &mut self.is_persistent
    }
    fn default_start_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.default_start_event
    }
    fn default_start_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.default_start_event
    }
    fn default_stop_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.default_stop_event
    }
    fn default_stop_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.default_stop_event
    }
    fn default_enter_scope_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.default_enter_scope_event
    }
    fn default_enter_scope_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.default_enter_scope_event
    }
    fn default_force_init_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.default_force_init_event
    }
    fn default_force_init_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.default_force_init_event
    }
    fn context_group(&self) -> &Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>> {
        &self.context_group
    }
    fn context_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>> {
        &mut self.context_group
    }
}

impl SoundGraphAssetTrait for SoundPatchAsset {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        self._glacier_base.graph()
    }
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        self._glacier_base.graph_mut()
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        self._glacier_base.mixer()
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        self._glacier_base.mixer_mut()
    }
}

impl SoundAssetTrait for SoundPatchAsset {
    fn referenced_data(&self) -> &Vec<SoundDataReference> {
        self._glacier_base.referenced_data()
    }
    fn referenced_data_mut(&mut self) -> &mut Vec<SoundDataReference> {
        self._glacier_base.referenced_data_mut()
    }
}

impl super::core::AssetTrait for SoundPatchAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundPatchAsset {
}

pub static SOUNDPATCHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDGRAPHASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundPatchAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutputNodes",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphNodeData-Array",
                rust_offset: offset_of!(SoundPatchAsset, output_nodes),
            },
            FieldInfoData {
                name: "Loudness",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchAsset, loudness),
            },
            FieldInfoData {
                name: "Scope",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeData",
                rust_offset: offset_of!(SoundPatchAsset, scope),
            },
            FieldInfoData {
                name: "Radius",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchAsset, radius),
            },
            FieldInfoData {
                name: "ObstructionOuterDistanceMultiplier",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchAsset, obstruction_outer_distance_multiplier),
            },
            FieldInfoData {
                name: "DopplerFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchAsset, doppler_factor),
            },
            FieldInfoData {
                name: "MasterPitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundPatchAsset, master_pitch),
            },
            FieldInfoData {
                name: "IsLooping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchAsset, is_looping),
            },
            FieldInfoData {
                name: "IsPersistent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundPatchAsset, is_persistent),
            },
            FieldInfoData {
                name: "DefaultStartEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundPatchAsset, default_start_event),
            },
            FieldInfoData {
                name: "DefaultStopEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundPatchAsset, default_stop_event),
            },
            FieldInfoData {
                name: "DefaultEnterScopeEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundPatchAsset, default_enter_scope_event),
            },
            FieldInfoData {
                name: "DefaultForceInitEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundPatchAsset, default_force_init_event),
            },
            FieldInfoData {
                name: "ContextGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextGroupData",
                rust_offset: offset_of!(SoundPatchAsset, context_group),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPATCHASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDPATCHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundPatchDefaultEvent {
    #[default]
    SoundPatchDefaultEvent_Start = 0,
    SoundPatchDefaultEvent_Stop = 1,
    SoundPatchDefaultEvent_EnterScope = 2,
    SoundPatchDefaultEvent_ForceInit = 3,
}

pub static SOUNDPATCHDEFAULTEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchDefaultEvent",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDPATCHDEFAULTEVENT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundPatchDefaultEvent {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPATCHDEFAULTEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDPATCHDEFAULTEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchDefaultEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchDefaultEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundPatchPublicNode {
    pub node: Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>,
    pub id: u32,
}

pub trait SoundPatchPublicNodeTrait: TypeObject {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn id(&self) -> &u32;
    fn id_mut(&mut self) -> &mut u32;
}

impl SoundPatchPublicNodeTrait for SoundPatchPublicNode {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &self.node
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &mut self.node
    }
    fn id(&self) -> &u32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut u32 {
        &mut self.id
    }
}

pub static SOUNDPATCHPUBLICNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchPublicNode",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundPatchPublicNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodeData",
                rust_offset: offset_of!(SoundPatchPublicNode, node),
            },
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundPatchPublicNode, id),
            },
        ],
    }),
    array_type: Some(SOUNDPATCHPUBLICNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPatchPublicNode {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPATCHPUBLICNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDPATCHPUBLICNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPatchPublicNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPatchPublicNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphAsset {
    pub _glacier_base: SoundAsset,
    pub graph: Option<Arc<Mutex<dyn SoundGraphDataTrait>>>,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
}

pub trait SoundGraphAssetTrait: SoundAssetTrait {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>>;
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>>;
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
}

impl SoundGraphAssetTrait for SoundGraphAsset {
    fn graph(&self) -> &Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        &self.graph
    }
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundGraphDataTrait>>> {
        &mut self.graph
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
}

impl SoundAssetTrait for SoundGraphAsset {
    fn referenced_data(&self) -> &Vec<SoundDataReference> {
        self._glacier_base.referenced_data()
    }
    fn referenced_data_mut(&mut self) -> &mut Vec<SoundDataReference> {
        self._glacier_base.referenced_data_mut()
    }
}

impl super::core::AssetTrait for SoundGraphAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundGraphAsset {
}

pub static SOUNDGRAPHASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Graph",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphData",
                rust_offset: offset_of!(SoundGraphAsset, graph),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(SoundGraphAsset, mixer),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDGRAPHASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioMaterialDefinitions {
    pub _glacier_base: super::core::Asset,
}

pub trait AudioMaterialDefinitionsTrait: super::core::AssetTrait {
}

impl AudioMaterialDefinitionsTrait for AudioMaterialDefinitions {
}

impl super::core::AssetTrait for AudioMaterialDefinitions {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for AudioMaterialDefinitions {
}

pub static AUDIOMATERIALDEFINITIONS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioMaterialDefinitions",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioMaterialDefinitions as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUDIOMATERIALDEFINITIONS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioMaterialDefinitions {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOMATERIALDEFINITIONS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOMATERIALDEFINITIONS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioMaterialDefinitions-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioMaterialDefinitions"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ImpulseResponseAsset {
    pub _glacier_base: SoundDataAsset,
}

pub trait ImpulseResponseAssetTrait: SoundDataAssetTrait {
}

impl ImpulseResponseAssetTrait for ImpulseResponseAsset {
}

impl SoundDataAssetTrait for ImpulseResponseAsset {
    fn chunks(&self) -> &Vec<SoundDataChunk> {
        self._glacier_base.chunks()
    }
    fn chunks_mut(&mut self) -> &mut Vec<SoundDataChunk> {
        self._glacier_base.chunks_mut()
    }
    fn policy(&self) -> &Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy()
    }
    fn policy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataPolicyTrait>>> {
        self._glacier_base.policy_mut()
    }
    fn prime_priority(&self) -> &u8 {
        self._glacier_base.prime_priority()
    }
    fn prime_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.prime_priority_mut()
    }
    fn request_priority(&self) -> &u8 {
        self._glacier_base.request_priority()
    }
    fn request_priority_mut(&mut self) -> &mut u8 {
        self._glacier_base.request_priority_mut()
    }
}

impl super::core::AssetTrait for ImpulseResponseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for ImpulseResponseAsset {
}

pub static IMPULSERESPONSEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDDATAASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ImpulseResponseAsset as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(IMPULSERESPONSEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ImpulseResponseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        IMPULSERESPONSEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IMPULSERESPONSEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ImpulseResponseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ImpulseResponseBlockSize {
    #[default]
    ImpulseResponseBlockSize_256 = 256,
    ImpulseResponseBlockSize_512 = 512,
    ImpulseResponseBlockSize_768 = 768,
    ImpulseResponseBlockSize_1024 = 1024,
    ImpulseResponseBlockSize_1280 = 1280,
    ImpulseResponseBlockSize_1536 = 1536,
    ImpulseResponseBlockSize_1792 = 1792,
    ImpulseResponseBlockSize_2048 = 2048,
    ImpulseResponseBlockSize_2304 = 2304,
    ImpulseResponseBlockSize_2560 = 2560,
    ImpulseResponseBlockSize_2816 = 2816,
    ImpulseResponseBlockSize_3072 = 3072,
    ImpulseResponseBlockSize_3328 = 3328,
    ImpulseResponseBlockSize_3584 = 3584,
    ImpulseResponseBlockSize_3840 = 3840,
    ImpulseResponseBlockSize_4096 = 4096,
    ImpulseResponseBlockSize_4352 = 4352,
    ImpulseResponseBlockSize_4608 = 4608,
    ImpulseResponseBlockSize_4864 = 4864,
    ImpulseResponseBlockSize_5120 = 5120,
    ImpulseResponseBlockSize_5376 = 5376,
    ImpulseResponseBlockSize_5632 = 5632,
    ImpulseResponseBlockSize_5888 = 5888,
    ImpulseResponseBlockSize_6144 = 6144,
    ImpulseResponseBlockSize_6400 = 6400,
    ImpulseResponseBlockSize_6656 = 6656,
    ImpulseResponseBlockSize_6912 = 6912,
    ImpulseResponseBlockSize_7168 = 7168,
    ImpulseResponseBlockSize_7424 = 7424,
    ImpulseResponseBlockSize_7680 = 7680,
    ImpulseResponseBlockSize_7936 = 7936,
    ImpulseResponseBlockSize_8192 = 8192,
}

pub static IMPULSERESPONSEBLOCKSIZE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseBlockSize",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(IMPULSERESPONSEBLOCKSIZE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ImpulseResponseBlockSize {
    fn type_info(&self) -> &'static TypeInfo {
        IMPULSERESPONSEBLOCKSIZE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static IMPULSERESPONSEBLOCKSIZE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ImpulseResponseBlockSize-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ImpulseResponseBlockSize"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveSelectionGroup {
    pub _glacier_base: super::core::DataContainer,
    pub entry_count: u32,
    pub entry_timeout: f32,
    pub name_hash: u32,
    pub should_serialize: bool,
    pub behavior: u8,
    pub category: Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>,
}

pub trait NewWaveSelectionGroupTrait: super::core::DataContainerTrait {
    fn entry_count(&self) -> &u32;
    fn entry_count_mut(&mut self) -> &mut u32;
    fn entry_timeout(&self) -> &f32;
    fn entry_timeout_mut(&mut self) -> &mut f32;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn should_serialize(&self) -> &bool;
    fn should_serialize_mut(&mut self) -> &mut bool;
    fn behavior(&self) -> &u8;
    fn behavior_mut(&mut self) -> &mut u8;
    fn category(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>;
    fn category_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>>;
}

impl NewWaveSelectionGroupTrait for NewWaveSelectionGroup {
    fn entry_count(&self) -> &u32 {
        &self.entry_count
    }
    fn entry_count_mut(&mut self) -> &mut u32 {
        &mut self.entry_count
    }
    fn entry_timeout(&self) -> &f32 {
        &self.entry_timeout
    }
    fn entry_timeout_mut(&mut self) -> &mut f32 {
        &mut self.entry_timeout
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn should_serialize(&self) -> &bool {
        &self.should_serialize
    }
    fn should_serialize_mut(&mut self) -> &mut bool {
        &mut self.should_serialize
    }
    fn behavior(&self) -> &u8 {
        &self.behavior
    }
    fn behavior_mut(&mut self) -> &mut u8 {
        &mut self.behavior
    }
    fn category(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>> {
        &self.category
    }
    fn category_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupCategoryTrait>>> {
        &mut self.category
    }
}

impl super::core::DataContainerTrait for NewWaveSelectionGroup {
}

pub static NEWWAVESELECTIONGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveSelectionGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntryCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NewWaveSelectionGroup, entry_count),
            },
            FieldInfoData {
                name: "EntryTimeout",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NewWaveSelectionGroup, entry_timeout),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(NewWaveSelectionGroup, name_hash),
            },
            FieldInfoData {
                name: "ShouldSerialize",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(NewWaveSelectionGroup, should_serialize),
            },
            FieldInfoData {
                name: "Behavior",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(NewWaveSelectionGroup, behavior),
            },
            FieldInfoData {
                name: "Category",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveSelectionGroupCategory",
                rust_offset: offset_of!(NewWaveSelectionGroup, category),
            },
        ],
    }),
    array_type: Some(NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveSelectionGroup {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVESELECTIONGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NEWWAVESELECTIONGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveSelectionGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum NewWaveSelectionGroupBehavior {
    #[default]
    NewWaveSelectionGroupBehavior_Shuffle = 1,
    NewWaveSelectionGroupBehavior_Timed = 2,
    NewWaveSelectionGroupBehavior_Once = 3,
    NewWaveSelectionGroupBehavior_Timeout = 4,
}

pub static NEWWAVESELECTIONGROUPBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(NEWWAVESELECTIONGROUPBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for NewWaveSelectionGroupBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVESELECTIONGROUPBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NEWWAVESELECTIONGROUPBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveSelectionGroupBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveSelectionGroupCategory {
    pub _glacier_base: super::core::DataContainer,
}

pub trait NewWaveSelectionGroupCategoryTrait: super::core::DataContainerTrait {
}

impl NewWaveSelectionGroupCategoryTrait for NewWaveSelectionGroupCategory {
}

impl super::core::DataContainerTrait for NewWaveSelectionGroupCategory {
}

pub static NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupCategory",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveSelectionGroupCategory as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveSelectionGroupCategory {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVESELECTIONGROUPCATEGORY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NEWWAVESELECTIONGROUPCATEGORY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveSelectionGroupCategory-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveSelectionGroupCategory"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StreamPool {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub stream_pool_id: u32,
    pub setups: Vec<Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>>,
}

pub trait StreamPoolTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn stream_pool_id(&self) -> &u32;
    fn stream_pool_id_mut(&mut self) -> &mut u32;
    fn setups(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>>;
    fn setups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>>;
}

impl StreamPoolTrait for StreamPool {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn stream_pool_id(&self) -> &u32 {
        &self.stream_pool_id
    }
    fn stream_pool_id_mut(&mut self) -> &mut u32 {
        &mut self.stream_pool_id
    }
    fn setups(&self) -> &Vec<Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>> {
        &self.setups
    }
    fn setups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn StreamPoolSetupTrait>>>> {
        &mut self.setups
    }
}

impl super::core::DataContainerTrait for StreamPool {
}

pub static STREAMPOOL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPool",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamPool as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(StreamPool, name),
            },
            FieldInfoData {
                name: "StreamPoolId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StreamPool, stream_pool_id),
            },
            FieldInfoData {
                name: "Setups",
                flags: MemberInfoFlags::new(144),
                field_type: "StreamPoolSetup-Array",
                rust_offset: offset_of!(StreamPool, setups),
            },
        ],
    }),
    array_type: Some(STREAMPOOL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPool {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMPOOL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STREAMPOOL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPool-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPool"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StreamPoolSetup {
    pub _glacier_base: super::core::DataContainer,
    pub properties: StreamPoolProperties,
    pub stream_starve_mode: StreamStarveMode,
}

pub trait StreamPoolSetupTrait: super::core::DataContainerTrait {
    fn properties(&self) -> &StreamPoolProperties;
    fn properties_mut(&mut self) -> &mut StreamPoolProperties;
    fn stream_starve_mode(&self) -> &StreamStarveMode;
    fn stream_starve_mode_mut(&mut self) -> &mut StreamStarveMode;
}

impl StreamPoolSetupTrait for StreamPoolSetup {
    fn properties(&self) -> &StreamPoolProperties {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut StreamPoolProperties {
        &mut self.properties
    }
    fn stream_starve_mode(&self) -> &StreamStarveMode {
        &self.stream_starve_mode
    }
    fn stream_starve_mode_mut(&mut self) -> &mut StreamStarveMode {
        &mut self.stream_starve_mode
    }
}

impl super::core::DataContainerTrait for StreamPoolSetup {
}

pub static STREAMPOOLSETUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolSetup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamPoolSetup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamPoolProperties",
                rust_offset: offset_of!(StreamPoolSetup, properties),
            },
            FieldInfoData {
                name: "StreamStarveMode",
                flags: MemberInfoFlags::new(0),
                field_type: "StreamStarveMode",
                rust_offset: offset_of!(StreamPoolSetup, stream_starve_mode),
            },
        ],
    }),
    array_type: Some(STREAMPOOLSETUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for StreamPoolSetup {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMPOOLSETUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static STREAMPOOLSETUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolSetup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolSetup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct StreamPoolProperties {
    pub buffer_size: u32,
    pub count: u32,
    pub read_block_size: u32,
    pub starvation_threshold: u32,
    pub max_requests: u32,
}

pub trait StreamPoolPropertiesTrait: TypeObject {
    fn buffer_size(&self) -> &u32;
    fn buffer_size_mut(&mut self) -> &mut u32;
    fn count(&self) -> &u32;
    fn count_mut(&mut self) -> &mut u32;
    fn read_block_size(&self) -> &u32;
    fn read_block_size_mut(&mut self) -> &mut u32;
    fn starvation_threshold(&self) -> &u32;
    fn starvation_threshold_mut(&mut self) -> &mut u32;
    fn max_requests(&self) -> &u32;
    fn max_requests_mut(&mut self) -> &mut u32;
}

impl StreamPoolPropertiesTrait for StreamPoolProperties {
    fn buffer_size(&self) -> &u32 {
        &self.buffer_size
    }
    fn buffer_size_mut(&mut self) -> &mut u32 {
        &mut self.buffer_size
    }
    fn count(&self) -> &u32 {
        &self.count
    }
    fn count_mut(&mut self) -> &mut u32 {
        &mut self.count
    }
    fn read_block_size(&self) -> &u32 {
        &self.read_block_size
    }
    fn read_block_size_mut(&mut self) -> &mut u32 {
        &mut self.read_block_size
    }
    fn starvation_threshold(&self) -> &u32 {
        &self.starvation_threshold
    }
    fn starvation_threshold_mut(&mut self) -> &mut u32 {
        &mut self.starvation_threshold
    }
    fn max_requests(&self) -> &u32 {
        &self.max_requests
    }
    fn max_requests_mut(&mut self) -> &mut u32 {
        &mut self.max_requests
    }
}

pub static STREAMPOOLPROPERTIES_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolProperties",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<StreamPoolProperties as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "BufferSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StreamPoolProperties, buffer_size),
            },
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StreamPoolProperties, count),
            },
            FieldInfoData {
                name: "ReadBlockSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StreamPoolProperties, read_block_size),
            },
            FieldInfoData {
                name: "StarvationThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StreamPoolProperties, starvation_threshold),
            },
            FieldInfoData {
                name: "MaxRequests",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(StreamPoolProperties, max_requests),
            },
        ],
    }),
    array_type: Some(STREAMPOOLPROPERTIES_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for StreamPoolProperties {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMPOOLPROPERTIES_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STREAMPOOLPROPERTIES_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamPoolProperties-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamPoolProperties"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum StreamStarveMode {
    #[default]
    StreamStarveMode_Off = 0,
    StreamStarveMode_On = 1,
    StreamStarveMode_Dynamic = 2,
}

pub static STREAMSTARVEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamStarveMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(STREAMSTARVEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for StreamStarveMode {
    fn type_info(&self) -> &'static TypeInfo {
        STREAMSTARVEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static STREAMSTARVEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "StreamStarveMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("StreamStarveMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundAsset {
    pub _glacier_base: super::core::Asset,
    pub referenced_data: Vec<SoundDataReference>,
}

pub trait SoundAssetTrait: super::core::AssetTrait {
    fn referenced_data(&self) -> &Vec<SoundDataReference>;
    fn referenced_data_mut(&mut self) -> &mut Vec<SoundDataReference>;
}

impl SoundAssetTrait for SoundAsset {
    fn referenced_data(&self) -> &Vec<SoundDataReference> {
        &self.referenced_data
    }
    fn referenced_data_mut(&mut self) -> &mut Vec<SoundDataReference> {
        &mut self.referenced_data
    }
}

impl super::core::AssetTrait for SoundAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for SoundAsset {
}

pub static SOUNDASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ReferencedData",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundDataReference-Array",
                rust_offset: offset_of!(SoundAsset, referenced_data),
            },
        ],
    }),
    array_type: Some(SOUNDASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundAsset {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundDataReference {
    pub data_owner: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
    pub sound_data: Option<Arc<Mutex<dyn SoundDataAssetTrait>>>,
}

pub trait SoundDataReferenceTrait: TypeObject {
    fn data_owner(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn data_owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn sound_data(&self) -> &Option<Arc<Mutex<dyn SoundDataAssetTrait>>>;
    fn sound_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataAssetTrait>>>;
}

impl SoundDataReferenceTrait for SoundDataReference {
    fn data_owner(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.data_owner
    }
    fn data_owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &mut self.data_owner
    }
    fn sound_data(&self) -> &Option<Arc<Mutex<dyn SoundDataAssetTrait>>> {
        &self.sound_data
    }
    fn sound_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundDataAssetTrait>>> {
        &mut self.sound_data
    }
}

pub static SOUNDDATAREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReference",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundDataReference as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DataOwner",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(SoundDataReference, data_owner),
            },
            FieldInfoData {
                name: "SoundData",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundDataAsset",
                rust_offset: offset_of!(SoundDataReference, sound_data),
            },
        ],
    }),
    array_type: Some(SOUNDDATAREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataReference {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDDATAREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSystemAsset {
    pub _glacier_base: super::core::Asset,
    pub exponential_gain_interpolation: bool,
    pub octave_frequency_interpolation_lpf: bool,
    pub groups: Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>>,
}

pub trait MixerSystemAssetTrait: super::core::AssetTrait {
    fn exponential_gain_interpolation(&self) -> &bool;
    fn exponential_gain_interpolation_mut(&mut self) -> &mut bool;
    fn octave_frequency_interpolation_lpf(&self) -> &bool;
    fn octave_frequency_interpolation_lpf_mut(&mut self) -> &mut bool;
    fn groups(&self) -> &Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>>;
    fn groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>>;
}

impl MixerSystemAssetTrait for MixerSystemAsset {
    fn exponential_gain_interpolation(&self) -> &bool {
        &self.exponential_gain_interpolation
    }
    fn exponential_gain_interpolation_mut(&mut self) -> &mut bool {
        &mut self.exponential_gain_interpolation
    }
    fn octave_frequency_interpolation_lpf(&self) -> &bool {
        &self.octave_frequency_interpolation_lpf
    }
    fn octave_frequency_interpolation_lpf_mut(&mut self) -> &mut bool {
        &mut self.octave_frequency_interpolation_lpf
    }
    fn groups(&self) -> &Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>> {
        &self.groups
    }
    fn groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>> {
        &mut self.groups
    }
}

impl super::core::AssetTrait for MixerSystemAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MixerSystemAsset {
}

pub static MIXERSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSystemAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ExponentialGainInterpolation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerSystemAsset, exponential_gain_interpolation),
            },
            FieldInfoData {
                name: "OctaveFrequencyInterpolationLpf",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerSystemAsset, octave_frequency_interpolation_lpf),
            },
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: "MixGroup-Array",
                rust_offset: offset_of!(MixerSystemAsset, groups),
            },
        ],
    }),
    array_type: Some(MIXERSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSystemAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSYSTEMASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSystemAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerAsset {
    pub _glacier_base: super::core::Asset,
    pub bypass: bool,
    pub graph: Option<Arc<Mutex<dyn MixerGraphDataTrait>>>,
    pub presets: Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>>,
    pub default_preset: Option<Arc<Mutex<dyn MixerPresetTrait>>>,
}

pub trait MixerAssetTrait: super::core::AssetTrait {
    fn bypass(&self) -> &bool;
    fn bypass_mut(&mut self) -> &mut bool;
    fn graph(&self) -> &Option<Arc<Mutex<dyn MixerGraphDataTrait>>>;
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerGraphDataTrait>>>;
    fn presets(&self) -> &Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>>;
    fn presets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>>;
    fn default_preset(&self) -> &Option<Arc<Mutex<dyn MixerPresetTrait>>>;
    fn default_preset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerPresetTrait>>>;
}

impl MixerAssetTrait for MixerAsset {
    fn bypass(&self) -> &bool {
        &self.bypass
    }
    fn bypass_mut(&mut self) -> &mut bool {
        &mut self.bypass
    }
    fn graph(&self) -> &Option<Arc<Mutex<dyn MixerGraphDataTrait>>> {
        &self.graph
    }
    fn graph_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerGraphDataTrait>>> {
        &mut self.graph
    }
    fn presets(&self) -> &Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>> {
        &self.presets
    }
    fn presets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>> {
        &mut self.presets
    }
    fn default_preset(&self) -> &Option<Arc<Mutex<dyn MixerPresetTrait>>> {
        &self.default_preset
    }
    fn default_preset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerPresetTrait>>> {
        &mut self.default_preset
    }
}

impl super::core::AssetTrait for MixerAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MixerAsset {
}

pub static MIXERASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Bypass",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerAsset, bypass),
            },
            FieldInfoData {
                name: "Graph",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerGraphData",
                rust_offset: offset_of!(MixerAsset, graph),
            },
            FieldInfoData {
                name: "Presets",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerPreset-Array",
                rust_offset: offset_of!(MixerAsset, presets),
            },
            FieldInfoData {
                name: "DefaultPreset",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerPreset",
                rust_offset: offset_of!(MixerAsset, default_preset),
            },
        ],
    }),
    array_type: Some(MIXERASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerGraphData {
    pub _glacier_base: AudioGraphData,
    pub inputs: Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>,
    pub mixer_input_infos: Vec<MixerInputInfo>,
    pub outputs: Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>,
}

pub trait MixerGraphDataTrait: AudioGraphDataTrait {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn mixer_input_infos(&self) -> &Vec<MixerInputInfo>;
    fn mixer_input_infos_mut(&mut self) -> &mut Vec<MixerInputInfo>;
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn outputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
}

impl MixerGraphDataTrait for MixerGraphData {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &mut self.inputs
    }
    fn mixer_input_infos(&self) -> &Vec<MixerInputInfo> {
        &self.mixer_input_infos
    }
    fn mixer_input_infos_mut(&mut self) -> &mut Vec<MixerInputInfo> {
        &mut self.mixer_input_infos
    }
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &self.outputs
    }
    fn outputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &mut self.outputs
    }
}

impl AudioGraphDataTrait for MixerGraphData {
    fn nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        self._glacier_base.nodes()
    }
    fn nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        self._glacier_base.nodes_mut()
    }
    fn public_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        self._glacier_base.public_parameters()
    }
    fn public_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        self._glacier_base.public_parameters_mut()
    }
    fn public_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        self._glacier_base.public_events()
    }
    fn public_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        self._glacier_base.public_events_mut()
    }
    fn public_asset_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>> {
        self._glacier_base.public_asset_parameters()
    }
    fn public_asset_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>> {
        self._glacier_base.public_asset_parameters_mut()
    }
    fn public_value_count(&self) -> &u16 {
        self._glacier_base.public_value_count()
    }
    fn public_value_count_mut(&mut self) -> &mut u16 {
        self._glacier_base.public_value_count_mut()
    }
    fn value_count(&self) -> &u16 {
        self._glacier_base.value_count()
    }
    fn value_count_mut(&mut self) -> &mut u16 {
        self._glacier_base.value_count_mut()
    }
}

impl super::core::DataContainerTrait for MixerGraphData {
}

pub static MIXERGRAPHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGraphData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerGraphData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphParameter-Array",
                rust_offset: offset_of!(MixerGraphData, inputs),
            },
            FieldInfoData {
                name: "MixerInputInfos",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerInputInfo-Array",
                rust_offset: offset_of!(MixerGraphData, mixer_input_infos),
            },
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphParameter-Array",
                rust_offset: offset_of!(MixerGraphData, outputs),
            },
        ],
    }),
    array_type: Some(MIXERGRAPHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerGraphData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERGRAPHDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERGRAPHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGraphData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerGraphData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerInputInfo {
    pub mode: MixerValueAccumulateMode,
    pub keep_value: bool,
}

pub trait MixerInputInfoTrait: TypeObject {
    fn mode(&self) -> &MixerValueAccumulateMode;
    fn mode_mut(&mut self) -> &mut MixerValueAccumulateMode;
    fn keep_value(&self) -> &bool;
    fn keep_value_mut(&mut self) -> &mut bool;
}

impl MixerInputInfoTrait for MixerInputInfo {
    fn mode(&self) -> &MixerValueAccumulateMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut MixerValueAccumulateMode {
        &mut self.mode
    }
    fn keep_value(&self) -> &bool {
        &self.keep_value
    }
    fn keep_value_mut(&mut self) -> &mut bool {
        &mut self.keep_value
    }
}

pub static MIXERINPUTINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputInfo",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerInputInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerValueAccumulateMode",
                rust_offset: offset_of!(MixerInputInfo, mode),
            },
            FieldInfoData {
                name: "KeepValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerInputInfo, keep_value),
            },
        ],
    }),
    array_type: Some(MIXERINPUTINFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MixerInputInfo {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERINPUTINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERINPUTINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerInputInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MixerValueAccumulateMode {
    #[default]
    MixerValueAccumulateMode_None = 0,
    MixerValueAccumulateMode_Min = 1,
    MixerValueAccumulateMode_Max = 2,
}

pub static MIXERVALUEACCUMULATEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueAccumulateMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEACCUMULATEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueAccumulateMode {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERVALUEACCUMULATEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERVALUEACCUMULATEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueAccumulateMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueAccumulateMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerPreset {
    pub _glacier_base: super::core::DataContainer,
    pub name_hash: u32,
    pub groups: Vec<MixerPresetGroupData>,
    pub nodes: Vec<MixerPresetNodeData>,
}

pub trait MixerPresetTrait: super::core::DataContainerTrait {
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn groups(&self) -> &Vec<MixerPresetGroupData>;
    fn groups_mut(&mut self) -> &mut Vec<MixerPresetGroupData>;
    fn nodes(&self) -> &Vec<MixerPresetNodeData>;
    fn nodes_mut(&mut self) -> &mut Vec<MixerPresetNodeData>;
}

impl MixerPresetTrait for MixerPreset {
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn groups(&self) -> &Vec<MixerPresetGroupData> {
        &self.groups
    }
    fn groups_mut(&mut self) -> &mut Vec<MixerPresetGroupData> {
        &mut self.groups
    }
    fn nodes(&self) -> &Vec<MixerPresetNodeData> {
        &self.nodes
    }
    fn nodes_mut(&mut self) -> &mut Vec<MixerPresetNodeData> {
        &mut self.nodes
    }
}

impl super::core::DataContainerTrait for MixerPreset {
}

pub static MIXERPRESET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPreset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerPreset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MixerPreset, name_hash),
            },
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerPresetGroupData-Array",
                rust_offset: offset_of!(MixerPreset, groups),
            },
            FieldInfoData {
                name: "Nodes",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerPresetNodeData-Array",
                rust_offset: offset_of!(MixerPreset, nodes),
            },
        ],
    }),
    array_type: Some(MIXERPRESET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerPreset {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERPRESET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERPRESET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPreset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerPreset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerPresetNodeData {
    pub node: Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>,
    pub value: f32,
}

pub trait MixerPresetNodeDataTrait: TypeObject {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl MixerPresetNodeDataTrait for MixerPresetNodeData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &self.node
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &mut self.node
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

pub static MIXERPRESETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetNodeData",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerPresetNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodeData",
                rust_offset: offset_of!(MixerPresetNodeData, node),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixerPresetNodeData, value),
            },
        ],
    }),
    array_type: Some(MIXERPRESETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerPresetNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERPRESETNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERPRESETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerPresetNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerPresetGroupData {
    pub group: Option<Arc<Mutex<dyn MixGroupTrait>>>,
    pub state: MixGroupState,
    pub attack_time: f32,
    pub release_time: f32,
    pub is_dominant: bool,
    pub is_additive: bool,
    pub priority: i32,
    pub properties: Vec<MixGroupPropertyValue>,
}

pub trait MixerPresetGroupDataTrait: TypeObject {
    fn group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn state(&self) -> &MixGroupState;
    fn state_mut(&mut self) -> &mut MixGroupState;
    fn attack_time(&self) -> &f32;
    fn attack_time_mut(&mut self) -> &mut f32;
    fn release_time(&self) -> &f32;
    fn release_time_mut(&mut self) -> &mut f32;
    fn is_dominant(&self) -> &bool;
    fn is_dominant_mut(&mut self) -> &mut bool;
    fn is_additive(&self) -> &bool;
    fn is_additive_mut(&mut self) -> &mut bool;
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn properties(&self) -> &Vec<MixGroupPropertyValue>;
    fn properties_mut(&mut self) -> &mut Vec<MixGroupPropertyValue>;
}

impl MixerPresetGroupDataTrait for MixerPresetGroupData {
    fn group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &self.group
    }
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &mut self.group
    }
    fn state(&self) -> &MixGroupState {
        &self.state
    }
    fn state_mut(&mut self) -> &mut MixGroupState {
        &mut self.state
    }
    fn attack_time(&self) -> &f32 {
        &self.attack_time
    }
    fn attack_time_mut(&mut self) -> &mut f32 {
        &mut self.attack_time
    }
    fn release_time(&self) -> &f32 {
        &self.release_time
    }
    fn release_time_mut(&mut self) -> &mut f32 {
        &mut self.release_time
    }
    fn is_dominant(&self) -> &bool {
        &self.is_dominant
    }
    fn is_dominant_mut(&mut self) -> &mut bool {
        &mut self.is_dominant
    }
    fn is_additive(&self) -> &bool {
        &self.is_additive
    }
    fn is_additive_mut(&mut self) -> &mut bool {
        &mut self.is_additive
    }
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn properties(&self) -> &Vec<MixGroupPropertyValue> {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut Vec<MixGroupPropertyValue> {
        &mut self.properties
    }
}

pub static MIXERPRESETGROUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetGroupData",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerPresetGroupData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: "MixGroup",
                rust_offset: offset_of!(MixerPresetGroupData, group),
            },
            FieldInfoData {
                name: "State",
                flags: MemberInfoFlags::new(0),
                field_type: "MixGroupState",
                rust_offset: offset_of!(MixerPresetGroupData, state),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixerPresetGroupData, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixerPresetGroupData, release_time),
            },
            FieldInfoData {
                name: "IsDominant",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerPresetGroupData, is_dominant),
            },
            FieldInfoData {
                name: "IsAdditive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerPresetGroupData, is_additive),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MixerPresetGroupData, priority),
            },
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: "MixGroupPropertyValue-Array",
                rust_offset: offset_of!(MixerPresetGroupData, properties),
            },
        ],
    }),
    array_type: Some(MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerPresetGroupData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERPRESETGROUPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERPRESETGROUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerPresetGroupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerPresetGroupData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixGroupPropertyValue {
    pub property: u32,
    pub value: f32,
    pub controlled: bool,
}

pub trait MixGroupPropertyValueTrait: TypeObject {
    fn property(&self) -> &u32;
    fn property_mut(&mut self) -> &mut u32;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
    fn controlled(&self) -> &bool;
    fn controlled_mut(&mut self) -> &mut bool;
}

impl MixGroupPropertyValueTrait for MixGroupPropertyValue {
    fn property(&self) -> &u32 {
        &self.property
    }
    fn property_mut(&mut self) -> &mut u32 {
        &mut self.property
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
    fn controlled(&self) -> &bool {
        &self.controlled
    }
    fn controlled_mut(&mut self) -> &mut bool {
        &mut self.controlled
    }
}

pub static MIXGROUPPROPERTYVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyValue",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixGroupPropertyValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MixGroupPropertyValue, property),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixGroupPropertyValue, value),
            },
            FieldInfoData {
                name: "Controlled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixGroupPropertyValue, controlled),
            },
        ],
    }),
    array_type: Some(MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MixGroupPropertyValue {
    fn type_info(&self) -> &'static TypeInfo {
        MIXGROUPPROPERTYVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXGROUPPROPERTYVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupPropertyValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MixGroupPropertyType {
    #[default]
    MixGroupPropertyType_Gain = 0,
    MixGroupPropertyType_Pitch = 1,
    MixGroupPropertyType_Lfe = 2,
    MixGroupPropertyType_Reverb = 3,
    MixGroupPropertyType_Lpf = 4,
    MixGroupPropertyType_CurveFactor = 5,
    MixGroupPropertyTypeCount = 6,
}

pub static MIXGROUPPROPERTYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXGROUPPROPERTYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixGroupPropertyType {
    fn type_info(&self) -> &'static TypeInfo {
        MIXGROUPPROPERTYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXGROUPPROPERTYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupPropertyType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixGroup {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub group_index: u16,
    pub parent_group_index: u16,
    pub parameters: Vec<MixGroupPropertyParameters>,
}

pub trait MixGroupTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn group_index(&self) -> &u16;
    fn group_index_mut(&mut self) -> &mut u16;
    fn parent_group_index(&self) -> &u16;
    fn parent_group_index_mut(&mut self) -> &mut u16;
    fn parameters(&self) -> &Vec<MixGroupPropertyParameters>;
    fn parameters_mut(&mut self) -> &mut Vec<MixGroupPropertyParameters>;
}

impl MixGroupTrait for MixGroup {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn group_index(&self) -> &u16 {
        &self.group_index
    }
    fn group_index_mut(&mut self) -> &mut u16 {
        &mut self.group_index
    }
    fn parent_group_index(&self) -> &u16 {
        &self.parent_group_index
    }
    fn parent_group_index_mut(&mut self) -> &mut u16 {
        &mut self.parent_group_index
    }
    fn parameters(&self) -> &Vec<MixGroupPropertyParameters> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<MixGroupPropertyParameters> {
        &mut self.parameters
    }
}

impl super::core::DataContainerTrait for MixGroup {
}

pub static MIXGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MixGroup, name),
            },
            FieldInfoData {
                name: "GroupIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(MixGroup, group_index),
            },
            FieldInfoData {
                name: "ParentGroupIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(MixGroup, parent_group_index),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "MixGroupPropertyParameters-Array",
                rust_offset: offset_of!(MixGroup, parameters),
            },
        ],
    }),
    array_type: Some(MIXGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixGroup {
    fn type_info(&self) -> &'static TypeInfo {
        MIXGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixGroupPropertyParameters {
    pub property: u32,
    pub enable_offset_min_max: bool,
    pub min_offset: f32,
    pub max_offset: f32,
    pub override_default_value: bool,
    pub default_value: f32,
}

pub trait MixGroupPropertyParametersTrait: TypeObject {
    fn property(&self) -> &u32;
    fn property_mut(&mut self) -> &mut u32;
    fn enable_offset_min_max(&self) -> &bool;
    fn enable_offset_min_max_mut(&mut self) -> &mut bool;
    fn min_offset(&self) -> &f32;
    fn min_offset_mut(&mut self) -> &mut f32;
    fn max_offset(&self) -> &f32;
    fn max_offset_mut(&mut self) -> &mut f32;
    fn override_default_value(&self) -> &bool;
    fn override_default_value_mut(&mut self) -> &mut bool;
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
}

impl MixGroupPropertyParametersTrait for MixGroupPropertyParameters {
    fn property(&self) -> &u32 {
        &self.property
    }
    fn property_mut(&mut self) -> &mut u32 {
        &mut self.property
    }
    fn enable_offset_min_max(&self) -> &bool {
        &self.enable_offset_min_max
    }
    fn enable_offset_min_max_mut(&mut self) -> &mut bool {
        &mut self.enable_offset_min_max
    }
    fn min_offset(&self) -> &f32 {
        &self.min_offset
    }
    fn min_offset_mut(&mut self) -> &mut f32 {
        &mut self.min_offset
    }
    fn max_offset(&self) -> &f32 {
        &self.max_offset
    }
    fn max_offset_mut(&mut self) -> &mut f32 {
        &mut self.max_offset
    }
    fn override_default_value(&self) -> &bool {
        &self.override_default_value
    }
    fn override_default_value_mut(&mut self) -> &mut bool {
        &mut self.override_default_value
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
}

pub static MIXGROUPPROPERTYPARAMETERS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyParameters",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixGroupPropertyParameters as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MixGroupPropertyParameters, property),
            },
            FieldInfoData {
                name: "EnableOffsetMinMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixGroupPropertyParameters, enable_offset_min_max),
            },
            FieldInfoData {
                name: "MinOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixGroupPropertyParameters, min_offset),
            },
            FieldInfoData {
                name: "MaxOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixGroupPropertyParameters, max_offset),
            },
            FieldInfoData {
                name: "OverrideDefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixGroupPropertyParameters, override_default_value),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixGroupPropertyParameters, default_value),
            },
        ],
    }),
    array_type: Some(MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MixGroupPropertyParameters {
    fn type_info(&self) -> &'static TypeInfo {
        MIXGROUPPROPERTYPARAMETERS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXGROUPPROPERTYPARAMETERS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupPropertyParameters-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupPropertyParameters"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MixGroupState {
    #[default]
    MixGroupState_Normal = 0,
    MixGroupState_Mute = 1,
    MixGroupState_Solo = 2,
    MixGroupStateBitCount = 4,
}

pub static MIXGROUPSTATE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupState",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXGROUPSTATE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixGroupState {
    fn type_info(&self) -> &'static TypeInfo {
        MIXGROUPSTATE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXGROUPSTATE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixGroupState-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixGroupState"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerValueNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub out: AudioGraphNodePort,
    pub default_value: f32,
}

pub trait MixerValueNodeDataTrait: AudioGraphNodeDataTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
}

impl MixerValueNodeDataTrait for MixerValueNodeData {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
}

impl AudioGraphNodeDataTrait for MixerValueNodeData {
}

impl super::core::DataContainerTrait for MixerValueNodeData {
}

pub static MIXERVALUENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerValueNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerValueNodeData, out),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixerValueNodeData, default_value),
            },
        ],
    }),
    array_type: Some(MIXERVALUENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerValueNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERVALUENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERVALUENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MixerValueUIScale {
    #[default]
    MixerValueUIScale_Linear = 0,
    MixerValueUIScale_Logarithmic = 1,
}

pub static MIXERVALUEUISCALE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIScale",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEUISCALE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueUIScale {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERVALUEUISCALE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERVALUEUISCALE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIScale-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueUIScale"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MixerValueUIOrientation {
    #[default]
    MixerValueUIOrientation_Horizontal = 0,
    MixerValueUIOrientation_Vertical = 1,
}

pub static MIXERVALUEUIORIENTATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIOrientation",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEUIORIENTATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueUIOrientation {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERVALUEUIORIENTATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERVALUEUIORIENTATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUIOrientation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueUIOrientation"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MixerValueUI {
    #[default]
    MixerValueUI_None = 0,
    MixerValueUI_Fader = 1,
    MixerValueUI_Knob = 2,
    MixerValueUI_EditBox = 3,
}

pub static MIXERVALUEUI_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUI",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MIXERVALUEUI_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MixerValueUI {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERVALUEUI_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MIXERVALUEUI_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerValueUI-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerValueUI"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSendNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub entry_configs: Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>>,
}

pub trait MixerSendNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn entry_configs(&self) -> &Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>>;
    fn entry_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>>;
}

impl MixerSendNodeConfigDataTrait for MixerSendNodeConfigData {
    fn entry_configs(&self) -> &Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>> {
        &self.entry_configs
    }
    fn entry_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>> {
        &mut self.entry_configs
    }
}

impl AudioGraphNodeConfigDataTrait for MixerSendNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for MixerSendNodeConfigData {
}

pub static MIXERSENDNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSendNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntryConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerEntryConfig-Array",
                rust_offset: offset_of!(MixerSendNodeConfigData, entry_configs),
            },
        ],
    }),
    array_type: Some(MIXERSENDNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSendNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSENDNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSENDNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSendNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerReceiveNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub entry_configs: Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>>,
}

pub trait MixerReceiveNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn entry_configs(&self) -> &Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>>;
    fn entry_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>>;
}

impl MixerReceiveNodeConfigDataTrait for MixerReceiveNodeConfigData {
    fn entry_configs(&self) -> &Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>> {
        &self.entry_configs
    }
    fn entry_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerEntryConfigTrait>>>> {
        &mut self.entry_configs
    }
}

impl AudioGraphNodeConfigDataTrait for MixerReceiveNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for MixerReceiveNodeConfigData {
}

pub static MIXERRECEIVENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerReceiveNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EntryConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerEntryConfig-Array",
                rust_offset: offset_of!(MixerReceiveNodeConfigData, entry_configs),
            },
        ],
    }),
    array_type: Some(MIXERRECEIVENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerReceiveNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERRECEIVENODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERRECEIVENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerReceiveNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerEntryConfig {
    pub _glacier_base: super::core::DataContainer,
    pub graph_parameter: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
}

pub trait MixerEntryConfigTrait: super::core::DataContainerTrait {
    fn graph_parameter(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn graph_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
}

impl MixerEntryConfigTrait for MixerEntryConfig {
    fn graph_parameter(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.graph_parameter
    }
    fn graph_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.graph_parameter
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
}

impl super::core::DataContainerTrait for MixerEntryConfig {
}

pub static MIXERENTRYCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntryConfig",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerEntryConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "GraphParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(MixerEntryConfig, graph_parameter),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(MixerEntryConfig, mixer),
            },
        ],
    }),
    array_type: Some(MIXERENTRYCONFIG_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerEntryConfig {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERENTRYCONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERENTRYCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntryConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntryConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSendNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerSendEntryTrait>>>>,
}

pub trait MixerSendNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerSendEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerSendEntryTrait>>>>;
}

impl MixerSendNodeDataTrait for MixerSendNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerSendEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerSendEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for MixerSendNodeData {
}

impl super::core::DataContainerTrait for MixerSendNodeData {
}

pub static MIXERSENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSendNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerSendEntry-Array",
                rust_offset: offset_of!(MixerSendNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERSENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSendNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSENDNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSendNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSendEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub target: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
}

pub trait MixerSendEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
}

impl MixerSendEntryTrait for MixerSendEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.target
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
}

impl AudioGraphNodePortGroupTrait for MixerSendEntry {
}

impl super::core::DataContainerTrait for MixerSendEntry {
}

pub static MIXERSENDENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSendEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerSendEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(MixerSendEntry, target),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(MixerSendEntry, mixer),
            },
        ],
    }),
    array_type: Some(MIXERSENDENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSendEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSENDENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSENDENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSendEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSendEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerReceiveNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerReceiveEntryTrait>>>>,
}

pub trait MixerReceiveNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerReceiveEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerReceiveEntryTrait>>>>;
}

impl MixerReceiveNodeDataTrait for MixerReceiveNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerReceiveEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerReceiveEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for MixerReceiveNodeData {
}

impl super::core::DataContainerTrait for MixerReceiveNodeData {
}

pub static MIXERRECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerReceiveNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerReceiveEntry-Array",
                rust_offset: offset_of!(MixerReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERRECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerReceiveNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERRECEIVENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERRECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerReceiveNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerReceiveEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub out: AudioGraphNodePort,
    pub source: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
}

pub trait MixerReceiveEntryTrait: AudioGraphNodePortGroupTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
}

impl MixerReceiveEntryTrait for MixerReceiveEntry {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.source
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
}

impl AudioGraphNodePortGroupTrait for MixerReceiveEntry {
}

impl super::core::DataContainerTrait for MixerReceiveEntry {
}

pub static MIXERRECEIVEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerReceiveEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerReceiveEntry, out),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(MixerReceiveEntry, source),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(MixerReceiveEntry, mixer),
            },
        ],
    }),
    array_type: Some(MIXERRECEIVEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerReceiveEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERRECEIVEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERRECEIVEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerReceiveEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerReceiveEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerGetPropertyNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerGetPropertyEntryTrait>>>>,
}

pub trait MixerGetPropertyNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerGetPropertyEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerGetPropertyEntryTrait>>>>;
}

impl MixerGetPropertyNodeDataTrait for MixerGetPropertyNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerGetPropertyEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerGetPropertyEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for MixerGetPropertyNodeData {
}

impl super::core::DataContainerTrait for MixerGetPropertyNodeData {
}

pub static MIXERGETPROPERTYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerGetPropertyNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerGetPropertyEntry-Array",
                rust_offset: offset_of!(MixerGetPropertyNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERGETPROPERTYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerGetPropertyNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERGETPROPERTYNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERGETPROPERTYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerGetPropertyNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerGetPropertyEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub out: AudioGraphNodePort,
    pub property: u32,
    pub group: Option<Arc<Mutex<dyn MixGroupTrait>>>,
}

pub trait MixerGetPropertyEntryTrait: AudioGraphNodePortGroupTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn property(&self) -> &u32;
    fn property_mut(&mut self) -> &mut u32;
    fn group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>>;
}

impl MixerGetPropertyEntryTrait for MixerGetPropertyEntry {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn property(&self) -> &u32 {
        &self.property
    }
    fn property_mut(&mut self) -> &mut u32 {
        &mut self.property
    }
    fn group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &self.group
    }
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &mut self.group
    }
}

impl AudioGraphNodePortGroupTrait for MixerGetPropertyEntry {
}

impl super::core::DataContainerTrait for MixerGetPropertyEntry {
}

pub static MIXERGETPROPERTYENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerGetPropertyEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerGetPropertyEntry, out),
            },
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MixerGetPropertyEntry, property),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: "MixGroup",
                rust_offset: offset_of!(MixerGetPropertyEntry, group),
            },
        ],
    }),
    array_type: Some(MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerGetPropertyEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERGETPROPERTYENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERGETPROPERTYENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerGetPropertyEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerGetPropertyEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSetPropertyNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerSetPropertyEntryTrait>>>>,
}

pub trait MixerSetPropertyNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerSetPropertyEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerSetPropertyEntryTrait>>>>;
}

impl MixerSetPropertyNodeDataTrait for MixerSetPropertyNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerSetPropertyEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerSetPropertyEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for MixerSetPropertyNodeData {
}

impl super::core::DataContainerTrait for MixerSetPropertyNodeData {
}

pub static MIXERSETPROPERTYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSetPropertyNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerSetPropertyEntry-Array",
                rust_offset: offset_of!(MixerSetPropertyNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERSETPROPERTYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSetPropertyNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSETPROPERTYNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSETPROPERTYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSetPropertyNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSetPropertyEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub target: u32,
    pub group: Option<Arc<Mutex<dyn MixGroupTrait>>>,
    pub attack_time: f32,
    pub release_time: f32,
}

pub trait MixerSetPropertyEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn target(&self) -> &u32;
    fn target_mut(&mut self) -> &mut u32;
    fn group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn attack_time(&self) -> &f32;
    fn attack_time_mut(&mut self) -> &mut f32;
    fn release_time(&self) -> &f32;
    fn release_time_mut(&mut self) -> &mut f32;
}

impl MixerSetPropertyEntryTrait for MixerSetPropertyEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn target(&self) -> &u32 {
        &self.target
    }
    fn target_mut(&mut self) -> &mut u32 {
        &mut self.target
    }
    fn group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &self.group
    }
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &mut self.group
    }
    fn attack_time(&self) -> &f32 {
        &self.attack_time
    }
    fn attack_time_mut(&mut self) -> &mut f32 {
        &mut self.attack_time
    }
    fn release_time(&self) -> &f32 {
        &self.release_time
    }
    fn release_time_mut(&mut self) -> &mut f32 {
        &mut self.release_time
    }
}

impl AudioGraphNodePortGroupTrait for MixerSetPropertyEntry {
}

impl super::core::DataContainerTrait for MixerSetPropertyEntry {
}

pub static MIXERSETPROPERTYENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSetPropertyEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerSetPropertyEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MixerSetPropertyEntry, target),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: "MixGroup",
                rust_offset: offset_of!(MixerSetPropertyEntry, group),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixerSetPropertyEntry, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MixerSetPropertyEntry, release_time),
            },
        ],
    }),
    array_type: Some(MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSetPropertyEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSETPROPERTYENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSETPROPERTYENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSetPropertyEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSetPropertyEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerSimplePresetNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub index: AudioGraphNodePort,
    pub presets: Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>>,
}

pub trait MixerSimplePresetNodeDataTrait: AudioGraphNodeDataTrait {
    fn index(&self) -> &AudioGraphNodePort;
    fn index_mut(&mut self) -> &mut AudioGraphNodePort;
    fn presets(&self) -> &Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>>;
    fn presets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>>;
}

impl MixerSimplePresetNodeDataTrait for MixerSimplePresetNodeData {
    fn index(&self) -> &AudioGraphNodePort {
        &self.index
    }
    fn index_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.index
    }
    fn presets(&self) -> &Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>> {
        &self.presets
    }
    fn presets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerPresetTrait>>>> {
        &mut self.presets
    }
}

impl AudioGraphNodeDataTrait for MixerSimplePresetNodeData {
}

impl super::core::DataContainerTrait for MixerSimplePresetNodeData {
}

pub static MIXERSIMPLEPRESETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSimplePresetNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerSimplePresetNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerSimplePresetNodeData, index),
            },
            FieldInfoData {
                name: "Presets",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerPreset-Array",
                rust_offset: offset_of!(MixerSimplePresetNodeData, presets),
            },
        ],
    }),
    array_type: Some(MIXERSIMPLEPRESETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerSimplePresetNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERSIMPLEPRESETNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERSIMPLEPRESETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerSimplePresetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerSimplePresetNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerOutputNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerOutputEntryTrait>>>>,
}

pub trait MixerOutputNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerOutputEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerOutputEntryTrait>>>>;
}

impl MixerOutputNodeDataTrait for MixerOutputNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerOutputEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerOutputEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for MixerOutputNodeData {
}

impl super::core::DataContainerTrait for MixerOutputNodeData {
}

pub static MIXEROUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerOutputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerOutputEntry-Array",
                rust_offset: offset_of!(MixerOutputNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXEROUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerOutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXEROUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXEROUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerOutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerOutputEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub target: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
}

pub trait MixerOutputEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
}

impl MixerOutputEntryTrait for MixerOutputEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.target
    }
}

impl AudioGraphNodePortGroupTrait for MixerOutputEntry {
}

impl super::core::DataContainerTrait for MixerOutputEntry {
}

pub static MIXEROUTPUTENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerOutputEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerOutputEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(MixerOutputEntry, target),
            },
        ],
    }),
    array_type: Some(MIXEROUTPUTENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerOutputEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXEROUTPUTENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXEROUTPUTENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerOutputEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerOutputEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerInputNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerInputEntryTrait>>>>,
}

pub trait MixerInputNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerInputEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerInputEntryTrait>>>>;
}

impl MixerInputNodeDataTrait for MixerInputNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerInputEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerInputEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for MixerInputNodeData {
}

impl super::core::DataContainerTrait for MixerInputNodeData {
}

pub static MIXERINPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerInputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerInputEntry-Array",
                rust_offset: offset_of!(MixerInputNodeData, entries),
            },
        ],
    }),
    array_type: Some(MIXERINPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerInputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERINPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERINPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerInputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerInputEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub out: AudioGraphNodePort,
    pub source: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub accumulate_mode: MixerValueAccumulateMode,
    pub keep_value: bool,
}

pub trait MixerInputEntryTrait: AudioGraphNodePortGroupTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn accumulate_mode(&self) -> &MixerValueAccumulateMode;
    fn accumulate_mode_mut(&mut self) -> &mut MixerValueAccumulateMode;
    fn keep_value(&self) -> &bool;
    fn keep_value_mut(&mut self) -> &mut bool;
}

impl MixerInputEntryTrait for MixerInputEntry {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.source
    }
    fn accumulate_mode(&self) -> &MixerValueAccumulateMode {
        &self.accumulate_mode
    }
    fn accumulate_mode_mut(&mut self) -> &mut MixerValueAccumulateMode {
        &mut self.accumulate_mode
    }
    fn keep_value(&self) -> &bool {
        &self.keep_value
    }
    fn keep_value_mut(&mut self) -> &mut bool {
        &mut self.keep_value
    }
}

impl AudioGraphNodePortGroupTrait for MixerInputEntry {
}

impl super::core::DataContainerTrait for MixerInputEntry {
}

pub static MIXERINPUTENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerInputEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerInputEntry, out),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(MixerInputEntry, source),
            },
            FieldInfoData {
                name: "AccumulateMode",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerValueAccumulateMode",
                rust_offset: offset_of!(MixerInputEntry, accumulate_mode),
            },
            FieldInfoData {
                name: "KeepValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerInputEntry, keep_value),
            },
        ],
    }),
    array_type: Some(MIXERINPUTENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerInputEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERINPUTENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERINPUTENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerInputEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerInputEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphEnumerationParameterConfigData {
    pub _glacier_base: AudioGraphParameterConfigData,
    pub value: f32,
}

pub trait AudioGraphEnumerationParameterConfigDataTrait: AudioGraphParameterConfigDataTrait {
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl AudioGraphEnumerationParameterConfigDataTrait for AudioGraphEnumerationParameterConfigData {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl AudioGraphParameterConfigDataTrait for AudioGraphEnumerationParameterConfigData {
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
}

impl super::core::DataContainerTrait for AudioGraphEnumerationParameterConfigData {
}

pub static AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphEnumerationParameterConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioGraphEnumerationParameterConfigData, value),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphEnumerationParameterConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHENUMERATIONPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphEnumerationParameterConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphValueParameterConfigData {
    pub _glacier_base: AudioGraphParameterConfigData,
    pub value: f32,
}

pub trait AudioGraphValueParameterConfigDataTrait: AudioGraphParameterConfigDataTrait {
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl AudioGraphValueParameterConfigDataTrait for AudioGraphValueParameterConfigData {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl AudioGraphParameterConfigDataTrait for AudioGraphValueParameterConfigData {
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
}

impl super::core::DataContainerTrait for AudioGraphValueParameterConfigData {
}

pub static AUDIOGRAPHVALUEPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphValueParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphValueParameterConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioGraphValueParameterConfigData, value),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHVALUEPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphValueParameterConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHVALUEPARAMETERCONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHVALUEPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphValueParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphValueParameterConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphAssetParameterConfigData {
    pub _glacier_base: AudioGraphParameterConfigData,
    pub asset: Option<Arc<Mutex<dyn super::core::AssetTrait>>>,
}

pub trait AudioGraphAssetParameterConfigDataTrait: AudioGraphParameterConfigDataTrait {
    fn asset(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>>;
}

impl AudioGraphAssetParameterConfigDataTrait for AudioGraphAssetParameterConfigData {
    fn asset(&self) -> &Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::AssetTrait>>> {
        &mut self.asset
    }
}

impl AudioGraphParameterConfigDataTrait for AudioGraphAssetParameterConfigData {
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
}

impl super::core::DataContainerTrait for AudioGraphAssetParameterConfigData {
}

pub static AUDIOGRAPHASSETPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphAssetParameterConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "Asset",
                rust_offset: offset_of!(AudioGraphAssetParameterConfigData, asset),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHASSETPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphAssetParameterConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHASSETPARAMETERCONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHASSETPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphAssetParameterConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphParameterConfigData {
    pub _glacier_base: super::core::DataContainer,
    pub name_hash: u32,
}

pub trait AudioGraphParameterConfigDataTrait: super::core::DataContainerTrait {
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
}

impl AudioGraphParameterConfigDataTrait for AudioGraphParameterConfigData {
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
}

impl super::core::DataContainerTrait for AudioGraphParameterConfigData {
}

pub static AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameterConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphParameterConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioGraphParameterConfigData, name_hash),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphParameterConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHPARAMETERCONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHPARAMETERCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameterConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphParameterConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphNodeConfigData {
    pub _glacier_base: super::core::DataContainer,
    pub node: Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>,
    pub configured_property_flags: u64,
}

pub trait AudioGraphNodeConfigDataTrait: super::core::DataContainerTrait {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn configured_property_flags(&self) -> &u64;
    fn configured_property_flags_mut(&mut self) -> &mut u64;
}

impl AudioGraphNodeConfigDataTrait for AudioGraphNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &self.node
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &mut self.node
    }
    fn configured_property_flags(&self) -> &u64 {
        &self.configured_property_flags
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        &mut self.configured_property_flags
    }
}

impl super::core::DataContainerTrait for AudioGraphNodeConfigData {
}

pub static AUDIOGRAPHNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodeData",
                rust_offset: offset_of!(AudioGraphNodeConfigData, node),
            },
            FieldInfoData {
                name: "ConfiguredPropertyFlags",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint64",
                rust_offset: offset_of!(AudioGraphNodeConfigData, configured_property_flags),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphData {
    pub _glacier_base: super::core::DataContainer,
    pub nodes: Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>,
    pub public_parameters: Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>,
    pub public_events: Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>,
    pub public_asset_parameters: Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>>,
    pub public_value_count: u16,
    pub value_count: u16,
}

pub trait AudioGraphDataTrait: super::core::DataContainerTrait {
    fn nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
    fn nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>>;
    fn public_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn public_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn public_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>;
    fn public_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>;
    fn public_asset_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>>;
    fn public_asset_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>>;
    fn public_value_count(&self) -> &u16;
    fn public_value_count_mut(&mut self) -> &mut u16;
    fn value_count(&self) -> &u16;
    fn value_count_mut(&mut self) -> &mut u16;
}

impl AudioGraphDataTrait for AudioGraphData {
    fn nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &self.nodes
    }
    fn nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        &mut self.nodes
    }
    fn public_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &self.public_parameters
    }
    fn public_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &mut self.public_parameters
    }
    fn public_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        &self.public_events
    }
    fn public_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        &mut self.public_events
    }
    fn public_asset_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>> {
        &self.public_asset_parameters
    }
    fn public_asset_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>> {
        &mut self.public_asset_parameters
    }
    fn public_value_count(&self) -> &u16 {
        &self.public_value_count
    }
    fn public_value_count_mut(&mut self) -> &mut u16 {
        &mut self.public_value_count
    }
    fn value_count(&self) -> &u16 {
        &self.value_count
    }
    fn value_count_mut(&mut self) -> &mut u16 {
        &mut self.value_count
    }
}

impl super::core::DataContainerTrait for AudioGraphData {
}

pub static AUDIOGRAPHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Nodes",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphNodeData-Array",
                rust_offset: offset_of!(AudioGraphData, nodes),
            },
            FieldInfoData {
                name: "PublicParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphParameter-Array",
                rust_offset: offset_of!(AudioGraphData, public_parameters),
            },
            FieldInfoData {
                name: "PublicEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphEvent-Array",
                rust_offset: offset_of!(AudioGraphData, public_events),
            },
            FieldInfoData {
                name: "PublicAssetParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphAssetParameter-Array",
                rust_offset: offset_of!(AudioGraphData, public_asset_parameters),
            },
            FieldInfoData {
                name: "PublicValueCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(AudioGraphData, public_value_count),
            },
            FieldInfoData {
                name: "ValueCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(AudioGraphData, value_count),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphNodeData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AudioGraphNodeDataTrait: super::core::DataContainerTrait {
}

impl AudioGraphNodeDataTrait for AudioGraphNodeData {
}

impl super::core::DataContainerTrait for AudioGraphNodeData {
}

pub static AUDIOGRAPHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphNodeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphNodePortGroup {
    pub _glacier_base: super::core::DataContainer,
}

pub trait AudioGraphNodePortGroupTrait: super::core::DataContainerTrait {
}

impl AudioGraphNodePortGroupTrait for AudioGraphNodePortGroup {
}

impl super::core::DataContainerTrait for AudioGraphNodePortGroup {
}

pub static AUDIOGRAPHNODEPORTGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePortGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphNodePortGroup as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHNODEPORTGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphNodePortGroup {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHNODEPORTGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHNODEPORTGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePortGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodePortGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphNodePort {
    pub unconnected_value: f32,
    pub value_index: u16,
    pub is_connected: bool,
}

pub trait AudioGraphNodePortTrait: TypeObject {
    fn unconnected_value(&self) -> &f32;
    fn unconnected_value_mut(&mut self) -> &mut f32;
    fn value_index(&self) -> &u16;
    fn value_index_mut(&mut self) -> &mut u16;
    fn is_connected(&self) -> &bool;
    fn is_connected_mut(&mut self) -> &mut bool;
}

impl AudioGraphNodePortTrait for AudioGraphNodePort {
    fn unconnected_value(&self) -> &f32 {
        &self.unconnected_value
    }
    fn unconnected_value_mut(&mut self) -> &mut f32 {
        &mut self.unconnected_value
    }
    fn value_index(&self) -> &u16 {
        &self.value_index
    }
    fn value_index_mut(&mut self) -> &mut u16 {
        &mut self.value_index
    }
    fn is_connected(&self) -> &bool {
        &self.is_connected
    }
    fn is_connected_mut(&mut self) -> &mut bool {
        &mut self.is_connected
    }
}

pub static AUDIOGRAPHNODEPORT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePort",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphNodePort as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnconnectedValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioGraphNodePort, unconnected_value),
            },
            FieldInfoData {
                name: "ValueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(AudioGraphNodePort, value_index),
            },
            FieldInfoData {
                name: "IsConnected",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AudioGraphNodePort, is_connected),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHNODEPORT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for AudioGraphNodePort {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHNODEPORT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AUDIOGRAPHNODEPORT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphNodePort-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphNodePort"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphEnumerationParameter {
    pub _glacier_base: AudioGraphParameter,
}

pub trait AudioGraphEnumerationParameterTrait: AudioGraphParameterTrait {
}

impl AudioGraphEnumerationParameterTrait for AudioGraphEnumerationParameter {
}

impl AudioGraphParameterTrait for AudioGraphEnumerationParameter {
    fn default_value(&self) -> &f32 {
        self._glacier_base.default_value()
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        self._glacier_base.default_value_mut()
    }
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
    fn value_index(&self) -> &u16 {
        self._glacier_base.value_index()
    }
    fn value_index_mut(&mut self) -> &mut u16 {
        self._glacier_base.value_index_mut()
    }
}

impl super::core::DataContainerTrait for AudioGraphEnumerationParameter {
}

pub static AUDIOGRAPHENUMERATIONPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphEnumerationParameter as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHENUMERATIONPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphEnumerationParameter {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHENUMERATIONPARAMETER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHENUMERATIONPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEnumerationParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphEnumerationParameter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphAssetParameter {
    pub _glacier_base: AudioGraphParameter,
}

pub trait AudioGraphAssetParameterTrait: AudioGraphParameterTrait {
}

impl AudioGraphAssetParameterTrait for AudioGraphAssetParameter {
}

impl AudioGraphParameterTrait for AudioGraphAssetParameter {
    fn default_value(&self) -> &f32 {
        self._glacier_base.default_value()
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        self._glacier_base.default_value_mut()
    }
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
    fn value_index(&self) -> &u16 {
        self._glacier_base.value_index()
    }
    fn value_index_mut(&mut self) -> &mut u16 {
        self._glacier_base.value_index_mut()
    }
}

impl super::core::DataContainerTrait for AudioGraphAssetParameter {
}

pub static AUDIOGRAPHASSETPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphAssetParameter as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphAssetParameter {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHASSETPARAMETER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHASSETPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphAssetParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphAssetParameter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphEvent {
    pub _glacier_base: AudioGraphParameter,
}

pub trait AudioGraphEventTrait: AudioGraphParameterTrait {
}

impl AudioGraphEventTrait for AudioGraphEvent {
}

impl AudioGraphParameterTrait for AudioGraphEvent {
    fn default_value(&self) -> &f32 {
        self._glacier_base.default_value()
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        self._glacier_base.default_value_mut()
    }
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
    fn value_index(&self) -> &u16 {
        self._glacier_base.value_index()
    }
    fn value_index_mut(&mut self) -> &mut u16 {
        self._glacier_base.value_index_mut()
    }
}

impl super::core::DataContainerTrait for AudioGraphEvent {
}

pub static AUDIOGRAPHEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEvent",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHPARAMETER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphEvent as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(AUDIOGRAPHEVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphEvent {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioGraphParameter {
    pub _glacier_base: super::core::DataContainer,
    pub default_value: f32,
    pub name_hash: u32,
    pub value_index: u16,
}

pub trait AudioGraphParameterTrait: super::core::DataContainerTrait {
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn value_index(&self) -> &u16;
    fn value_index_mut(&mut self) -> &mut u16;
}

impl AudioGraphParameterTrait for AudioGraphParameter {
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn value_index(&self) -> &u16 {
        &self.value_index
    }
    fn value_index_mut(&mut self) -> &mut u16 {
        &mut self.value_index
    }
}

impl super::core::DataContainerTrait for AudioGraphParameter {
}

pub static AUDIOGRAPHPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioGraphParameter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AudioGraphParameter, default_value),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(AudioGraphParameter, name_hash),
            },
            FieldInfoData {
                name: "ValueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(AudioGraphParameter, value_index),
            },
        ],
    }),
    array_type: Some(AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioGraphParameter {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOGRAPHPARAMETER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOGRAPHPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioGraphParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioGraphParameter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueCurveNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub curves: Vec<Option<Arc<Mutex<dyn ValueCurveNodeEntryTrait>>>>,
    pub r#in: AudioGraphNodePort,
}

pub trait ValueCurveNodeDataTrait: AudioGraphNodeDataTrait {
    fn curves(&self) -> &Vec<Option<Arc<Mutex<dyn ValueCurveNodeEntryTrait>>>>;
    fn curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ValueCurveNodeEntryTrait>>>>;
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl ValueCurveNodeDataTrait for ValueCurveNodeData {
    fn curves(&self) -> &Vec<Option<Arc<Mutex<dyn ValueCurveNodeEntryTrait>>>> {
        &self.curves
    }
    fn curves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ValueCurveNodeEntryTrait>>>> {
        &mut self.curves
    }
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
}

impl AudioGraphNodeDataTrait for ValueCurveNodeData {
}

impl super::core::DataContainerTrait for ValueCurveNodeData {
}

pub static VALUECURVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueCurveNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Curves",
                flags: MemberInfoFlags::new(144),
                field_type: "ValueCurveNodeEntry-Array",
                rust_offset: offset_of!(ValueCurveNodeData, curves),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ValueCurveNodeData, r#in),
            },
        ],
    }),
    array_type: Some(VALUECURVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueCurveNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        VALUECURVENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUECURVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueCurveNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueCurveNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub out: AudioGraphNodePort,
}

pub trait ValueCurveNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl ValueCurveNodeEntryTrait for ValueCurveNodeEntry {
    fn curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.curve
    }
    fn curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.curve
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodePortGroupTrait for ValueCurveNodeEntry {
}

impl super::core::DataContainerTrait for ValueCurveNodeEntry {
}

pub static VALUECURVENODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueCurveNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Curve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(ValueCurveNodeEntry, curve),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ValueCurveNodeEntry, out),
            },
        ],
    }),
    array_type: Some(VALUECURVENODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueCurveNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        VALUECURVENODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUECURVENODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueCurveNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueCurveNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SampleAndHoldNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub hold: AudioGraphNodePort,
    pub release: AudioGraphNodePort,
}

pub trait SampleAndHoldNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn hold(&self) -> &AudioGraphNodePort;
    fn hold_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release(&self) -> &AudioGraphNodePort;
    fn release_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl SampleAndHoldNodeDataTrait for SampleAndHoldNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn hold(&self) -> &AudioGraphNodePort {
        &self.hold
    }
    fn hold_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.hold
    }
    fn release(&self) -> &AudioGraphNodePort {
        &self.release
    }
    fn release_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release
    }
}

impl AudioGraphNodeDataTrait for SampleAndHoldNodeData {
}

impl super::core::DataContainerTrait for SampleAndHoldNodeData {
}

pub static SAMPLEANDHOLDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SampleAndHoldNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SampleAndHoldNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SampleAndHoldNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SampleAndHoldNodeData, out),
            },
            FieldInfoData {
                name: "Hold",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SampleAndHoldNodeData, hold),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SampleAndHoldNodeData, release),
            },
        ],
    }),
    array_type: Some(SAMPLEANDHOLDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SampleAndHoldNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLEANDHOLDNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAMPLEANDHOLDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SampleAndHoldNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SampleAndHoldNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterRouterNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub route_in: AudioGraphNodePort,
    pub route_out: AudioGraphNodePort,
    pub default_out: AudioGraphNodePort,
    pub parameter_router_entries: Vec<Option<Arc<Mutex<dyn ParameterRouterEntryTrait>>>>,
}

pub trait ParameterRouterNodeDataTrait: AudioGraphNodeDataTrait {
    fn route_in(&self) -> &AudioGraphNodePort;
    fn route_in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn route_out(&self) -> &AudioGraphNodePort;
    fn route_out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_out(&self) -> &AudioGraphNodePort;
    fn default_out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn parameter_router_entries(&self) -> &Vec<Option<Arc<Mutex<dyn ParameterRouterEntryTrait>>>>;
    fn parameter_router_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ParameterRouterEntryTrait>>>>;
}

impl ParameterRouterNodeDataTrait for ParameterRouterNodeData {
    fn route_in(&self) -> &AudioGraphNodePort {
        &self.route_in
    }
    fn route_in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.route_in
    }
    fn route_out(&self) -> &AudioGraphNodePort {
        &self.route_out
    }
    fn route_out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.route_out
    }
    fn default_out(&self) -> &AudioGraphNodePort {
        &self.default_out
    }
    fn default_out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.default_out
    }
    fn parameter_router_entries(&self) -> &Vec<Option<Arc<Mutex<dyn ParameterRouterEntryTrait>>>> {
        &self.parameter_router_entries
    }
    fn parameter_router_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ParameterRouterEntryTrait>>>> {
        &mut self.parameter_router_entries
    }
}

impl AudioGraphNodeDataTrait for ParameterRouterNodeData {
}

impl super::core::DataContainerTrait for ParameterRouterNodeData {
}

pub static PARAMETERROUTERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterRouterNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RouteIn",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterRouterNodeData, route_in),
            },
            FieldInfoData {
                name: "RouteOut",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterRouterNodeData, route_out),
            },
            FieldInfoData {
                name: "DefaultOut",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterRouterNodeData, default_out),
            },
            FieldInfoData {
                name: "ParameterRouterEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "ParameterRouterEntry-Array",
                rust_offset: offset_of!(ParameterRouterNodeData, parameter_router_entries),
            },
        ],
    }),
    array_type: Some(PARAMETERROUTERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterRouterNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERROUTERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERROUTERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterRouterNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterRouterEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub trait ParameterRouterEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl ParameterRouterEntryTrait for ParameterRouterEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodePortGroupTrait for ParameterRouterEntry {
}

impl super::core::DataContainerTrait for ParameterRouterEntry {
}

pub static PARAMETERROUTERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterRouterEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterRouterEntry, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterRouterEntry, out),
            },
        ],
    }),
    array_type: Some(PARAMETERROUTERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterRouterEntry {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERROUTERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERROUTERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterRouterEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterRouterEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct KeepAliveNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub keep_alive: AudioGraphNodePort,
}

pub trait KeepAliveNodeDataTrait: AudioGraphNodeDataTrait {
    fn keep_alive(&self) -> &AudioGraphNodePort;
    fn keep_alive_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl KeepAliveNodeDataTrait for KeepAliveNodeData {
    fn keep_alive(&self) -> &AudioGraphNodePort {
        &self.keep_alive
    }
    fn keep_alive_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.keep_alive
    }
}

impl AudioGraphNodeDataTrait for KeepAliveNodeData {
}

impl super::core::DataContainerTrait for KeepAliveNodeData {
}

pub static KEEPALIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KeepAliveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<KeepAliveNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "KeepAlive",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(KeepAliveNodeData, keep_alive),
            },
        ],
    }),
    array_type: Some(KEEPALIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for KeepAliveNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        KEEPALIVENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static KEEPALIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "KeepAliveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("KeepAliveNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSequencerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub interval: AudioGraphNodePort,
    pub interval_variation: AudioGraphNodePort,
    pub repeat: AudioGraphNodePort,
    pub repeat_variation: AudioGraphNodePort,
    pub out_events: Vec<Option<Arc<Mutex<dyn EventSequencerOutEventTrait>>>>,
    pub playback: EventSequencerPlayback,
    pub ignore_first_interval: bool,
    pub version: EventSequencerNodeVersion,
}

pub trait EventSequencerNodeDataTrait: AudioGraphNodeDataTrait {
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn interval(&self) -> &AudioGraphNodePort;
    fn interval_mut(&mut self) -> &mut AudioGraphNodePort;
    fn interval_variation(&self) -> &AudioGraphNodePort;
    fn interval_variation_mut(&mut self) -> &mut AudioGraphNodePort;
    fn repeat(&self) -> &AudioGraphNodePort;
    fn repeat_mut(&mut self) -> &mut AudioGraphNodePort;
    fn repeat_variation(&self) -> &AudioGraphNodePort;
    fn repeat_variation_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out_events(&self) -> &Vec<Option<Arc<Mutex<dyn EventSequencerOutEventTrait>>>>;
    fn out_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn EventSequencerOutEventTrait>>>>;
    fn playback(&self) -> &EventSequencerPlayback;
    fn playback_mut(&mut self) -> &mut EventSequencerPlayback;
    fn ignore_first_interval(&self) -> &bool;
    fn ignore_first_interval_mut(&mut self) -> &mut bool;
    fn version(&self) -> &EventSequencerNodeVersion;
    fn version_mut(&mut self) -> &mut EventSequencerNodeVersion;
}

impl EventSequencerNodeDataTrait for EventSequencerNodeData {
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn interval(&self) -> &AudioGraphNodePort {
        &self.interval
    }
    fn interval_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.interval
    }
    fn interval_variation(&self) -> &AudioGraphNodePort {
        &self.interval_variation
    }
    fn interval_variation_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.interval_variation
    }
    fn repeat(&self) -> &AudioGraphNodePort {
        &self.repeat
    }
    fn repeat_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.repeat
    }
    fn repeat_variation(&self) -> &AudioGraphNodePort {
        &self.repeat_variation
    }
    fn repeat_variation_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.repeat_variation
    }
    fn out_events(&self) -> &Vec<Option<Arc<Mutex<dyn EventSequencerOutEventTrait>>>> {
        &self.out_events
    }
    fn out_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn EventSequencerOutEventTrait>>>> {
        &mut self.out_events
    }
    fn playback(&self) -> &EventSequencerPlayback {
        &self.playback
    }
    fn playback_mut(&mut self) -> &mut EventSequencerPlayback {
        &mut self.playback
    }
    fn ignore_first_interval(&self) -> &bool {
        &self.ignore_first_interval
    }
    fn ignore_first_interval_mut(&mut self) -> &mut bool {
        &mut self.ignore_first_interval
    }
    fn version(&self) -> &EventSequencerNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut EventSequencerNodeVersion {
        &mut self.version
    }
}

impl AudioGraphNodeDataTrait for EventSequencerNodeData {
}

impl super::core::DataContainerTrait for EventSequencerNodeData {
}

pub static EVENTSEQUENCERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSequencerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerNodeData, stop),
            },
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerNodeData, interval),
            },
            FieldInfoData {
                name: "IntervalVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerNodeData, interval_variation),
            },
            FieldInfoData {
                name: "Repeat",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerNodeData, repeat),
            },
            FieldInfoData {
                name: "RepeatVariation",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerNodeData, repeat_variation),
            },
            FieldInfoData {
                name: "OutEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "EventSequencerOutEvent-Array",
                rust_offset: offset_of!(EventSequencerNodeData, out_events),
            },
            FieldInfoData {
                name: "Playback",
                flags: MemberInfoFlags::new(0),
                field_type: "EventSequencerPlayback",
                rust_offset: offset_of!(EventSequencerNodeData, playback),
            },
            FieldInfoData {
                name: "IgnoreFirstInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventSequencerNodeData, ignore_first_interval),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "EventSequencerNodeVersion",
                rust_offset: offset_of!(EventSequencerNodeData, version),
            },
        ],
    }),
    array_type: Some(EVENTSEQUENCERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSequencerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSEQUENCERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSEQUENCERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSequencerOutEvent {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub out: AudioGraphNodePort,
}

pub trait EventSequencerOutEventTrait: AudioGraphNodePortGroupTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl EventSequencerOutEventTrait for EventSequencerOutEvent {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodePortGroupTrait for EventSequencerOutEvent {
}

impl super::core::DataContainerTrait for EventSequencerOutEvent {
}

pub static EVENTSEQUENCEROUTEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerOutEvent",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSequencerOutEvent as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSequencerOutEvent, out),
            },
        ],
    }),
    array_type: Some(EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSequencerOutEvent {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSEQUENCEROUTEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSEQUENCEROUTEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerOutEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerOutEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventSequencerPlayback {
    #[default]
    EventSequencerPlayback_Sequential = 0,
    EventSequencerPlayback_Simultaneous = 1,
    EventSequencerPlayback_Random = 2,
}

pub static EVENTSEQUENCERPLAYBACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerPlayback",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTSEQUENCERPLAYBACK_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventSequencerPlayback {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSEQUENCERPLAYBACK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTSEQUENCERPLAYBACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerPlayback-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerPlayback"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum EventSequencerNodeVersion {
    #[default]
    EventSequencerNodeVersion_2012_2 = 0,
    EventSequencerNodeVersion_2014_5 = 1,
    EventSequencerNodeVersion_2015_1 = 2,
}

pub static EVENTSEQUENCERNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(EVENTSEQUENCERNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for EventSequencerNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSEQUENCERNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EVENTSEQUENCERNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSequencerNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSequencerNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueSelectorNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub inputs: Vec<Option<Arc<Mutex<dyn ValueSelectorEntryTrait>>>>,
    pub value: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub default_case_value: f32,
}

pub trait ValueSelectorNodeDataTrait: AudioGraphNodeDataTrait {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn ValueSelectorEntryTrait>>>>;
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ValueSelectorEntryTrait>>>>;
    fn value(&self) -> &AudioGraphNodePort;
    fn value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_case_value(&self) -> &f32;
    fn default_case_value_mut(&mut self) -> &mut f32;
}

impl ValueSelectorNodeDataTrait for ValueSelectorNodeData {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn ValueSelectorEntryTrait>>>> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ValueSelectorEntryTrait>>>> {
        &mut self.inputs
    }
    fn value(&self) -> &AudioGraphNodePort {
        &self.value
    }
    fn value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.value
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn default_case_value(&self) -> &f32 {
        &self.default_case_value
    }
    fn default_case_value_mut(&mut self) -> &mut f32 {
        &mut self.default_case_value
    }
}

impl AudioGraphNodeDataTrait for ValueSelectorNodeData {
}

impl super::core::DataContainerTrait for ValueSelectorNodeData {
}

pub static VALUESELECTORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueSelectorNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "ValueSelectorEntry-Array",
                rust_offset: offset_of!(ValueSelectorNodeData, inputs),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ValueSelectorNodeData, value),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ValueSelectorNodeData, out),
            },
            FieldInfoData {
                name: "DefaultCaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ValueSelectorNodeData, default_case_value),
            },
        ],
    }),
    array_type: Some(VALUESELECTORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueSelectorNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        VALUESELECTORNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUESELECTORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueSelectorNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueSelectorEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub input: AudioGraphNodePort,
    pub case_value: f32,
}

pub trait ValueSelectorEntryTrait: AudioGraphNodePortGroupTrait {
    fn input(&self) -> &AudioGraphNodePort;
    fn input_mut(&mut self) -> &mut AudioGraphNodePort;
    fn case_value(&self) -> &f32;
    fn case_value_mut(&mut self) -> &mut f32;
}

impl ValueSelectorEntryTrait for ValueSelectorEntry {
    fn input(&self) -> &AudioGraphNodePort {
        &self.input
    }
    fn input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.input
    }
    fn case_value(&self) -> &f32 {
        &self.case_value
    }
    fn case_value_mut(&mut self) -> &mut f32 {
        &mut self.case_value
    }
}

impl AudioGraphNodePortGroupTrait for ValueSelectorEntry {
}

impl super::core::DataContainerTrait for ValueSelectorEntry {
}

pub static VALUESELECTORENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueSelectorEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ValueSelectorEntry, input),
            },
            FieldInfoData {
                name: "CaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ValueSelectorEntry, case_value),
            },
        ],
    }),
    array_type: Some(VALUESELECTORENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueSelectorEntry {
    fn type_info(&self) -> &'static TypeInfo {
        VALUESELECTORENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUESELECTORENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueSelectorEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueSelectorEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TimerNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub period: f32,
    pub mode: TimerMode,
    pub progress_output: ProgressMode,
}

pub trait TimerNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn period(&self) -> &f32;
    fn period_mut(&mut self) -> &mut f32;
    fn mode(&self) -> &TimerMode;
    fn mode_mut(&mut self) -> &mut TimerMode;
    fn progress_output(&self) -> &ProgressMode;
    fn progress_output_mut(&mut self) -> &mut ProgressMode;
}

impl TimerNodeConfigDataTrait for TimerNodeConfigData {
    fn period(&self) -> &f32 {
        &self.period
    }
    fn period_mut(&mut self) -> &mut f32 {
        &mut self.period
    }
    fn mode(&self) -> &TimerMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut TimerMode {
        &mut self.mode
    }
    fn progress_output(&self) -> &ProgressMode {
        &self.progress_output
    }
    fn progress_output_mut(&mut self) -> &mut ProgressMode {
        &mut self.progress_output
    }
}

impl AudioGraphNodeConfigDataTrait for TimerNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for TimerNodeConfigData {
}

pub static TIMERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TimerNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Period",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TimerNodeConfigData, period),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "TimerMode",
                rust_offset: offset_of!(TimerNodeConfigData, mode),
            },
            FieldInfoData {
                name: "ProgressOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "ProgressMode",
                rust_offset: offset_of!(TimerNodeConfigData, progress_output),
            },
        ],
    }),
    array_type: Some(TIMERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TimerNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        TIMERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TIMERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TimerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub period: AudioGraphNodePort,
    pub tick: AudioGraphNodePort,
    pub progress: AudioGraphNodePort,
    pub mode: TimerMode,
    pub progress_output: ProgressMode,
    pub version: TimerNodeVersion,
}

pub trait TimerNodeDataTrait: AudioGraphNodeDataTrait {
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn period(&self) -> &AudioGraphNodePort;
    fn period_mut(&mut self) -> &mut AudioGraphNodePort;
    fn tick(&self) -> &AudioGraphNodePort;
    fn tick_mut(&mut self) -> &mut AudioGraphNodePort;
    fn progress(&self) -> &AudioGraphNodePort;
    fn progress_mut(&mut self) -> &mut AudioGraphNodePort;
    fn mode(&self) -> &TimerMode;
    fn mode_mut(&mut self) -> &mut TimerMode;
    fn progress_output(&self) -> &ProgressMode;
    fn progress_output_mut(&mut self) -> &mut ProgressMode;
    fn version(&self) -> &TimerNodeVersion;
    fn version_mut(&mut self) -> &mut TimerNodeVersion;
}

impl TimerNodeDataTrait for TimerNodeData {
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn period(&self) -> &AudioGraphNodePort {
        &self.period
    }
    fn period_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.period
    }
    fn tick(&self) -> &AudioGraphNodePort {
        &self.tick
    }
    fn tick_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.tick
    }
    fn progress(&self) -> &AudioGraphNodePort {
        &self.progress
    }
    fn progress_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.progress
    }
    fn mode(&self) -> &TimerMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut TimerMode {
        &mut self.mode
    }
    fn progress_output(&self) -> &ProgressMode {
        &self.progress_output
    }
    fn progress_output_mut(&mut self) -> &mut ProgressMode {
        &mut self.progress_output
    }
    fn version(&self) -> &TimerNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut TimerNodeVersion {
        &mut self.version
    }
}

impl AudioGraphNodeDataTrait for TimerNodeData {
}

impl super::core::DataContainerTrait for TimerNodeData {
}

pub static TIMERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TimerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimerNodeData, stop),
            },
            FieldInfoData {
                name: "Period",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimerNodeData, period),
            },
            FieldInfoData {
                name: "Tick",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimerNodeData, tick),
            },
            FieldInfoData {
                name: "Progress",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimerNodeData, progress),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "TimerMode",
                rust_offset: offset_of!(TimerNodeData, mode),
            },
            FieldInfoData {
                name: "ProgressOutput",
                flags: MemberInfoFlags::new(0),
                field_type: "ProgressMode",
                rust_offset: offset_of!(TimerNodeData, progress_output),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "TimerNodeVersion",
                rust_offset: offset_of!(TimerNodeData, version),
            },
        ],
    }),
    array_type: Some(TIMERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TimerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        TIMERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TIMERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ProgressMode {
    #[default]
    ProgressMode_Normalized = 0,
    ProgressMode_Time = 1,
}

pub static PROGRESSMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProgressMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PROGRESSMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ProgressMode {
    fn type_info(&self) -> &'static TypeInfo {
        PROGRESSMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROGRESSMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ProgressMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ProgressMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimerMode {
    #[default]
    TimerMode_Repeating = 0,
    TimerMode_SingleShot = 1,
}

pub static TIMERMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMERMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimerMode {
    fn type_info(&self) -> &'static TypeInfo {
        TIMERMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TIMERMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimerNodeVersion {
    #[default]
    TimerNodeVersion_2012_4 = 0,
    TimerNodeVersion_2015_3 = 1,
    TimerNodeVersion_2016_4 = 2,
}

pub static TIMERNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMERNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimerNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        TIMERNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TIMERNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimerNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimerNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SwitcherNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub outputs: Vec<Option<Arc<Mutex<dyn SwitcherEntryTrait>>>>,
    pub trigger: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub default_case_value: f32,
}

pub trait SwitcherNodeDataTrait: AudioGraphNodeDataTrait {
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn SwitcherEntryTrait>>>>;
    fn outputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SwitcherEntryTrait>>>>;
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn value(&self) -> &AudioGraphNodePort;
    fn value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_case_value(&self) -> &f32;
    fn default_case_value_mut(&mut self) -> &mut f32;
}

impl SwitcherNodeDataTrait for SwitcherNodeData {
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn SwitcherEntryTrait>>>> {
        &self.outputs
    }
    fn outputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SwitcherEntryTrait>>>> {
        &mut self.outputs
    }
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn value(&self) -> &AudioGraphNodePort {
        &self.value
    }
    fn value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.value
    }
    fn default_case_value(&self) -> &f32 {
        &self.default_case_value
    }
    fn default_case_value_mut(&mut self) -> &mut f32 {
        &mut self.default_case_value
    }
}

impl AudioGraphNodeDataTrait for SwitcherNodeData {
}

impl super::core::DataContainerTrait for SwitcherNodeData {
}

pub static SWITCHERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitcherNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: "SwitcherEntry-Array",
                rust_offset: offset_of!(SwitcherNodeData, outputs),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SwitcherNodeData, trigger),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SwitcherNodeData, value),
            },
            FieldInfoData {
                name: "DefaultCaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SwitcherNodeData, default_case_value),
            },
        ],
    }),
    array_type: Some(SWITCHERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitcherNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SWITCHERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SwitcherNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SwitcherEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub case_trigger: AudioGraphNodePort,
    pub case_value: f32,
}

pub trait SwitcherEntryTrait: AudioGraphNodePortGroupTrait {
    fn case_trigger(&self) -> &AudioGraphNodePort;
    fn case_trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn case_value(&self) -> &f32;
    fn case_value_mut(&mut self) -> &mut f32;
}

impl SwitcherEntryTrait for SwitcherEntry {
    fn case_trigger(&self) -> &AudioGraphNodePort {
        &self.case_trigger
    }
    fn case_trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.case_trigger
    }
    fn case_value(&self) -> &f32 {
        &self.case_value
    }
    fn case_value_mut(&mut self) -> &mut f32 {
        &mut self.case_value
    }
}

impl AudioGraphNodePortGroupTrait for SwitcherEntry {
}

impl super::core::DataContainerTrait for SwitcherEntry {
}

pub static SWITCHERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SwitcherEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CaseTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SwitcherEntry, case_trigger),
            },
            FieldInfoData {
                name: "CaseValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SwitcherEntry, case_value),
            },
        ],
    }),
    array_type: Some(SWITCHERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SwitcherEntry {
    fn type_info(&self) -> &'static TypeInfo {
        SWITCHERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SWITCHERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SwitcherEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SwitcherEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleValueSelectorNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub out_values: Vec<f32>,
}

pub trait SimpleValueSelectorNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn out_values(&self) -> &Vec<f32>;
    fn out_values_mut(&mut self) -> &mut Vec<f32>;
}

impl SimpleValueSelectorNodeConfigDataTrait for SimpleValueSelectorNodeConfigData {
    fn out_values(&self) -> &Vec<f32> {
        &self.out_values
    }
    fn out_values_mut(&mut self) -> &mut Vec<f32> {
        &mut self.out_values
    }
}

impl AudioGraphNodeConfigDataTrait for SimpleValueSelectorNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for SimpleValueSelectorNodeConfigData {
}

pub static SIMPLEVALUESELECTORNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleValueSelectorNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(SimpleValueSelectorNodeConfigData, out_values),
            },
        ],
    }),
    array_type: Some(SIMPLEVALUESELECTORNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleValueSelectorNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEVALUESELECTORNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEVALUESELECTORNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleValueSelectorNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleValueSelectorNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub out_values: Vec<f32>,
    pub index: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub trait SimpleValueSelectorNodeDataTrait: AudioGraphNodeDataTrait {
    fn out_values(&self) -> &Vec<f32>;
    fn out_values_mut(&mut self) -> &mut Vec<f32>;
    fn index(&self) -> &AudioGraphNodePort;
    fn index_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl SimpleValueSelectorNodeDataTrait for SimpleValueSelectorNodeData {
    fn out_values(&self) -> &Vec<f32> {
        &self.out_values
    }
    fn out_values_mut(&mut self) -> &mut Vec<f32> {
        &mut self.out_values
    }
    fn index(&self) -> &AudioGraphNodePort {
        &self.index
    }
    fn index_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.index
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodeDataTrait for SimpleValueSelectorNodeData {
}

impl super::core::DataContainerTrait for SimpleValueSelectorNodeData {
}

pub static SIMPLEVALUESELECTORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleValueSelectorNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutValues",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(SimpleValueSelectorNodeData, out_values),
            },
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SimpleValueSelectorNodeData, index),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SimpleValueSelectorNodeData, out),
            },
        ],
    }),
    array_type: Some(SIMPLEVALUESELECTORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleValueSelectorNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLEVALUESELECTORNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLEVALUESELECTORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleValueSelectorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleValueSelectorNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultipleTransformNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub x: AudioGraphNodePort,
    pub transforms: Vec<Option<Arc<Mutex<dyn MultipleTransformEntryTrait>>>>,
    pub result: AudioGraphNodePort,
}

pub trait MultipleTransformNodeDataTrait: AudioGraphNodeDataTrait {
    fn x(&self) -> &AudioGraphNodePort;
    fn x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn transforms(&self) -> &Vec<Option<Arc<Mutex<dyn MultipleTransformEntryTrait>>>>;
    fn transforms_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MultipleTransformEntryTrait>>>>;
    fn result(&self) -> &AudioGraphNodePort;
    fn result_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MultipleTransformNodeDataTrait for MultipleTransformNodeData {
    fn x(&self) -> &AudioGraphNodePort {
        &self.x
    }
    fn x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.x
    }
    fn transforms(&self) -> &Vec<Option<Arc<Mutex<dyn MultipleTransformEntryTrait>>>> {
        &self.transforms
    }
    fn transforms_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MultipleTransformEntryTrait>>>> {
        &mut self.transforms
    }
    fn result(&self) -> &AudioGraphNodePort {
        &self.result
    }
    fn result_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.result
    }
}

impl AudioGraphNodeDataTrait for MultipleTransformNodeData {
}

impl super::core::DataContainerTrait for MultipleTransformNodeData {
}

pub static MULTIPLETRANSFORMNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultipleTransformNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultipleTransformNodeData, x),
            },
            FieldInfoData {
                name: "Transforms",
                flags: MemberInfoFlags::new(144),
                field_type: "MultipleTransformEntry-Array",
                rust_offset: offset_of!(MultipleTransformNodeData, transforms),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultipleTransformNodeData, result),
            },
        ],
    }),
    array_type: Some(MULTIPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultipleTransformNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIPLETRANSFORMNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultipleTransformNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultipleTransformEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub y: AudioGraphNodePort,
    pub z: AudioGraphNodePort,
    pub operation: SimpleTransformOperation,
    pub angle_unit: AngleUnit,
}

pub trait MultipleTransformEntryTrait: AudioGraphNodePortGroupTrait {
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn z(&self) -> &AudioGraphNodePort;
    fn z_mut(&mut self) -> &mut AudioGraphNodePort;
    fn operation(&self) -> &SimpleTransformOperation;
    fn operation_mut(&mut self) -> &mut SimpleTransformOperation;
    fn angle_unit(&self) -> &AngleUnit;
    fn angle_unit_mut(&mut self) -> &mut AngleUnit;
}

impl MultipleTransformEntryTrait for MultipleTransformEntry {
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
    fn z(&self) -> &AudioGraphNodePort {
        &self.z
    }
    fn z_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.z
    }
    fn operation(&self) -> &SimpleTransformOperation {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut SimpleTransformOperation {
        &mut self.operation
    }
    fn angle_unit(&self) -> &AngleUnit {
        &self.angle_unit
    }
    fn angle_unit_mut(&mut self) -> &mut AngleUnit {
        &mut self.angle_unit
    }
}

impl AudioGraphNodePortGroupTrait for MultipleTransformEntry {
}

impl super::core::DataContainerTrait for MultipleTransformEntry {
}

pub static MULTIPLETRANSFORMENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultipleTransformEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultipleTransformEntry, y),
            },
            FieldInfoData {
                name: "Z",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultipleTransformEntry, z),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleTransformOperation",
                rust_offset: offset_of!(MultipleTransformEntry, operation),
            },
            FieldInfoData {
                name: "AngleUnit",
                flags: MemberInfoFlags::new(0),
                field_type: "AngleUnit",
                rust_offset: offset_of!(MultipleTransformEntry, angle_unit),
            },
        ],
    }),
    array_type: Some(MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultipleTransformEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MULTIPLETRANSFORMENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTIPLETRANSFORMENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultipleTransformEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultipleTransformEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SimpleTransformNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub z: AudioGraphNodePort,
    pub operation: SimpleTransformOperation,
    pub angle_unit: AngleUnit,
}

pub trait SimpleTransformNodeDataTrait: AudioGraphNodeDataTrait {
    fn x(&self) -> &AudioGraphNodePort;
    fn x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn z(&self) -> &AudioGraphNodePort;
    fn z_mut(&mut self) -> &mut AudioGraphNodePort;
    fn operation(&self) -> &SimpleTransformOperation;
    fn operation_mut(&mut self) -> &mut SimpleTransformOperation;
    fn angle_unit(&self) -> &AngleUnit;
    fn angle_unit_mut(&mut self) -> &mut AngleUnit;
}

impl SimpleTransformNodeDataTrait for SimpleTransformNodeData {
    fn x(&self) -> &AudioGraphNodePort {
        &self.x
    }
    fn x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.x
    }
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
    fn z(&self) -> &AudioGraphNodePort {
        &self.z
    }
    fn z_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.z
    }
    fn operation(&self) -> &SimpleTransformOperation {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut SimpleTransformOperation {
        &mut self.operation
    }
    fn angle_unit(&self) -> &AngleUnit {
        &self.angle_unit
    }
    fn angle_unit_mut(&mut self) -> &mut AngleUnit {
        &mut self.angle_unit
    }
}

impl AudioGraphNodeDataTrait for SimpleTransformNodeData {
}

impl super::core::DataContainerTrait for SimpleTransformNodeData {
}

pub static SIMPLETRANSFORMNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SimpleTransformNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SimpleTransformNodeData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SimpleTransformNodeData, y),
            },
            FieldInfoData {
                name: "Z",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SimpleTransformNodeData, z),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "SimpleTransformOperation",
                rust_offset: offset_of!(SimpleTransformNodeData, operation),
            },
            FieldInfoData {
                name: "AngleUnit",
                flags: MemberInfoFlags::new(0),
                field_type: "AngleUnit",
                rust_offset: offset_of!(SimpleTransformNodeData, angle_unit),
            },
        ],
    }),
    array_type: Some(SIMPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SimpleTransformNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLETRANSFORMNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SIMPLETRANSFORMNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleTransformNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AngleUnit {
    #[default]
    AngleUnit_Radians = 0,
    AngleUnit_Degrees = 1,
}

pub static ANGLEUNIT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleUnit",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(ANGLEUNIT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AngleUnit {
    fn type_info(&self) -> &'static TypeInfo {
        ANGLEUNIT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ANGLEUNIT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AngleUnit-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AngleUnit"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SimpleTransformOperation {
    #[default]
    SimpleTransformOperation_Add = 0,
    SimpleTransformOperation_Subtract = 1,
    SimpleTransformOperation_Multiply = 2,
    SimpleTransformOperation_Divide = 3,
    SimpleTransformOperation_Sine = 4,
    SimpleTransformOperation_Cosine = 5,
    SimpleTransformOperation_ArcSine = 6,
    SimpleTransformOperation_ArcCosine = 7,
    SimpleTransformOperation_Modulus = 8,
    SimpleTransformOperation_Round = 9,
    SimpleTransformOperation_Floor = 10,
    SimpleTransformOperation_Ceiling = 11,
    SimpleTransformOperation_Power = 12,
    SimpleTransformOperation_SquareRoot = 13,
    SimpleTransformOperation_Absolute = 14,
    SimpleTransformOperation_Exp = 15,
    SimpleTransformOperation_Log = 16,
    SimpleTransformOperation_Log10 = 17,
    SimpleTransformOperation_Tangent = 18,
    SimpleTransformOperation_ArcTangent = 19,
    SimpleTransformOperation_LinearToDb = 20,
    SimpleTransformOperation_DbToLinear = 21,
}

pub static SIMPLETRANSFORMOPERATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformOperation",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SIMPLETRANSFORMOPERATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SimpleTransformOperation {
    fn type_info(&self) -> &'static TypeInfo {
        SIMPLETRANSFORMOPERATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SIMPLETRANSFORMOPERATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SimpleTransformOperation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SimpleTransformOperation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SequenceGeneratorNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub trigger: AudioGraphNodePort,
    pub reset: AudioGraphNodePort,
    pub min: AudioGraphNodePort,
    pub max: AudioGraphNodePort,
    pub step: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub update_value_on_events: bool,
}

pub trait SequenceGeneratorNodeDataTrait: AudioGraphNodeDataTrait {
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reset(&self) -> &AudioGraphNodePort;
    fn reset_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min(&self) -> &AudioGraphNodePort;
    fn min_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max(&self) -> &AudioGraphNodePort;
    fn max_mut(&mut self) -> &mut AudioGraphNodePort;
    fn step(&self) -> &AudioGraphNodePort;
    fn step_mut(&mut self) -> &mut AudioGraphNodePort;
    fn value(&self) -> &AudioGraphNodePort;
    fn value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn update_value_on_events(&self) -> &bool;
    fn update_value_on_events_mut(&mut self) -> &mut bool;
}

impl SequenceGeneratorNodeDataTrait for SequenceGeneratorNodeData {
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn reset(&self) -> &AudioGraphNodePort {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reset
    }
    fn min(&self) -> &AudioGraphNodePort {
        &self.min
    }
    fn min_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.min
    }
    fn max(&self) -> &AudioGraphNodePort {
        &self.max
    }
    fn max_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.max
    }
    fn step(&self) -> &AudioGraphNodePort {
        &self.step
    }
    fn step_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.step
    }
    fn value(&self) -> &AudioGraphNodePort {
        &self.value
    }
    fn value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.value
    }
    fn update_value_on_events(&self) -> &bool {
        &self.update_value_on_events
    }
    fn update_value_on_events_mut(&mut self) -> &mut bool {
        &mut self.update_value_on_events
    }
}

impl AudioGraphNodeDataTrait for SequenceGeneratorNodeData {
}

impl super::core::DataContainerTrait for SequenceGeneratorNodeData {
}

pub static SEQUENCEGENERATORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceGeneratorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SequenceGeneratorNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SequenceGeneratorNodeData, trigger),
            },
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SequenceGeneratorNodeData, reset),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SequenceGeneratorNodeData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SequenceGeneratorNodeData, max),
            },
            FieldInfoData {
                name: "Step",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SequenceGeneratorNodeData, step),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SequenceGeneratorNodeData, value),
            },
            FieldInfoData {
                name: "UpdateValueOnEvents",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SequenceGeneratorNodeData, update_value_on_events),
            },
        ],
    }),
    array_type: Some(SEQUENCEGENERATORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SequenceGeneratorNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SEQUENCEGENERATORNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SEQUENCEGENERATORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SequenceGeneratorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SequenceGeneratorNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SendNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn SendEntryTrait>>>>,
}

pub trait SendNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn SendEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SendEntryTrait>>>>;
}

impl SendNodeDataTrait for SendNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn SendEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SendEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for SendNodeData {
}

impl super::core::DataContainerTrait for SendNodeData {
}

pub static SENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SendNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "SendEntry-Array",
                rust_offset: offset_of!(SendNodeData, entries),
            },
        ],
    }),
    array_type: Some(SENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SendNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SENDNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SendNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SendEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub target: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
}

pub trait SendEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
}

impl SendEntryTrait for SendEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.target
    }
}

impl AudioGraphNodePortGroupTrait for SendEntry {
}

impl super::core::DataContainerTrait for SendEntry {
}

pub static SENDENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SendEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SendEntry, r#in),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(SendEntry, target),
            },
        ],
    }),
    array_type: Some(SENDENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SendEntry {
    fn type_info(&self) -> &'static TypeInfo {
        SENDENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SENDENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SendEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SendEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScaleClampNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub in_min: f32,
    pub in_max: f32,
    pub out_min: f32,
    pub out_max: f32,
}

pub trait ScaleClampNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn in_min(&self) -> &f32;
    fn in_min_mut(&mut self) -> &mut f32;
    fn in_max(&self) -> &f32;
    fn in_max_mut(&mut self) -> &mut f32;
    fn out_min(&self) -> &f32;
    fn out_min_mut(&mut self) -> &mut f32;
    fn out_max(&self) -> &f32;
    fn out_max_mut(&mut self) -> &mut f32;
}

impl ScaleClampNodeConfigDataTrait for ScaleClampNodeConfigData {
    fn in_min(&self) -> &f32 {
        &self.in_min
    }
    fn in_min_mut(&mut self) -> &mut f32 {
        &mut self.in_min
    }
    fn in_max(&self) -> &f32 {
        &self.in_max
    }
    fn in_max_mut(&mut self) -> &mut f32 {
        &mut self.in_max
    }
    fn out_min(&self) -> &f32 {
        &self.out_min
    }
    fn out_min_mut(&mut self) -> &mut f32 {
        &mut self.out_min
    }
    fn out_max(&self) -> &f32 {
        &self.out_max
    }
    fn out_max_mut(&mut self) -> &mut f32 {
        &mut self.out_max
    }
}

impl AudioGraphNodeConfigDataTrait for ScaleClampNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for ScaleClampNodeConfigData {
}

pub static SCALECLAMPNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScaleClampNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "InMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScaleClampNodeConfigData, in_min),
            },
            FieldInfoData {
                name: "InMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScaleClampNodeConfigData, in_max),
            },
            FieldInfoData {
                name: "OutMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScaleClampNodeConfigData, out_min),
            },
            FieldInfoData {
                name: "OutMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ScaleClampNodeConfigData, out_max),
            },
        ],
    }),
    array_type: Some(SCALECLAMPNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScaleClampNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        SCALECLAMPNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCALECLAMPNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScaleClampNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ScaleClampNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub in_min: AudioGraphNodePort,
    pub in_max: AudioGraphNodePort,
    pub out_min: AudioGraphNodePort,
    pub out_max: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub trait ScaleClampNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn in_min(&self) -> &AudioGraphNodePort;
    fn in_min_mut(&mut self) -> &mut AudioGraphNodePort;
    fn in_max(&self) -> &AudioGraphNodePort;
    fn in_max_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out_min(&self) -> &AudioGraphNodePort;
    fn out_min_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out_max(&self) -> &AudioGraphNodePort;
    fn out_max_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl ScaleClampNodeDataTrait for ScaleClampNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn in_min(&self) -> &AudioGraphNodePort {
        &self.in_min
    }
    fn in_min_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.in_min
    }
    fn in_max(&self) -> &AudioGraphNodePort {
        &self.in_max
    }
    fn in_max_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.in_max
    }
    fn out_min(&self) -> &AudioGraphNodePort {
        &self.out_min
    }
    fn out_min_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out_min
    }
    fn out_max(&self) -> &AudioGraphNodePort {
        &self.out_max
    }
    fn out_max_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out_max
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodeDataTrait for ScaleClampNodeData {
}

impl super::core::DataContainerTrait for ScaleClampNodeData {
}

pub static SCALECLAMPNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ScaleClampNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ScaleClampNodeData, r#in),
            },
            FieldInfoData {
                name: "InMin",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ScaleClampNodeData, in_min),
            },
            FieldInfoData {
                name: "InMax",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ScaleClampNodeData, in_max),
            },
            FieldInfoData {
                name: "OutMin",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ScaleClampNodeData, out_min),
            },
            FieldInfoData {
                name: "OutMax",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ScaleClampNodeData, out_max),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ScaleClampNodeData, out),
            },
        ],
    }),
    array_type: Some(SCALECLAMPNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ScaleClampNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SCALECLAMPNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SCALECLAMPNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScaleClampNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScaleClampNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ContextSendNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn SoundContextSendEntryTrait>>>>,
}

pub trait ContextSendNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextSendEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextSendEntryTrait>>>>;
}

impl ContextSendNodeDataTrait for ContextSendNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextSendEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextSendEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for ContextSendNodeData {
}

impl super::core::DataContainerTrait for ContextSendNodeData {
}

pub static CONTEXTSENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextSendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ContextSendNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundContextSendEntry-Array",
                rust_offset: offset_of!(ContextSendNodeData, entries),
            },
        ],
    }),
    array_type: Some(CONTEXTSENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextSendNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTEXTSENDNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONTEXTSENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextSendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ContextSendNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextSendEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub context: Option<Arc<Mutex<dyn SoundContextDataTrait>>>,
}

pub trait SoundContextSendEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn context(&self) -> &Option<Arc<Mutex<dyn SoundContextDataTrait>>>;
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextDataTrait>>>;
}

impl SoundContextSendEntryTrait for SoundContextSendEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn context(&self) -> &Option<Arc<Mutex<dyn SoundContextDataTrait>>> {
        &self.context
    }
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextDataTrait>>> {
        &mut self.context
    }
}

impl AudioGraphNodePortGroupTrait for SoundContextSendEntry {
}

impl super::core::DataContainerTrait for SoundContextSendEntry {
}

pub static SOUNDCONTEXTSENDENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSendEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextSendEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SoundContextSendEntry, r#in),
            },
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextData",
                rust_offset: offset_of!(SoundContextSendEntry, context),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextSendEntry {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTSENDENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTSENDENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextSendEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextSendEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ContextReceiveNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn SoundContextReceiveEntryTrait>>>>,
}

pub trait ContextReceiveNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextReceiveEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextReceiveEntryTrait>>>>;
}

impl ContextReceiveNodeDataTrait for ContextReceiveNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn SoundContextReceiveEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundContextReceiveEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for ContextReceiveNodeData {
}

impl super::core::DataContainerTrait for ContextReceiveNodeData {
}

pub static CONTEXTRECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ContextReceiveNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundContextReceiveEntry-Array",
                rust_offset: offset_of!(ContextReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(CONTEXTRECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ContextReceiveNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTEXTRECEIVENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONTEXTRECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ContextReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ContextReceiveNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextReceiveEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub out: AudioGraphNodePort,
    pub context: Option<Arc<Mutex<dyn SoundContextDataTrait>>>,
}

pub trait SoundContextReceiveEntryTrait: AudioGraphNodePortGroupTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn context(&self) -> &Option<Arc<Mutex<dyn SoundContextDataTrait>>>;
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextDataTrait>>>;
}

impl SoundContextReceiveEntryTrait for SoundContextReceiveEntry {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn context(&self) -> &Option<Arc<Mutex<dyn SoundContextDataTrait>>> {
        &self.context
    }
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextDataTrait>>> {
        &mut self.context
    }
}

impl AudioGraphNodePortGroupTrait for SoundContextReceiveEntry {
}

impl super::core::DataContainerTrait for SoundContextReceiveEntry {
}

pub static SOUNDCONTEXTRECEIVEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextReceiveEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextReceiveEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SoundContextReceiveEntry, out),
            },
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextData",
                rust_offset: offset_of!(SoundContextReceiveEntry, context),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextReceiveEntry {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTRECEIVEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTRECEIVEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextReceiveEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextReceiveEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReceiveNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn ReceiveEntryTrait>>>>,
}

pub trait ReceiveNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn ReceiveEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ReceiveEntryTrait>>>>;
}

impl ReceiveNodeDataTrait for ReceiveNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn ReceiveEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ReceiveEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for ReceiveNodeData {
}

impl super::core::DataContainerTrait for ReceiveNodeData {
}

pub static RECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReceiveNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "ReceiveEntry-Array",
                rust_offset: offset_of!(ReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(RECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReceiveNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        RECEIVENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ReceiveNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ReceiveEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub out: AudioGraphNodePort,
    pub source: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub parameter: f32,
    pub saved_value: f32,
}

pub trait ReceiveEntryTrait: AudioGraphNodePortGroupTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn parameter(&self) -> &f32;
    fn parameter_mut(&mut self) -> &mut f32;
    fn saved_value(&self) -> &f32;
    fn saved_value_mut(&mut self) -> &mut f32;
}

impl ReceiveEntryTrait for ReceiveEntry {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.source
    }
    fn parameter(&self) -> &f32 {
        &self.parameter
    }
    fn parameter_mut(&mut self) -> &mut f32 {
        &mut self.parameter
    }
    fn saved_value(&self) -> &f32 {
        &self.saved_value
    }
    fn saved_value_mut(&mut self) -> &mut f32 {
        &mut self.saved_value
    }
}

impl AudioGraphNodePortGroupTrait for ReceiveEntry {
}

impl super::core::DataContainerTrait for ReceiveEntry {
}

pub static RECEIVEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ReceiveEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ReceiveEntry, out),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(ReceiveEntry, source),
            },
            FieldInfoData {
                name: "Parameter",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ReceiveEntry, parameter),
            },
            FieldInfoData {
                name: "SavedValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ReceiveEntry, saved_value),
            },
        ],
    }),
    array_type: Some(RECEIVEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ReceiveEntry {
    fn type_info(&self) -> &'static TypeInfo {
        RECEIVEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RECEIVEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ReceiveEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ReceiveEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RangeMapperNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub ranges: Vec<RangeMapperConfigEntry>,
}

pub trait RangeMapperNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn ranges(&self) -> &Vec<RangeMapperConfigEntry>;
    fn ranges_mut(&mut self) -> &mut Vec<RangeMapperConfigEntry>;
}

impl RangeMapperNodeConfigDataTrait for RangeMapperNodeConfigData {
    fn ranges(&self) -> &Vec<RangeMapperConfigEntry> {
        &self.ranges
    }
    fn ranges_mut(&mut self) -> &mut Vec<RangeMapperConfigEntry> {
        &mut self.ranges
    }
}

impl AudioGraphNodeConfigDataTrait for RangeMapperNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for RangeMapperNodeConfigData {
}

pub static RANGEMAPPERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RangeMapperNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Ranges",
                flags: MemberInfoFlags::new(144),
                field_type: "RangeMapperConfigEntry-Array",
                rust_offset: offset_of!(RangeMapperNodeConfigData, ranges),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RangeMapperNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        RANGEMAPPERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANGEMAPPERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RangeMapperConfigEntry {
    pub range_start: f32,
    pub range_end: f32,
    pub output_value: f32,
}

pub trait RangeMapperConfigEntryTrait: TypeObject {
    fn range_start(&self) -> &f32;
    fn range_start_mut(&mut self) -> &mut f32;
    fn range_end(&self) -> &f32;
    fn range_end_mut(&mut self) -> &mut f32;
    fn output_value(&self) -> &f32;
    fn output_value_mut(&mut self) -> &mut f32;
}

impl RangeMapperConfigEntryTrait for RangeMapperConfigEntry {
    fn range_start(&self) -> &f32 {
        &self.range_start
    }
    fn range_start_mut(&mut self) -> &mut f32 {
        &mut self.range_start
    }
    fn range_end(&self) -> &f32 {
        &self.range_end
    }
    fn range_end_mut(&mut self) -> &mut f32 {
        &mut self.range_end
    }
    fn output_value(&self) -> &f32 {
        &self.output_value
    }
    fn output_value_mut(&mut self) -> &mut f32 {
        &mut self.output_value
    }
}

pub static RANGEMAPPERCONFIGENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperConfigEntry",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RangeMapperConfigEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RangeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RangeMapperConfigEntry, range_start),
            },
            FieldInfoData {
                name: "RangeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RangeMapperConfigEntry, range_end),
            },
            FieldInfoData {
                name: "OutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(RangeMapperConfigEntry, output_value),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for RangeMapperConfigEntry {
    fn type_info(&self) -> &'static TypeInfo {
        RANGEMAPPERCONFIGENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static RANGEMAPPERCONFIGENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperConfigEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperConfigEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RangeMapperNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub default_output_value: AudioGraphNodePort,
    pub ranges: Vec<Option<Arc<Mutex<dyn RangeMapperEntryTrait>>>>,
    pub out: AudioGraphNodePort,
    pub default_output_value_enabled: bool,
}

pub trait RangeMapperNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_output_value(&self) -> &AudioGraphNodePort;
    fn default_output_value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn ranges(&self) -> &Vec<Option<Arc<Mutex<dyn RangeMapperEntryTrait>>>>;
    fn ranges_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RangeMapperEntryTrait>>>>;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_output_value_enabled(&self) -> &bool;
    fn default_output_value_enabled_mut(&mut self) -> &mut bool;
}

impl RangeMapperNodeDataTrait for RangeMapperNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn default_output_value(&self) -> &AudioGraphNodePort {
        &self.default_output_value
    }
    fn default_output_value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.default_output_value
    }
    fn ranges(&self) -> &Vec<Option<Arc<Mutex<dyn RangeMapperEntryTrait>>>> {
        &self.ranges
    }
    fn ranges_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RangeMapperEntryTrait>>>> {
        &mut self.ranges
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn default_output_value_enabled(&self) -> &bool {
        &self.default_output_value_enabled
    }
    fn default_output_value_enabled_mut(&mut self) -> &mut bool {
        &mut self.default_output_value_enabled
    }
}

impl AudioGraphNodeDataTrait for RangeMapperNodeData {
}

impl super::core::DataContainerTrait for RangeMapperNodeData {
}

pub static RANGEMAPPERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RangeMapperNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RangeMapperNodeData, r#in),
            },
            FieldInfoData {
                name: "DefaultOutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RangeMapperNodeData, default_output_value),
            },
            FieldInfoData {
                name: "Ranges",
                flags: MemberInfoFlags::new(144),
                field_type: "RangeMapperEntry-Array",
                rust_offset: offset_of!(RangeMapperNodeData, ranges),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RangeMapperNodeData, out),
            },
            FieldInfoData {
                name: "DefaultOutputValueEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(RangeMapperNodeData, default_output_value_enabled),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RangeMapperNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        RANGEMAPPERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANGEMAPPERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RangeMapperEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub range_start: AudioGraphNodePort,
    pub range_end: AudioGraphNodePort,
    pub output_value: AudioGraphNodePort,
}

pub trait RangeMapperEntryTrait: AudioGraphNodePortGroupTrait {
    fn range_start(&self) -> &AudioGraphNodePort;
    fn range_start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn range_end(&self) -> &AudioGraphNodePort;
    fn range_end_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output_value(&self) -> &AudioGraphNodePort;
    fn output_value_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl RangeMapperEntryTrait for RangeMapperEntry {
    fn range_start(&self) -> &AudioGraphNodePort {
        &self.range_start
    }
    fn range_start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.range_start
    }
    fn range_end(&self) -> &AudioGraphNodePort {
        &self.range_end
    }
    fn range_end_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.range_end
    }
    fn output_value(&self) -> &AudioGraphNodePort {
        &self.output_value
    }
    fn output_value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output_value
    }
}

impl AudioGraphNodePortGroupTrait for RangeMapperEntry {
}

impl super::core::DataContainerTrait for RangeMapperEntry {
}

pub static RANGEMAPPERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RangeMapperEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RangeStart",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RangeMapperEntry, range_start),
            },
            FieldInfoData {
                name: "RangeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RangeMapperEntry, range_end),
            },
            FieldInfoData {
                name: "OutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RangeMapperEntry, output_value),
            },
        ],
    }),
    array_type: Some(RANGEMAPPERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RangeMapperEntry {
    fn type_info(&self) -> &'static TypeInfo {
        RANGEMAPPERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static RANGEMAPPERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RangeMapperEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RangeMapperEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterFilterLinearNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub attack_speed: AudioGraphNodePort,
    pub release_speed: AudioGraphNodePort,
    pub default_output_value: f32,
    pub keep_active: bool,
    pub skip_first_update: bool,
}

pub trait ParameterFilterLinearNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn attack_speed(&self) -> &AudioGraphNodePort;
    fn attack_speed_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release_speed(&self) -> &AudioGraphNodePort;
    fn release_speed_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_output_value(&self) -> &f32;
    fn default_output_value_mut(&mut self) -> &mut f32;
    fn keep_active(&self) -> &bool;
    fn keep_active_mut(&mut self) -> &mut bool;
    fn skip_first_update(&self) -> &bool;
    fn skip_first_update_mut(&mut self) -> &mut bool;
}

impl ParameterFilterLinearNodeDataTrait for ParameterFilterLinearNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn attack_speed(&self) -> &AudioGraphNodePort {
        &self.attack_speed
    }
    fn attack_speed_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.attack_speed
    }
    fn release_speed(&self) -> &AudioGraphNodePort {
        &self.release_speed
    }
    fn release_speed_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release_speed
    }
    fn default_output_value(&self) -> &f32 {
        &self.default_output_value
    }
    fn default_output_value_mut(&mut self) -> &mut f32 {
        &mut self.default_output_value
    }
    fn keep_active(&self) -> &bool {
        &self.keep_active
    }
    fn keep_active_mut(&mut self) -> &mut bool {
        &mut self.keep_active
    }
    fn skip_first_update(&self) -> &bool {
        &self.skip_first_update
    }
    fn skip_first_update_mut(&mut self) -> &mut bool {
        &mut self.skip_first_update
    }
}

impl AudioGraphNodeDataTrait for ParameterFilterLinearNodeData {
}

impl super::core::DataContainerTrait for ParameterFilterLinearNodeData {
}

pub static PARAMETERFILTERLINEARNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLinearNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterFilterLinearNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, out),
            },
            FieldInfoData {
                name: "AttackSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, attack_speed),
            },
            FieldInfoData {
                name: "ReleaseSpeed",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, release_speed),
            },
            FieldInfoData {
                name: "DefaultOutputValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, default_output_value),
            },
            FieldInfoData {
                name: "KeepActive",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, keep_active),
            },
            FieldInfoData {
                name: "SkipFirstUpdate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ParameterFilterLinearNodeData, skip_first_update),
            },
        ],
    }),
    array_type: Some(PARAMETERFILTERLINEARNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterFilterLinearNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERFILTERLINEARNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERFILTERLINEARNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLinearNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterFilterLinearNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterFilterLpNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub hz: AudioGraphNodePort,
    pub version: ParameterFilterLpNodeVersion,
}

pub trait ParameterFilterLpNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn hz(&self) -> &AudioGraphNodePort;
    fn hz_mut(&mut self) -> &mut AudioGraphNodePort;
    fn version(&self) -> &ParameterFilterLpNodeVersion;
    fn version_mut(&mut self) -> &mut ParameterFilterLpNodeVersion;
}

impl ParameterFilterLpNodeDataTrait for ParameterFilterLpNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn hz(&self) -> &AudioGraphNodePort {
        &self.hz
    }
    fn hz_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.hz
    }
    fn version(&self) -> &ParameterFilterLpNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut ParameterFilterLpNodeVersion {
        &mut self.version
    }
}

impl AudioGraphNodeDataTrait for ParameterFilterLpNodeData {
}

impl super::core::DataContainerTrait for ParameterFilterLpNodeData {
}

pub static PARAMETERFILTERLPNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterFilterLpNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLpNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLpNodeData, out),
            },
            FieldInfoData {
                name: "Hz",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterFilterLpNodeData, hz),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "ParameterFilterLpNodeVersion",
                rust_offset: offset_of!(ParameterFilterLpNodeData, version),
            },
        ],
    }),
    array_type: Some(PARAMETERFILTERLPNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterFilterLpNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERFILTERLPNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERFILTERLPNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterFilterLpNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ParameterFilterLpNodeVersion {
    #[default]
    ParameterFilterLpNodeVersion_2010_2 = 0,
    ParameterFilterLpNodeVersion_2012_5 = 1,
    ParameterFilterLpNodeVersion_2015_1 = 2,
}

pub static PARAMETERFILTERLPNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PARAMETERFILTERLPNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ParameterFilterLpNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERFILTERLPNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PARAMETERFILTERLPNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterFilterLpNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterFilterLpNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterDelayNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub parameters: Vec<Option<Arc<Mutex<dyn ParameterDelayNodeEntryTrait>>>>,
    pub delay_time: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub max_updates_per_second: u32,
}

pub trait ParameterDelayNodeDataTrait: AudioGraphNodeDataTrait {
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn ParameterDelayNodeEntryTrait>>>>;
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ParameterDelayNodeEntryTrait>>>>;
    fn delay_time(&self) -> &AudioGraphNodePort;
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_delay_time(&self) -> &f32;
    fn max_delay_time_mut(&mut self) -> &mut f32;
    fn max_updates_per_second(&self) -> &u32;
    fn max_updates_per_second_mut(&mut self) -> &mut u32;
}

impl ParameterDelayNodeDataTrait for ParameterDelayNodeData {
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn ParameterDelayNodeEntryTrait>>>> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ParameterDelayNodeEntryTrait>>>> {
        &mut self.parameters
    }
    fn delay_time(&self) -> &AudioGraphNodePort {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay_time
    }
    fn max_delay_time(&self) -> &f32 {
        &self.max_delay_time
    }
    fn max_delay_time_mut(&mut self) -> &mut f32 {
        &mut self.max_delay_time
    }
    fn max_updates_per_second(&self) -> &u32 {
        &self.max_updates_per_second
    }
    fn max_updates_per_second_mut(&mut self) -> &mut u32 {
        &mut self.max_updates_per_second
    }
}

impl AudioGraphNodeDataTrait for ParameterDelayNodeData {
}

impl super::core::DataContainerTrait for ParameterDelayNodeData {
}

pub static PARAMETERDELAYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterDelayNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "ParameterDelayNodeEntry-Array",
                rust_offset: offset_of!(ParameterDelayNodeData, parameters),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterDelayNodeData, delay_time),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParameterDelayNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "MaxUpdatesPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ParameterDelayNodeData, max_updates_per_second),
            },
        ],
    }),
    array_type: Some(PARAMETERDELAYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterDelayNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERDELAYNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERDELAYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterDelayNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterDelayNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub default_value: f32,
}

pub trait ParameterDelayNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
}

impl ParameterDelayNodeEntryTrait for ParameterDelayNodeEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
}

impl AudioGraphNodePortGroupTrait for ParameterDelayNodeEntry {
}

impl super::core::DataContainerTrait for ParameterDelayNodeEntry {
}

pub static PARAMETERDELAYNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterDelayNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterDelayNodeEntry, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ParameterDelayNodeEntry, out),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParameterDelayNodeEntry, default_value),
            },
        ],
    }),
    array_type: Some(PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterDelayNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERDELAYNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERDELAYNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterDelayNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterDelayNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NumberGeneratorNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub min: f32,
    pub max: f32,
}

pub trait NumberGeneratorNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
}

impl NumberGeneratorNodeConfigDataTrait for NumberGeneratorNodeConfigData {
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
}

impl AudioGraphNodeConfigDataTrait for NumberGeneratorNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for NumberGeneratorNodeConfigData {
}

pub static NUMBERGENERATORNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NumberGeneratorNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NumberGeneratorNodeConfigData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(NumberGeneratorNodeConfigData, max),
            },
        ],
    }),
    array_type: Some(NUMBERGENERATORNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NumberGeneratorNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        NUMBERGENERATORNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NUMBERGENERATORNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NumberGeneratorNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub trigger: AudioGraphNodePort,
    pub min: AudioGraphNodePort,
    pub max: AudioGraphNodePort,
    pub mode: NumberGeneratorMode,
    pub y: AudioGraphNodePort,
    pub version: NumberGeneratorNodeVersion,
}

pub trait NumberGeneratorNodeDataTrait: AudioGraphNodeDataTrait {
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min(&self) -> &AudioGraphNodePort;
    fn min_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max(&self) -> &AudioGraphNodePort;
    fn max_mut(&mut self) -> &mut AudioGraphNodePort;
    fn mode(&self) -> &NumberGeneratorMode;
    fn mode_mut(&mut self) -> &mut NumberGeneratorMode;
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn version(&self) -> &NumberGeneratorNodeVersion;
    fn version_mut(&mut self) -> &mut NumberGeneratorNodeVersion;
}

impl NumberGeneratorNodeDataTrait for NumberGeneratorNodeData {
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn min(&self) -> &AudioGraphNodePort {
        &self.min
    }
    fn min_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.min
    }
    fn max(&self) -> &AudioGraphNodePort {
        &self.max
    }
    fn max_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.max
    }
    fn mode(&self) -> &NumberGeneratorMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut NumberGeneratorMode {
        &mut self.mode
    }
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
    fn version(&self) -> &NumberGeneratorNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut NumberGeneratorNodeVersion {
        &mut self.version
    }
}

impl AudioGraphNodeDataTrait for NumberGeneratorNodeData {
}

impl super::core::DataContainerTrait for NumberGeneratorNodeData {
}

pub static NUMBERGENERATORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NumberGeneratorNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(NumberGeneratorNodeData, trigger),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(NumberGeneratorNodeData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(NumberGeneratorNodeData, max),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "NumberGeneratorMode",
                rust_offset: offset_of!(NumberGeneratorNodeData, mode),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(NumberGeneratorNodeData, y),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "NumberGeneratorNodeVersion",
                rust_offset: offset_of!(NumberGeneratorNodeData, version),
            },
        ],
    }),
    array_type: Some(NUMBERGENERATORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NumberGeneratorNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        NUMBERGENERATORNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NUMBERGENERATORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum NumberGeneratorMode {
    #[default]
    NumberGeneratorMode_RandomUniform = 0,
}

pub static NUMBERGENERATORMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(NUMBERGENERATORMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for NumberGeneratorMode {
    fn type_info(&self) -> &'static TypeInfo {
        NUMBERGENERATORMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NUMBERGENERATORMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum NumberGeneratorNodeVersion {
    #[default]
    NumberGeneratorNodeVersion_2010_2 = 0,
    NumberGeneratorNodeVersion_2013_1 = 1,
}

pub static NUMBERGENERATORNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(NUMBERGENERATORNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for NumberGeneratorNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        NUMBERGENERATORNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static NUMBERGENERATORNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NumberGeneratorNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NumberGeneratorNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultiCrossfaderNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub crossfader_config_groups: Vec<MultiCrossfaderConfigGroup>,
}

pub trait MultiCrossfaderNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn crossfader_config_groups(&self) -> &Vec<MultiCrossfaderConfigGroup>;
    fn crossfader_config_groups_mut(&mut self) -> &mut Vec<MultiCrossfaderConfigGroup>;
}

impl MultiCrossfaderNodeConfigDataTrait for MultiCrossfaderNodeConfigData {
    fn crossfader_config_groups(&self) -> &Vec<MultiCrossfaderConfigGroup> {
        &self.crossfader_config_groups
    }
    fn crossfader_config_groups_mut(&mut self) -> &mut Vec<MultiCrossfaderConfigGroup> {
        &mut self.crossfader_config_groups
    }
}

impl AudioGraphNodeConfigDataTrait for MultiCrossfaderNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for MultiCrossfaderNodeConfigData {
}

pub static MULTICROSSFADERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiCrossfaderNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CrossfaderConfigGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "MultiCrossfaderConfigGroup-Array",
                rust_offset: offset_of!(MultiCrossfaderNodeConfigData, crossfader_config_groups),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiCrossfaderNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTICROSSFADERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTICROSSFADERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultiCrossfaderConfigGroup {
    pub fade_amplitude: f32,
    pub fade_begin: f32,
    pub fade_end: f32,
    pub fade_type: FaderType,
}

pub trait MultiCrossfaderConfigGroupTrait: TypeObject {
    fn fade_amplitude(&self) -> &f32;
    fn fade_amplitude_mut(&mut self) -> &mut f32;
    fn fade_begin(&self) -> &f32;
    fn fade_begin_mut(&mut self) -> &mut f32;
    fn fade_end(&self) -> &f32;
    fn fade_end_mut(&mut self) -> &mut f32;
    fn fade_type(&self) -> &FaderType;
    fn fade_type_mut(&mut self) -> &mut FaderType;
}

impl MultiCrossfaderConfigGroupTrait for MultiCrossfaderConfigGroup {
    fn fade_amplitude(&self) -> &f32 {
        &self.fade_amplitude
    }
    fn fade_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.fade_amplitude
    }
    fn fade_begin(&self) -> &f32 {
        &self.fade_begin
    }
    fn fade_begin_mut(&mut self) -> &mut f32 {
        &mut self.fade_begin
    }
    fn fade_end(&self) -> &f32 {
        &self.fade_end
    }
    fn fade_end_mut(&mut self) -> &mut f32 {
        &mut self.fade_end
    }
    fn fade_type(&self) -> &FaderType {
        &self.fade_type
    }
    fn fade_type_mut(&mut self) -> &mut FaderType {
        &mut self.fade_type
    }
}

pub static MULTICROSSFADERCONFIGGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderConfigGroup",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiCrossfaderConfigGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FadeAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_amplitude),
            },
            FieldInfoData {
                name: "FadeBegin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_begin),
            },
            FieldInfoData {
                name: "FadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_end),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: "FaderType",
                rust_offset: offset_of!(MultiCrossfaderConfigGroup, fade_type),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for MultiCrossfaderConfigGroup {
    fn type_info(&self) -> &'static TypeInfo {
        MULTICROSSFADERCONFIGGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MULTICROSSFADERCONFIGGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderConfigGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderConfigGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultiCrossfaderNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub crossfader_groups: Vec<Option<Arc<Mutex<dyn MultiCrossfaderGroupTrait>>>>,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub control: AudioGraphNodePort,
    pub lock_control_value: bool,
}

pub trait MultiCrossfaderNodeDataTrait: AudioGraphNodeDataTrait {
    fn crossfader_groups(&self) -> &Vec<Option<Arc<Mutex<dyn MultiCrossfaderGroupTrait>>>>;
    fn crossfader_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MultiCrossfaderGroupTrait>>>>;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn control(&self) -> &AudioGraphNodePort;
    fn control_mut(&mut self) -> &mut AudioGraphNodePort;
    fn lock_control_value(&self) -> &bool;
    fn lock_control_value_mut(&mut self) -> &mut bool;
}

impl MultiCrossfaderNodeDataTrait for MultiCrossfaderNodeData {
    fn crossfader_groups(&self) -> &Vec<Option<Arc<Mutex<dyn MultiCrossfaderGroupTrait>>>> {
        &self.crossfader_groups
    }
    fn crossfader_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MultiCrossfaderGroupTrait>>>> {
        &mut self.crossfader_groups
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn control(&self) -> &AudioGraphNodePort {
        &self.control
    }
    fn control_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.control
    }
    fn lock_control_value(&self) -> &bool {
        &self.lock_control_value
    }
    fn lock_control_value_mut(&mut self) -> &mut bool {
        &mut self.lock_control_value
    }
}

impl AudioGraphNodeDataTrait for MultiCrossfaderNodeData {
}

impl super::core::DataContainerTrait for MultiCrossfaderNodeData {
}

pub static MULTICROSSFADERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiCrossfaderNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CrossfaderGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "MultiCrossfaderGroup-Array",
                rust_offset: offset_of!(MultiCrossfaderNodeData, crossfader_groups),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultiCrossfaderNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultiCrossfaderNodeData, stop),
            },
            FieldInfoData {
                name: "Control",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultiCrossfaderNodeData, control),
            },
            FieldInfoData {
                name: "LockControlValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MultiCrossfaderNodeData, lock_control_value),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiCrossfaderNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTICROSSFADERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTICROSSFADERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultiCrossfaderGroup {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub amplitude: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub fade_amplitude: f32,
    pub fade_begin: f32,
    pub fade_end: f32,
    pub fade_type: FaderType,
}

pub trait MultiCrossfaderGroupTrait: AudioGraphNodePortGroupTrait {
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn fade_amplitude(&self) -> &f32;
    fn fade_amplitude_mut(&mut self) -> &mut f32;
    fn fade_begin(&self) -> &f32;
    fn fade_begin_mut(&mut self) -> &mut f32;
    fn fade_end(&self) -> &f32;
    fn fade_end_mut(&mut self) -> &mut f32;
    fn fade_type(&self) -> &FaderType;
    fn fade_type_mut(&mut self) -> &mut FaderType;
}

impl MultiCrossfaderGroupTrait for MultiCrossfaderGroup {
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn fade_amplitude(&self) -> &f32 {
        &self.fade_amplitude
    }
    fn fade_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.fade_amplitude
    }
    fn fade_begin(&self) -> &f32 {
        &self.fade_begin
    }
    fn fade_begin_mut(&mut self) -> &mut f32 {
        &mut self.fade_begin
    }
    fn fade_end(&self) -> &f32 {
        &self.fade_end
    }
    fn fade_end_mut(&mut self) -> &mut f32 {
        &mut self.fade_end
    }
    fn fade_type(&self) -> &FaderType {
        &self.fade_type
    }
    fn fade_type_mut(&mut self) -> &mut FaderType {
        &mut self.fade_type
    }
}

impl AudioGraphNodePortGroupTrait for MultiCrossfaderGroup {
}

impl super::core::DataContainerTrait for MultiCrossfaderGroup {
}

pub static MULTICROSSFADERGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultiCrossfaderGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultiCrossfaderGroup, amplitude),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultiCrossfaderGroup, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MultiCrossfaderGroup, stop),
            },
            FieldInfoData {
                name: "FadeAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_amplitude),
            },
            FieldInfoData {
                name: "FadeBegin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_begin),
            },
            FieldInfoData {
                name: "FadeEnd",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_end),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: "FaderType",
                rust_offset: offset_of!(MultiCrossfaderGroup, fade_type),
            },
        ],
    }),
    array_type: Some(MULTICROSSFADERGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultiCrossfaderGroup {
    fn type_info(&self) -> &'static TypeInfo {
        MULTICROSSFADERGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTICROSSFADERGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultiCrossfaderGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultiCrossfaderGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FaderType {
    #[default]
    FaderType_Linear = 0,
    FaderType_Cosine = 1,
}

pub static FADERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaderType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FADERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FaderType {
    fn type_info(&self) -> &'static TypeInfo {
        FADERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FADERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FaderType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FaderType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MinMaxValueSelectorNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub inputs: Vec<Option<Arc<Mutex<dyn MinMaxValueSelectorEntryTrait>>>>,
    pub max_value: AudioGraphNodePort,
    pub max_index: AudioGraphNodePort,
    pub min_value: AudioGraphNodePort,
    pub min_index: AudioGraphNodePort,
}

pub trait MinMaxValueSelectorNodeDataTrait: AudioGraphNodeDataTrait {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn MinMaxValueSelectorEntryTrait>>>>;
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MinMaxValueSelectorEntryTrait>>>>;
    fn max_value(&self) -> &AudioGraphNodePort;
    fn max_value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_index(&self) -> &AudioGraphNodePort;
    fn max_index_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min_value(&self) -> &AudioGraphNodePort;
    fn min_value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min_index(&self) -> &AudioGraphNodePort;
    fn min_index_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MinMaxValueSelectorNodeDataTrait for MinMaxValueSelectorNodeData {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn MinMaxValueSelectorEntryTrait>>>> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MinMaxValueSelectorEntryTrait>>>> {
        &mut self.inputs
    }
    fn max_value(&self) -> &AudioGraphNodePort {
        &self.max_value
    }
    fn max_value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.max_value
    }
    fn max_index(&self) -> &AudioGraphNodePort {
        &self.max_index
    }
    fn max_index_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.max_index
    }
    fn min_value(&self) -> &AudioGraphNodePort {
        &self.min_value
    }
    fn min_value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.min_value
    }
    fn min_index(&self) -> &AudioGraphNodePort {
        &self.min_index
    }
    fn min_index_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.min_index
    }
}

impl AudioGraphNodeDataTrait for MinMaxValueSelectorNodeData {
}

impl super::core::DataContainerTrait for MinMaxValueSelectorNodeData {
}

pub static MINMAXVALUESELECTORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MinMaxValueSelectorNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "MinMaxValueSelectorEntry-Array",
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, inputs),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, max_value),
            },
            FieldInfoData {
                name: "MaxIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, max_index),
            },
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, min_value),
            },
            FieldInfoData {
                name: "MinIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxValueSelectorNodeData, min_index),
            },
        ],
    }),
    array_type: Some(MINMAXVALUESELECTORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MinMaxValueSelectorNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MINMAXVALUESELECTORNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MINMAXVALUESELECTORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MinMaxValueSelectorNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MinMaxValueSelectorEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub input: AudioGraphNodePort,
}

pub trait MinMaxValueSelectorEntryTrait: AudioGraphNodePortGroupTrait {
    fn input(&self) -> &AudioGraphNodePort;
    fn input_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MinMaxValueSelectorEntryTrait for MinMaxValueSelectorEntry {
    fn input(&self) -> &AudioGraphNodePort {
        &self.input
    }
    fn input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.input
    }
}

impl AudioGraphNodePortGroupTrait for MinMaxValueSelectorEntry {
}

impl super::core::DataContainerTrait for MinMaxValueSelectorEntry {
}

pub static MINMAXVALUESELECTORENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MinMaxValueSelectorEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxValueSelectorEntry, input),
            },
        ],
    }),
    array_type: Some(MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MinMaxValueSelectorEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MINMAXVALUESELECTORENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MINMAXVALUESELECTORENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxValueSelectorEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MinMaxValueSelectorEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MinMaxNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub max: AudioGraphNodePort,
    pub min: AudioGraphNodePort,
}

pub trait MinMaxNodeDataTrait: AudioGraphNodeDataTrait {
    fn x(&self) -> &AudioGraphNodePort;
    fn x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max(&self) -> &AudioGraphNodePort;
    fn max_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min(&self) -> &AudioGraphNodePort;
    fn min_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MinMaxNodeDataTrait for MinMaxNodeData {
    fn x(&self) -> &AudioGraphNodePort {
        &self.x
    }
    fn x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.x
    }
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
    fn max(&self) -> &AudioGraphNodePort {
        &self.max
    }
    fn max_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.max
    }
    fn min(&self) -> &AudioGraphNodePort {
        &self.min
    }
    fn min_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.min
    }
}

impl AudioGraphNodeDataTrait for MinMaxNodeData {
}

impl super::core::DataContainerTrait for MinMaxNodeData {
}

pub static MINMAXNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MinMaxNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxNodeData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxNodeData, y),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxNodeData, max),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MinMaxNodeData, min),
            },
        ],
    }),
    array_type: Some(MINMAXNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MinMaxNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MINMAXNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MINMAXNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MinMaxNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MinMaxNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicalExpressionNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub reset: AudioGraphNodePort,
    pub inputs: Vec<Option<Arc<Mutex<dyn LogicalExpressionEntryTrait>>>>,
    pub trigger: AudioGraphNodePort,
    pub operator: LogicalExpressionOperator,
}

pub trait LogicalExpressionNodeDataTrait: AudioGraphNodeDataTrait {
    fn reset(&self) -> &AudioGraphNodePort;
    fn reset_mut(&mut self) -> &mut AudioGraphNodePort;
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn LogicalExpressionEntryTrait>>>>;
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LogicalExpressionEntryTrait>>>>;
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn operator(&self) -> &LogicalExpressionOperator;
    fn operator_mut(&mut self) -> &mut LogicalExpressionOperator;
}

impl LogicalExpressionNodeDataTrait for LogicalExpressionNodeData {
    fn reset(&self) -> &AudioGraphNodePort {
        &self.reset
    }
    fn reset_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reset
    }
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn LogicalExpressionEntryTrait>>>> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LogicalExpressionEntryTrait>>>> {
        &mut self.inputs
    }
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn operator(&self) -> &LogicalExpressionOperator {
        &self.operator
    }
    fn operator_mut(&mut self) -> &mut LogicalExpressionOperator {
        &mut self.operator
    }
}

impl AudioGraphNodeDataTrait for LogicalExpressionNodeData {
}

impl super::core::DataContainerTrait for LogicalExpressionNodeData {
}

pub static LOGICALEXPRESSIONNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicalExpressionNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Reset",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LogicalExpressionNodeData, reset),
            },
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "LogicalExpressionEntry-Array",
                rust_offset: offset_of!(LogicalExpressionNodeData, inputs),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LogicalExpressionNodeData, trigger),
            },
            FieldInfoData {
                name: "Operator",
                flags: MemberInfoFlags::new(0),
                field_type: "LogicalExpressionOperator",
                rust_offset: offset_of!(LogicalExpressionNodeData, operator),
            },
        ],
    }),
    array_type: Some(LOGICALEXPRESSIONNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicalExpressionNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICALEXPRESSIONNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICALEXPRESSIONNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicalExpressionNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum LogicalExpressionOperator {
    #[default]
    LogicalExpressionOperator_And = 0,
    LogicalExpressionOperator_Or = 1,
    LogicalExpressionOperator_Nand = 2,
    LogicalExpressionOperator_Nor = 3,
    LogicalExpressionOperator_And2 = 4,
}

pub static LOGICALEXPRESSIONOPERATOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionOperator",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LOGICALEXPRESSIONOPERATOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LogicalExpressionOperator {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICALEXPRESSIONOPERATOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LOGICALEXPRESSIONOPERATOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionOperator-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicalExpressionOperator"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LogicalExpressionEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub trigger: AudioGraphNodePort,
}

pub trait LogicalExpressionEntryTrait: AudioGraphNodePortGroupTrait {
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl LogicalExpressionEntryTrait for LogicalExpressionEntry {
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
}

impl AudioGraphNodePortGroupTrait for LogicalExpressionEntry {
}

impl super::core::DataContainerTrait for LogicalExpressionEntry {
}

pub static LOGICALEXPRESSIONENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LogicalExpressionEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LogicalExpressionEntry, trigger),
            },
        ],
    }),
    array_type: Some(LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LogicalExpressionEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LOGICALEXPRESSIONENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOGICALEXPRESSIONENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LogicalExpressionEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LogicalExpressionEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendAudioNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub audio_entries: Vec<Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>>,
}

pub trait LinkSendAudioNodeDataTrait: AudioGraphNodeDataTrait {
    fn audio_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>>;
    fn audio_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>>;
}

impl LinkSendAudioNodeDataTrait for LinkSendAudioNodeData {
    fn audio_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>> {
        &self.audio_entries
    }
    fn audio_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>> {
        &mut self.audio_entries
    }
}

impl AudioGraphNodeDataTrait for LinkSendAudioNodeData {
}

impl super::core::DataContainerTrait for LinkSendAudioNodeData {
}

pub static LINKSENDAUDIONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendAudioNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AudioEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkSendAudioNodeEntry-Array",
                rust_offset: offset_of!(LinkSendAudioNodeData, audio_entries),
            },
        ],
    }),
    array_type: Some(LINKSENDAUDIONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAudioNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDAUDIONODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDAUDIONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAudioNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendAudioNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub input: AudioGraphNodePort,
    pub send_audio_name: String,
}

pub trait LinkSendAudioNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn input(&self) -> &AudioGraphNodePort;
    fn input_mut(&mut self) -> &mut AudioGraphNodePort;
    fn send_audio_name(&self) -> &String;
    fn send_audio_name_mut(&mut self) -> &mut String;
}

impl LinkSendAudioNodeEntryTrait for LinkSendAudioNodeEntry {
    fn input(&self) -> &AudioGraphNodePort {
        &self.input
    }
    fn input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.input
    }
    fn send_audio_name(&self) -> &String {
        &self.send_audio_name
    }
    fn send_audio_name_mut(&mut self) -> &mut String {
        &mut self.send_audio_name
    }
}

impl AudioGraphNodePortGroupTrait for LinkSendAudioNodeEntry {
}

impl super::core::DataContainerTrait for LinkSendAudioNodeEntry {
}

pub static LINKSENDAUDIONODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendAudioNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkSendAudioNodeEntry, input),
            },
            FieldInfoData {
                name: "SendAudioName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LinkSendAudioNodeEntry, send_audio_name),
            },
        ],
    }),
    array_type: Some(LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAudioNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDAUDIONODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDAUDIONODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAudioNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAudioNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveAudioNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub audio_entries: Vec<Option<Arc<Mutex<dyn LinkReceiveAudioNodeEntryTrait>>>>,
}

pub trait LinkReceiveAudioNodeDataTrait: AudioGraphNodeDataTrait {
    fn audio_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveAudioNodeEntryTrait>>>>;
    fn audio_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveAudioNodeEntryTrait>>>>;
}

impl LinkReceiveAudioNodeDataTrait for LinkReceiveAudioNodeData {
    fn audio_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveAudioNodeEntryTrait>>>> {
        &self.audio_entries
    }
    fn audio_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveAudioNodeEntryTrait>>>> {
        &mut self.audio_entries
    }
}

impl AudioGraphNodeDataTrait for LinkReceiveAudioNodeData {
}

impl super::core::DataContainerTrait for LinkReceiveAudioNodeData {
}

pub static LINKRECEIVEAUDIONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveAudioNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AudioEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkReceiveAudioNodeEntry-Array",
                rust_offset: offset_of!(LinkReceiveAudioNodeData, audio_entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEAUDIONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAudioNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVEAUDIONODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVEAUDIONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAudioNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveAudioNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub output: AudioGraphNodePort,
    pub audio_sender: Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>,
}

pub trait LinkReceiveAudioNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn audio_sender(&self) -> &Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>;
    fn audio_sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>>;
}

impl LinkReceiveAudioNodeEntryTrait for LinkReceiveAudioNodeEntry {
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn audio_sender(&self) -> &Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>> {
        &self.audio_sender
    }
    fn audio_sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendAudioNodeEntryTrait>>> {
        &mut self.audio_sender
    }
}

impl AudioGraphNodePortGroupTrait for LinkReceiveAudioNodeEntry {
}

impl super::core::DataContainerTrait for LinkReceiveAudioNodeEntry {
}

pub static LINKRECEIVEAUDIONODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveAudioNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkReceiveAudioNodeEntry, output),
            },
            FieldInfoData {
                name: "AudioSender",
                flags: MemberInfoFlags::new(0),
                field_type: "LinkSendAudioNodeEntry",
                rust_offset: offset_of!(LinkReceiveAudioNodeEntry, audio_sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAudioNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVEAUDIONODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVEAUDIONODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAudioNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAudioNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendAssetNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub asset_entries: Vec<Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>>,
}

pub trait LinkSendAssetNodeDataTrait: AudioGraphNodeDataTrait {
    fn asset_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>>;
    fn asset_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>>;
}

impl LinkSendAssetNodeDataTrait for LinkSendAssetNodeData {
    fn asset_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>> {
        &self.asset_entries
    }
    fn asset_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>> {
        &mut self.asset_entries
    }
}

impl AudioGraphNodeDataTrait for LinkSendAssetNodeData {
}

impl super::core::DataContainerTrait for LinkSendAssetNodeData {
}

pub static LINKSENDASSETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendAssetNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AssetEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkSendAssetNodeEntry-Array",
                rust_offset: offset_of!(LinkSendAssetNodeData, asset_entries),
            },
        ],
    }),
    array_type: Some(LINKSENDASSETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAssetNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDASSETNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDASSETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAssetNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendAssetNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub input: AudioGraphNodePort,
    pub send_asset_name: String,
}

pub trait LinkSendAssetNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn input(&self) -> &AudioGraphNodePort;
    fn input_mut(&mut self) -> &mut AudioGraphNodePort;
    fn send_asset_name(&self) -> &String;
    fn send_asset_name_mut(&mut self) -> &mut String;
}

impl LinkSendAssetNodeEntryTrait for LinkSendAssetNodeEntry {
    fn input(&self) -> &AudioGraphNodePort {
        &self.input
    }
    fn input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.input
    }
    fn send_asset_name(&self) -> &String {
        &self.send_asset_name
    }
    fn send_asset_name_mut(&mut self) -> &mut String {
        &mut self.send_asset_name
    }
}

impl AudioGraphNodePortGroupTrait for LinkSendAssetNodeEntry {
}

impl super::core::DataContainerTrait for LinkSendAssetNodeEntry {
}

pub static LINKSENDASSETNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendAssetNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkSendAssetNodeEntry, input),
            },
            FieldInfoData {
                name: "SendAssetName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LinkSendAssetNodeEntry, send_asset_name),
            },
        ],
    }),
    array_type: Some(LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendAssetNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDASSETNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDASSETNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendAssetNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendAssetNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveAssetNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub asset_entries: Vec<Option<Arc<Mutex<dyn LinkReceiveAssetNodeEntryTrait>>>>,
}

pub trait LinkReceiveAssetNodeDataTrait: AudioGraphNodeDataTrait {
    fn asset_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveAssetNodeEntryTrait>>>>;
    fn asset_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveAssetNodeEntryTrait>>>>;
}

impl LinkReceiveAssetNodeDataTrait for LinkReceiveAssetNodeData {
    fn asset_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveAssetNodeEntryTrait>>>> {
        &self.asset_entries
    }
    fn asset_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveAssetNodeEntryTrait>>>> {
        &mut self.asset_entries
    }
}

impl AudioGraphNodeDataTrait for LinkReceiveAssetNodeData {
}

impl super::core::DataContainerTrait for LinkReceiveAssetNodeData {
}

pub static LINKRECEIVEASSETNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveAssetNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "AssetEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkReceiveAssetNodeEntry-Array",
                rust_offset: offset_of!(LinkReceiveAssetNodeData, asset_entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEASSETNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAssetNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVEASSETNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVEASSETNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAssetNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveAssetNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub output: AudioGraphNodePort,
    pub asset_sender: Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>,
}

pub trait LinkReceiveAssetNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn asset_sender(&self) -> &Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>;
    fn asset_sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>>;
}

impl LinkReceiveAssetNodeEntryTrait for LinkReceiveAssetNodeEntry {
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn asset_sender(&self) -> &Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>> {
        &self.asset_sender
    }
    fn asset_sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendAssetNodeEntryTrait>>> {
        &mut self.asset_sender
    }
}

impl AudioGraphNodePortGroupTrait for LinkReceiveAssetNodeEntry {
}

impl super::core::DataContainerTrait for LinkReceiveAssetNodeEntry {
}

pub static LINKRECEIVEASSETNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveAssetNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkReceiveAssetNodeEntry, output),
            },
            FieldInfoData {
                name: "AssetSender",
                flags: MemberInfoFlags::new(0),
                field_type: "LinkSendAssetNodeEntry",
                rust_offset: offset_of!(LinkReceiveAssetNodeEntry, asset_sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveAssetNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVEASSETNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVEASSETNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveAssetNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveAssetNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendEventNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub event_entries: Vec<Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>>,
}

pub trait LinkSendEventNodeDataTrait: AudioGraphNodeDataTrait {
    fn event_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>>;
    fn event_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>>;
}

impl LinkSendEventNodeDataTrait for LinkSendEventNodeData {
    fn event_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>> {
        &self.event_entries
    }
    fn event_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>> {
        &mut self.event_entries
    }
}

impl AudioGraphNodeDataTrait for LinkSendEventNodeData {
}

impl super::core::DataContainerTrait for LinkSendEventNodeData {
}

pub static LINKSENDEVENTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendEventNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EventEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkSendEventNodeEntry-Array",
                rust_offset: offset_of!(LinkSendEventNodeData, event_entries),
            },
        ],
    }),
    array_type: Some(LINKSENDEVENTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendEventNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDEVENTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDEVENTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendEventNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendEventNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub input: AudioGraphNodePort,
    pub send_event_name: String,
}

pub trait LinkSendEventNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn input(&self) -> &AudioGraphNodePort;
    fn input_mut(&mut self) -> &mut AudioGraphNodePort;
    fn send_event_name(&self) -> &String;
    fn send_event_name_mut(&mut self) -> &mut String;
}

impl LinkSendEventNodeEntryTrait for LinkSendEventNodeEntry {
    fn input(&self) -> &AudioGraphNodePort {
        &self.input
    }
    fn input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.input
    }
    fn send_event_name(&self) -> &String {
        &self.send_event_name
    }
    fn send_event_name_mut(&mut self) -> &mut String {
        &mut self.send_event_name
    }
}

impl AudioGraphNodePortGroupTrait for LinkSendEventNodeEntry {
}

impl super::core::DataContainerTrait for LinkSendEventNodeEntry {
}

pub static LINKSENDEVENTNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendEventNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkSendEventNodeEntry, input),
            },
            FieldInfoData {
                name: "SendEventName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LinkSendEventNodeEntry, send_event_name),
            },
        ],
    }),
    array_type: Some(LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendEventNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDEVENTNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDEVENTNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendEventNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendEventNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveEventNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub event_entries: Vec<Option<Arc<Mutex<dyn LinkReceiveEventNodeEntryTrait>>>>,
}

pub trait LinkReceiveEventNodeDataTrait: AudioGraphNodeDataTrait {
    fn event_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveEventNodeEntryTrait>>>>;
    fn event_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveEventNodeEntryTrait>>>>;
}

impl LinkReceiveEventNodeDataTrait for LinkReceiveEventNodeData {
    fn event_entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveEventNodeEntryTrait>>>> {
        &self.event_entries
    }
    fn event_entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveEventNodeEntryTrait>>>> {
        &mut self.event_entries
    }
}

impl AudioGraphNodeDataTrait for LinkReceiveEventNodeData {
}

impl super::core::DataContainerTrait for LinkReceiveEventNodeData {
}

pub static LINKRECEIVEEVENTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveEventNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EventEntries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkReceiveEventNodeEntry-Array",
                rust_offset: offset_of!(LinkReceiveEventNodeData, event_entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEEVENTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveEventNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVEEVENTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVEEVENTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveEventNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveEventNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub output: AudioGraphNodePort,
    pub event_sender: Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>,
}

pub trait LinkReceiveEventNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn event_sender(&self) -> &Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>;
    fn event_sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>>;
}

impl LinkReceiveEventNodeEntryTrait for LinkReceiveEventNodeEntry {
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn event_sender(&self) -> &Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>> {
        &self.event_sender
    }
    fn event_sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendEventNodeEntryTrait>>> {
        &mut self.event_sender
    }
}

impl AudioGraphNodePortGroupTrait for LinkReceiveEventNodeEntry {
}

impl super::core::DataContainerTrait for LinkReceiveEventNodeEntry {
}

pub static LINKRECEIVEEVENTNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveEventNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkReceiveEventNodeEntry, output),
            },
            FieldInfoData {
                name: "EventSender",
                flags: MemberInfoFlags::new(0),
                field_type: "LinkSendEventNodeEntry",
                rust_offset: offset_of!(LinkReceiveEventNodeEntry, event_sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveEventNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVEEVENTNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVEEVENTNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveEventNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveEventNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>>,
}

pub trait LinkSendNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>>;
}

impl LinkSendNodeDataTrait for LinkSendNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for LinkSendNodeData {
}

impl super::core::DataContainerTrait for LinkSendNodeData {
}

pub static LINKSENDNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkSendNodeEntry-Array",
                rust_offset: offset_of!(LinkSendNodeData, entries),
            },
        ],
    }),
    array_type: Some(LINKSENDNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkSendNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub input: AudioGraphNodePort,
    pub send_name: String,
}

pub trait LinkSendNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn input(&self) -> &AudioGraphNodePort;
    fn input_mut(&mut self) -> &mut AudioGraphNodePort;
    fn send_name(&self) -> &String;
    fn send_name_mut(&mut self) -> &mut String;
}

impl LinkSendNodeEntryTrait for LinkSendNodeEntry {
    fn input(&self) -> &AudioGraphNodePort {
        &self.input
    }
    fn input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.input
    }
    fn send_name(&self) -> &String {
        &self.send_name
    }
    fn send_name_mut(&mut self) -> &mut String {
        &mut self.send_name
    }
}

impl AudioGraphNodePortGroupTrait for LinkSendNodeEntry {
}

impl super::core::DataContainerTrait for LinkSendNodeEntry {
}

pub static LINKSENDNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkSendNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Input",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkSendNodeEntry, input),
            },
            FieldInfoData {
                name: "SendName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LinkSendNodeEntry, send_name),
            },
        ],
    }),
    array_type: Some(LINKSENDNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkSendNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKSENDNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKSENDNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkSendNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkSendNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn LinkReceiveNodeEntryTrait>>>>,
}

pub trait LinkReceiveNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveNodeEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveNodeEntryTrait>>>>;
}

impl LinkReceiveNodeDataTrait for LinkReceiveNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn LinkReceiveNodeEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn LinkReceiveNodeEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for LinkReceiveNodeData {
}

impl super::core::DataContainerTrait for LinkReceiveNodeData {
}

pub static LINKRECEIVENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "LinkReceiveNodeEntry-Array",
                rust_offset: offset_of!(LinkReceiveNodeData, entries),
            },
        ],
    }),
    array_type: Some(LINKRECEIVENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinkReceiveNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub output: AudioGraphNodePort,
    pub sender: Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>,
}

pub trait LinkReceiveNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn sender(&self) -> &Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>;
    fn sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>>;
}

impl LinkReceiveNodeEntryTrait for LinkReceiveNodeEntry {
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn sender(&self) -> &Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>> {
        &self.sender
    }
    fn sender_mut(&mut self) -> &mut Option<Arc<Mutex<dyn LinkSendNodeEntryTrait>>> {
        &mut self.sender
    }
}

impl AudioGraphNodePortGroupTrait for LinkReceiveNodeEntry {
}

impl super::core::DataContainerTrait for LinkReceiveNodeEntry {
}

pub static LINKRECEIVENODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinkReceiveNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinkReceiveNodeEntry, output),
            },
            FieldInfoData {
                name: "Sender",
                flags: MemberInfoFlags::new(0),
                field_type: "LinkSendNodeEntry",
                rust_offset: offset_of!(LinkReceiveNodeEntry, sender),
            },
        ],
    }),
    array_type: Some(LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinkReceiveNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        LINKRECEIVENODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINKRECEIVENODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinkReceiveNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinkReceiveNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LinearTransformNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub x: AudioGraphNodePort,
    pub k: AudioGraphNodePort,
    pub m: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
}

pub trait LinearTransformNodeDataTrait: AudioGraphNodeDataTrait {
    fn x(&self) -> &AudioGraphNodePort;
    fn x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn k(&self) -> &AudioGraphNodePort;
    fn k_mut(&mut self) -> &mut AudioGraphNodePort;
    fn m(&self) -> &AudioGraphNodePort;
    fn m_mut(&mut self) -> &mut AudioGraphNodePort;
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl LinearTransformNodeDataTrait for LinearTransformNodeData {
    fn x(&self) -> &AudioGraphNodePort {
        &self.x
    }
    fn x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.x
    }
    fn k(&self) -> &AudioGraphNodePort {
        &self.k
    }
    fn k_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.k
    }
    fn m(&self) -> &AudioGraphNodePort {
        &self.m
    }
    fn m_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.m
    }
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
}

impl AudioGraphNodeDataTrait for LinearTransformNodeData {
}

impl super::core::DataContainerTrait for LinearTransformNodeData {
}

pub static LINEARTRANSFORMNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTransformNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LinearTransformNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinearTransformNodeData, x),
            },
            FieldInfoData {
                name: "K",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinearTransformNodeData, k),
            },
            FieldInfoData {
                name: "M",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinearTransformNodeData, m),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LinearTransformNodeData, y),
            },
        ],
    }),
    array_type: Some(LINEARTRANSFORMNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LinearTransformNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LINEARTRANSFORMNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LINEARTRANSFORMNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LinearTransformNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LinearTransformNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LfoNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub hz: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub min: f32,
    pub max: f32,
    pub start_at_random_value: bool,
}

pub trait LfoNodeDataTrait: AudioGraphNodeDataTrait {
    fn hz(&self) -> &AudioGraphNodePort;
    fn hz_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
    fn start_at_random_value(&self) -> &bool;
    fn start_at_random_value_mut(&mut self) -> &mut bool;
}

impl LfoNodeDataTrait for LfoNodeData {
    fn hz(&self) -> &AudioGraphNodePort {
        &self.hz
    }
    fn hz_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.hz
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
    fn start_at_random_value(&self) -> &bool {
        &self.start_at_random_value
    }
    fn start_at_random_value_mut(&mut self) -> &mut bool {
        &mut self.start_at_random_value
    }
}

impl AudioGraphNodeDataTrait for LfoNodeData {
}

impl super::core::DataContainerTrait for LfoNodeData {
}

pub static LFONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LfoNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LfoNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Hz",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LfoNodeData, hz),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LfoNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LfoNodeData, out),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LfoNodeData, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(LfoNodeData, max),
            },
            FieldInfoData {
                name: "StartAtRandomValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LfoNodeData, start_at_random_value),
            },
        ],
    }),
    array_type: Some(LFONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LfoNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LFONODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LFONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LfoNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LfoNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FollowEnvelopeNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub base: f32,
    pub scale: f32,
    pub pivot: f32,
}

pub trait FollowEnvelopeNodeDataTrait: AudioGraphNodeDataTrait {
    fn x(&self) -> &AudioGraphNodePort;
    fn x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn base(&self) -> &f32;
    fn base_mut(&mut self) -> &mut f32;
    fn scale(&self) -> &f32;
    fn scale_mut(&mut self) -> &mut f32;
    fn pivot(&self) -> &f32;
    fn pivot_mut(&mut self) -> &mut f32;
}

impl FollowEnvelopeNodeDataTrait for FollowEnvelopeNodeData {
    fn x(&self) -> &AudioGraphNodePort {
        &self.x
    }
    fn x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.x
    }
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
    fn base(&self) -> &f32 {
        &self.base
    }
    fn base_mut(&mut self) -> &mut f32 {
        &mut self.base
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut f32 {
        &mut self.scale
    }
    fn pivot(&self) -> &f32 {
        &self.pivot
    }
    fn pivot_mut(&mut self) -> &mut f32 {
        &mut self.pivot
    }
}

impl AudioGraphNodeDataTrait for FollowEnvelopeNodeData {
}

impl super::core::DataContainerTrait for FollowEnvelopeNodeData {
}

pub static FOLLOWENVELOPENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowEnvelopeNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FollowEnvelopeNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FollowEnvelopeNodeData, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FollowEnvelopeNodeData, y),
            },
            FieldInfoData {
                name: "Base",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowEnvelopeNodeData, base),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowEnvelopeNodeData, scale),
            },
            FieldInfoData {
                name: "Pivot",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FollowEnvelopeNodeData, pivot),
            },
        ],
    }),
    array_type: Some(FOLLOWENVELOPENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FollowEnvelopeNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        FOLLOWENVELOPENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FOLLOWENVELOPENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FollowEnvelopeNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FollowEnvelopeNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSwitcherNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub inputs: Vec<Option<Arc<Mutex<dyn EventSwitcherEntryTrait>>>>,
    pub triggered: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub default_value: f32,
}

pub trait EventSwitcherNodeDataTrait: AudioGraphNodeDataTrait {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn EventSwitcherEntryTrait>>>>;
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn EventSwitcherEntryTrait>>>>;
    fn triggered(&self) -> &AudioGraphNodePort;
    fn triggered_mut(&mut self) -> &mut AudioGraphNodePort;
    fn value(&self) -> &AudioGraphNodePort;
    fn value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
}

impl EventSwitcherNodeDataTrait for EventSwitcherNodeData {
    fn inputs(&self) -> &Vec<Option<Arc<Mutex<dyn EventSwitcherEntryTrait>>>> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn EventSwitcherEntryTrait>>>> {
        &mut self.inputs
    }
    fn triggered(&self) -> &AudioGraphNodePort {
        &self.triggered
    }
    fn triggered_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.triggered
    }
    fn value(&self) -> &AudioGraphNodePort {
        &self.value
    }
    fn value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.value
    }
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
}

impl AudioGraphNodeDataTrait for EventSwitcherNodeData {
}

impl super::core::DataContainerTrait for EventSwitcherNodeData {
}

pub static EVENTSWITCHERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSwitcherNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "EventSwitcherEntry-Array",
                rust_offset: offset_of!(EventSwitcherNodeData, inputs),
            },
            FieldInfoData {
                name: "Triggered",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSwitcherNodeData, triggered),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSwitcherNodeData, value),
            },
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EventSwitcherNodeData, default_value),
            },
        ],
    }),
    array_type: Some(EVENTSWITCHERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSwitcherNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSWITCHERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSWITCHERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSwitcherNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventSwitcherEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub case_trigger: AudioGraphNodePort,
    pub value: f32,
}

pub trait EventSwitcherEntryTrait: AudioGraphNodePortGroupTrait {
    fn case_trigger(&self) -> &AudioGraphNodePort;
    fn case_trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl EventSwitcherEntryTrait for EventSwitcherEntry {
    fn case_trigger(&self) -> &AudioGraphNodePort {
        &self.case_trigger
    }
    fn case_trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.case_trigger
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl AudioGraphNodePortGroupTrait for EventSwitcherEntry {
}

impl super::core::DataContainerTrait for EventSwitcherEntry {
}

pub static EVENTSWITCHERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventSwitcherEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CaseTrigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventSwitcherEntry, case_trigger),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EventSwitcherEntry, value),
            },
        ],
    }),
    array_type: Some(EVENTSWITCHERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventSwitcherEntry {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTSWITCHERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTSWITCHERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventSwitcherEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventSwitcherEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventGateNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub cool_down_time: AudioGraphNodePort,
    pub probability: AudioGraphNodePort,
    pub enable: AudioGraphNodePort,
}

pub trait EventGateNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn cool_down_time(&self) -> &AudioGraphNodePort;
    fn cool_down_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn probability(&self) -> &AudioGraphNodePort;
    fn probability_mut(&mut self) -> &mut AudioGraphNodePort;
    fn enable(&self) -> &AudioGraphNodePort;
    fn enable_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl EventGateNodeDataTrait for EventGateNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn cool_down_time(&self) -> &AudioGraphNodePort {
        &self.cool_down_time
    }
    fn cool_down_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.cool_down_time
    }
    fn probability(&self) -> &AudioGraphNodePort {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.probability
    }
    fn enable(&self) -> &AudioGraphNodePort {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.enable
    }
}

impl AudioGraphNodeDataTrait for EventGateNodeData {
}

impl super::core::DataContainerTrait for EventGateNodeData {
}

pub static EVENTGATENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventGateNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventGateNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventGateNodeData, out),
            },
            FieldInfoData {
                name: "CoolDownTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventGateNodeData, cool_down_time),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventGateNodeData, probability),
            },
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventGateNodeData, enable),
            },
        ],
    }),
    array_type: Some(EVENTGATENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventGateNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTGATENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTGATENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventGateNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventGateNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventDelayNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub events: Vec<Option<Arc<Mutex<dyn EventDelayNodeEntryTrait>>>>,
    pub delay_time: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub max_updates_per_second: u32,
}

pub trait EventDelayNodeDataTrait: AudioGraphNodeDataTrait {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn EventDelayNodeEntryTrait>>>>;
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn EventDelayNodeEntryTrait>>>>;
    fn delay_time(&self) -> &AudioGraphNodePort;
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_delay_time(&self) -> &f32;
    fn max_delay_time_mut(&mut self) -> &mut f32;
    fn max_updates_per_second(&self) -> &u32;
    fn max_updates_per_second_mut(&mut self) -> &mut u32;
}

impl EventDelayNodeDataTrait for EventDelayNodeData {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn EventDelayNodeEntryTrait>>>> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn EventDelayNodeEntryTrait>>>> {
        &mut self.events
    }
    fn delay_time(&self) -> &AudioGraphNodePort {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay_time
    }
    fn max_delay_time(&self) -> &f32 {
        &self.max_delay_time
    }
    fn max_delay_time_mut(&mut self) -> &mut f32 {
        &mut self.max_delay_time
    }
    fn max_updates_per_second(&self) -> &u32 {
        &self.max_updates_per_second
    }
    fn max_updates_per_second_mut(&mut self) -> &mut u32 {
        &mut self.max_updates_per_second
    }
}

impl AudioGraphNodeDataTrait for EventDelayNodeData {
}

impl super::core::DataContainerTrait for EventDelayNodeData {
}

pub static EVENTDELAYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventDelayNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "EventDelayNodeEntry-Array",
                rust_offset: offset_of!(EventDelayNodeData, events),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventDelayNodeData, delay_time),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EventDelayNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "MaxUpdatesPerSecond",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(EventDelayNodeData, max_updates_per_second),
            },
        ],
    }),
    array_type: Some(EVENTDELAYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventDelayNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTDELAYNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTDELAYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventDelayNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventDelayNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
}

pub trait EventDelayNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl EventDelayNodeEntryTrait for EventDelayNodeEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodePortGroupTrait for EventDelayNodeEntry {
}

impl super::core::DataContainerTrait for EventDelayNodeEntry {
}

pub static EVENTDELAYNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventDelayNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventDelayNodeEntry, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EventDelayNodeEntry, out),
            },
        ],
    }),
    array_type: Some(EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventDelayNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTDELAYNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTDELAYNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDelayNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventDelayNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeMuxNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub outputs: Vec<Option<Arc<Mutex<dyn DeMuxOutputTrait>>>>,
    pub trigger: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub wrap_value: bool,
}

pub trait DeMuxNodeDataTrait: AudioGraphNodeDataTrait {
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn DeMuxOutputTrait>>>>;
    fn outputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DeMuxOutputTrait>>>>;
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn value(&self) -> &AudioGraphNodePort;
    fn value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn wrap_value(&self) -> &bool;
    fn wrap_value_mut(&mut self) -> &mut bool;
}

impl DeMuxNodeDataTrait for DeMuxNodeData {
    fn outputs(&self) -> &Vec<Option<Arc<Mutex<dyn DeMuxOutputTrait>>>> {
        &self.outputs
    }
    fn outputs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DeMuxOutputTrait>>>> {
        &mut self.outputs
    }
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn value(&self) -> &AudioGraphNodePort {
        &self.value
    }
    fn value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.value
    }
    fn wrap_value(&self) -> &bool {
        &self.wrap_value
    }
    fn wrap_value_mut(&mut self) -> &mut bool {
        &mut self.wrap_value
    }
}

impl AudioGraphNodeDataTrait for DeMuxNodeData {
}

impl super::core::DataContainerTrait for DeMuxNodeData {
}

pub static DEMUXNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeMuxNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Outputs",
                flags: MemberInfoFlags::new(144),
                field_type: "DeMuxOutput-Array",
                rust_offset: offset_of!(DeMuxNodeData, outputs),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DeMuxNodeData, trigger),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DeMuxNodeData, value),
            },
            FieldInfoData {
                name: "WrapValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DeMuxNodeData, wrap_value),
            },
        ],
    }),
    array_type: Some(DEMUXNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeMuxNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DEMUXNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEMUXNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeMuxNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeMuxOutput {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub trigger: AudioGraphNodePort,
}

pub trait DeMuxOutputTrait: AudioGraphNodePortGroupTrait {
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl DeMuxOutputTrait for DeMuxOutput {
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
}

impl AudioGraphNodePortGroupTrait for DeMuxOutput {
}

impl super::core::DataContainerTrait for DeMuxOutput {
}

pub static DEMUXOUTPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxOutput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeMuxOutput as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DeMuxOutput, trigger),
            },
        ],
    }),
    array_type: Some(DEMUXOUTPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeMuxOutput {
    fn type_info(&self) -> &'static TypeInfo {
        DEMUXOUTPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEMUXOUTPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeMuxOutput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeMuxOutput"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeltaNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub deltas: Vec<Option<Arc<Mutex<dyn DeltaGroupTrait>>>>,
}

pub trait DeltaNodeDataTrait: AudioGraphNodeDataTrait {
    fn deltas(&self) -> &Vec<Option<Arc<Mutex<dyn DeltaGroupTrait>>>>;
    fn deltas_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DeltaGroupTrait>>>>;
}

impl DeltaNodeDataTrait for DeltaNodeData {
    fn deltas(&self) -> &Vec<Option<Arc<Mutex<dyn DeltaGroupTrait>>>> {
        &self.deltas
    }
    fn deltas_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DeltaGroupTrait>>>> {
        &mut self.deltas
    }
}

impl AudioGraphNodeDataTrait for DeltaNodeData {
}

impl super::core::DataContainerTrait for DeltaNodeData {
}

pub static DELTANODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeltaNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Deltas",
                flags: MemberInfoFlags::new(144),
                field_type: "DeltaGroup-Array",
                rust_offset: offset_of!(DeltaNodeData, deltas),
            },
        ],
    }),
    array_type: Some(DELTANODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DELTANODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELTANODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeltaNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DeltaGroup {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub delta: AudioGraphNodePort,
}

pub trait DeltaGroupTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn delta(&self) -> &AudioGraphNodePort;
    fn delta_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl DeltaGroupTrait for DeltaGroup {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn delta(&self) -> &AudioGraphNodePort {
        &self.delta
    }
    fn delta_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delta
    }
}

impl AudioGraphNodePortGroupTrait for DeltaGroup {
}

impl super::core::DataContainerTrait for DeltaGroup {
}

pub static DELTAGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DeltaGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DeltaGroup, r#in),
            },
            FieldInfoData {
                name: "Delta",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DeltaGroup, delta),
            },
        ],
    }),
    array_type: Some(DELTAGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DeltaGroup {
    fn type_info(&self) -> &'static TypeInfo {
        DELTAGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELTAGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DeltaGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DeltaGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EventDebugNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub events: Vec<Option<Arc<Mutex<dyn DebugEventInputTrait>>>>,
    pub enabled: bool,
}

pub trait EventDebugNodeDataTrait: AudioGraphNodeDataTrait {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn DebugEventInputTrait>>>>;
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DebugEventInputTrait>>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl EventDebugNodeDataTrait for EventDebugNodeData {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn DebugEventInputTrait>>>> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DebugEventInputTrait>>>> {
        &mut self.events
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl AudioGraphNodeDataTrait for EventDebugNodeData {
}

impl super::core::DataContainerTrait for EventDebugNodeData {
}

pub static EVENTDEBUGNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDebugNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EventDebugNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "DebugEventInput-Array",
                rust_offset: offset_of!(EventDebugNodeData, events),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(EventDebugNodeData, enabled),
            },
        ],
    }),
    array_type: Some(EVENTDEBUGNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EventDebugNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        EVENTDEBUGNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EVENTDEBUGNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EventDebugNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EventDebugNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugEventInput {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub e: AudioGraphNodePort,
    pub name: String,
    pub require_triggered_and_set: bool,
}

pub trait DebugEventInputTrait: AudioGraphNodePortGroupTrait {
    fn e(&self) -> &AudioGraphNodePort;
    fn e_mut(&mut self) -> &mut AudioGraphNodePort;
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn require_triggered_and_set(&self) -> &bool;
    fn require_triggered_and_set_mut(&mut self) -> &mut bool;
}

impl DebugEventInputTrait for DebugEventInput {
    fn e(&self) -> &AudioGraphNodePort {
        &self.e
    }
    fn e_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.e
    }
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn require_triggered_and_set(&self) -> &bool {
        &self.require_triggered_and_set
    }
    fn require_triggered_and_set_mut(&mut self) -> &mut bool {
        &mut self.require_triggered_and_set
    }
}

impl AudioGraphNodePortGroupTrait for DebugEventInput {
}

impl super::core::DataContainerTrait for DebugEventInput {
}

pub static DEBUGEVENTINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugEventInput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugEventInput as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "E",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DebugEventInput, e),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugEventInput, name),
            },
            FieldInfoData {
                name: "RequireTriggeredAndSet",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DebugEventInput, require_triggered_and_set),
            },
        ],
    }),
    array_type: Some(DEBUGEVENTINPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugEventInput {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGEVENTINPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGEVENTINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugEventInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DebugEventInput"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ValueDebugNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub values: Vec<Option<Arc<Mutex<dyn DebugValueInputTrait>>>>,
    pub enabled: bool,
}

pub trait ValueDebugNodeDataTrait: AudioGraphNodeDataTrait {
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn DebugValueInputTrait>>>>;
    fn values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DebugValueInputTrait>>>>;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl ValueDebugNodeDataTrait for ValueDebugNodeData {
    fn values(&self) -> &Vec<Option<Arc<Mutex<dyn DebugValueInputTrait>>>> {
        &self.values
    }
    fn values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn DebugValueInputTrait>>>> {
        &mut self.values
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl AudioGraphNodeDataTrait for ValueDebugNodeData {
}

impl super::core::DataContainerTrait for ValueDebugNodeData {
}

pub static VALUEDEBUGNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueDebugNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ValueDebugNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Values",
                flags: MemberInfoFlags::new(144),
                field_type: "DebugValueInput-Array",
                rust_offset: offset_of!(ValueDebugNodeData, values),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ValueDebugNodeData, enabled),
            },
        ],
    }),
    array_type: Some(VALUEDEBUGNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ValueDebugNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        VALUEDEBUGNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VALUEDEBUGNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ValueDebugNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ValueDebugNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DebugValueInput {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub v: AudioGraphNodePort,
    pub name: String,
    pub render_type: DebugRenderType,
    pub min: f32,
    pub max: f32,
}

pub trait DebugValueInputTrait: AudioGraphNodePortGroupTrait {
    fn v(&self) -> &AudioGraphNodePort;
    fn v_mut(&mut self) -> &mut AudioGraphNodePort;
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn render_type(&self) -> &DebugRenderType;
    fn render_type_mut(&mut self) -> &mut DebugRenderType;
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
}

impl DebugValueInputTrait for DebugValueInput {
    fn v(&self) -> &AudioGraphNodePort {
        &self.v
    }
    fn v_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.v
    }
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn render_type(&self) -> &DebugRenderType {
        &self.render_type
    }
    fn render_type_mut(&mut self) -> &mut DebugRenderType {
        &mut self.render_type
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
}

impl AudioGraphNodePortGroupTrait for DebugValueInput {
}

impl super::core::DataContainerTrait for DebugValueInput {
}

pub static DEBUGVALUEINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugValueInput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DebugValueInput as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "V",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DebugValueInput, v),
            },
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(DebugValueInput, name),
            },
            FieldInfoData {
                name: "RenderType",
                flags: MemberInfoFlags::new(0),
                field_type: "DebugRenderType",
                rust_offset: offset_of!(DebugValueInput, render_type),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DebugValueInput, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DebugValueInput, max),
            },
        ],
    }),
    array_type: Some(DEBUGVALUEINPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DebugValueInput {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGVALUEINPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DEBUGVALUEINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugValueInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DebugValueInput"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum DebugRenderType {
    #[default]
    DebugRenderType_Text = 0,
    DebugRenderType_Plot = 1,
    DebugRenderType_Bar = 2,
    DebugRenderType_World = 3,
}

pub static DEBUGRENDERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugRenderType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(DEBUGRENDERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DebugRenderType {
    fn type_info(&self) -> &'static TypeInfo {
        DEBUGRENDERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DEBUGRENDERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DebugRenderType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DebugRenderType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Crossfader2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub ctrl: AudioGraphNodePort,
    pub ctrl_out1: AudioGraphNodePort,
    pub ctrl_out2: AudioGraphNodePort,
}

pub trait Crossfader2NodeDataTrait: AudioGraphNodeDataTrait {
    fn ctrl(&self) -> &AudioGraphNodePort;
    fn ctrl_mut(&mut self) -> &mut AudioGraphNodePort;
    fn ctrl_out1(&self) -> &AudioGraphNodePort;
    fn ctrl_out1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn ctrl_out2(&self) -> &AudioGraphNodePort;
    fn ctrl_out2_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl Crossfader2NodeDataTrait for Crossfader2NodeData {
    fn ctrl(&self) -> &AudioGraphNodePort {
        &self.ctrl
    }
    fn ctrl_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.ctrl
    }
    fn ctrl_out1(&self) -> &AudioGraphNodePort {
        &self.ctrl_out1
    }
    fn ctrl_out1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.ctrl_out1
    }
    fn ctrl_out2(&self) -> &AudioGraphNodePort {
        &self.ctrl_out2
    }
    fn ctrl_out2_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.ctrl_out2
    }
}

impl AudioGraphNodeDataTrait for Crossfader2NodeData {
}

impl super::core::DataContainerTrait for Crossfader2NodeData {
}

pub static CROSSFADER2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Crossfader2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Crossfader2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Ctrl",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Crossfader2NodeData, ctrl),
            },
            FieldInfoData {
                name: "CtrlOut1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Crossfader2NodeData, ctrl_out1),
            },
            FieldInfoData {
                name: "CtrlOut2",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Crossfader2NodeData, ctrl_out2),
            },
        ],
    }),
    array_type: Some(CROSSFADER2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Crossfader2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CROSSFADER2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CROSSFADER2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Crossfader2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Crossfader2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConditionNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub conditions: Vec<ConditionGroupConfig>,
}

pub trait ConditionNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn conditions(&self) -> &Vec<ConditionGroupConfig>;
    fn conditions_mut(&mut self) -> &mut Vec<ConditionGroupConfig>;
}

impl ConditionNodeConfigDataTrait for ConditionNodeConfigData {
    fn conditions(&self) -> &Vec<ConditionGroupConfig> {
        &self.conditions
    }
    fn conditions_mut(&mut self) -> &mut Vec<ConditionGroupConfig> {
        &mut self.conditions
    }
}

impl AudioGraphNodeConfigDataTrait for ConditionNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for ConditionNodeConfigData {
}

pub static CONDITIONNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConditionNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Conditions",
                flags: MemberInfoFlags::new(144),
                field_type: "ConditionGroupConfig-Array",
                rust_offset: offset_of!(ConditionNodeConfigData, conditions),
            },
        ],
    }),
    array_type: Some(CONDITIONNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConditionNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        CONDITIONNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONDITIONNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConditionGroupConfig {
    pub x: f32,
    pub y: f32,
    pub auto_evaluate: bool,
    pub condition: ConditionType,
}

pub trait ConditionGroupConfigTrait: TypeObject {
    fn x(&self) -> &f32;
    fn x_mut(&mut self) -> &mut f32;
    fn y(&self) -> &f32;
    fn y_mut(&mut self) -> &mut f32;
    fn auto_evaluate(&self) -> &bool;
    fn auto_evaluate_mut(&mut self) -> &mut bool;
    fn condition(&self) -> &ConditionType;
    fn condition_mut(&mut self) -> &mut ConditionType;
}

impl ConditionGroupConfigTrait for ConditionGroupConfig {
    fn x(&self) -> &f32 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut f32 {
        &mut self.x
    }
    fn y(&self) -> &f32 {
        &self.y
    }
    fn y_mut(&mut self) -> &mut f32 {
        &mut self.y
    }
    fn auto_evaluate(&self) -> &bool {
        &self.auto_evaluate
    }
    fn auto_evaluate_mut(&mut self) -> &mut bool {
        &mut self.auto_evaluate
    }
    fn condition(&self) -> &ConditionType {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut ConditionType {
        &mut self.condition
    }
}

pub static CONDITIONGROUPCONFIG_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroupConfig",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConditionGroupConfig as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConditionGroupConfig, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConditionGroupConfig, y),
            },
            FieldInfoData {
                name: "AutoEvaluate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ConditionGroupConfig, auto_evaluate),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: "ConditionType",
                rust_offset: offset_of!(ConditionGroupConfig, condition),
            },
        ],
    }),
    array_type: Some(CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for ConditionGroupConfig {
    fn type_info(&self) -> &'static TypeInfo {
        CONDITIONGROUPCONFIG_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CONDITIONGROUPCONFIG_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroupConfig-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionGroupConfig"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConditionNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub conditions: Vec<Option<Arc<Mutex<dyn ConditionGroupTrait>>>>,
}

pub trait ConditionNodeDataTrait: AudioGraphNodeDataTrait {
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn ConditionGroupTrait>>>>;
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ConditionGroupTrait>>>>;
}

impl ConditionNodeDataTrait for ConditionNodeData {
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn ConditionGroupTrait>>>> {
        &self.conditions
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ConditionGroupTrait>>>> {
        &mut self.conditions
    }
}

impl AudioGraphNodeDataTrait for ConditionNodeData {
}

impl super::core::DataContainerTrait for ConditionNodeData {
}

pub static CONDITIONNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConditionNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Conditions",
                flags: MemberInfoFlags::new(144),
                field_type: "ConditionGroup-Array",
                rust_offset: offset_of!(ConditionNodeData, conditions),
            },
        ],
    }),
    array_type: Some(CONDITIONNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConditionNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CONDITIONNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONDITIONNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConditionGroup {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub x: AudioGraphNodePort,
    pub y: AudioGraphNodePort,
    pub r#true: AudioGraphNodePort,
    pub evaluate: AudioGraphNodePort,
    pub auto_evaluate: bool,
    pub condition: ConditionType,
}

pub trait ConditionGroupTrait: AudioGraphNodePortGroupTrait {
    fn x(&self) -> &AudioGraphNodePort;
    fn x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn y(&self) -> &AudioGraphNodePort;
    fn y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn r#true(&self) -> &AudioGraphNodePort;
    fn r#true_mut(&mut self) -> &mut AudioGraphNodePort;
    fn evaluate(&self) -> &AudioGraphNodePort;
    fn evaluate_mut(&mut self) -> &mut AudioGraphNodePort;
    fn auto_evaluate(&self) -> &bool;
    fn auto_evaluate_mut(&mut self) -> &mut bool;
    fn condition(&self) -> &ConditionType;
    fn condition_mut(&mut self) -> &mut ConditionType;
}

impl ConditionGroupTrait for ConditionGroup {
    fn x(&self) -> &AudioGraphNodePort {
        &self.x
    }
    fn x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.x
    }
    fn y(&self) -> &AudioGraphNodePort {
        &self.y
    }
    fn y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.y
    }
    fn r#true(&self) -> &AudioGraphNodePort {
        &self.r#true
    }
    fn r#true_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#true
    }
    fn evaluate(&self) -> &AudioGraphNodePort {
        &self.evaluate
    }
    fn evaluate_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.evaluate
    }
    fn auto_evaluate(&self) -> &bool {
        &self.auto_evaluate
    }
    fn auto_evaluate_mut(&mut self) -> &mut bool {
        &mut self.auto_evaluate
    }
    fn condition(&self) -> &ConditionType {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut ConditionType {
        &mut self.condition
    }
}

impl AudioGraphNodePortGroupTrait for ConditionGroup {
}

impl super::core::DataContainerTrait for ConditionGroup {
}

pub static CONDITIONGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConditionGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConditionGroup, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConditionGroup, y),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConditionGroup, r#true),
            },
            FieldInfoData {
                name: "Evaluate",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConditionGroup, evaluate),
            },
            FieldInfoData {
                name: "AutoEvaluate",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ConditionGroup, auto_evaluate),
            },
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(0),
                field_type: "ConditionType",
                rust_offset: offset_of!(ConditionGroup, condition),
            },
        ],
    }),
    array_type: Some(CONDITIONGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ConditionGroup {
    fn type_info(&self) -> &'static TypeInfo {
        CONDITIONGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONDITIONGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ConditionType {
    #[default]
    ConditionType_And = 0,
    ConditionType_Or = 1,
    ConditionType_XOr = 2,
    ConditionType_Equal = 3,
    ConditionType_NotEqual = 4,
    ConditionType_Less = 5,
    ConditionType_Greater = 6,
    ConditionType_LessOrEqual = 7,
    ConditionType_GreaterOrEqual = 8,
}

pub static CONDITIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(CONDITIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ConditionType {
    fn type_info(&self) -> &'static TypeInfo {
        CONDITIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static CONDITIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConditionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConditionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AdsrNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub trigger: AudioGraphNodePort,
    pub release: AudioGraphNodePort,
    pub a: AudioGraphNodePort,
    pub d: AudioGraphNodePort,
    pub s: AudioGraphNodePort,
    pub r: AudioGraphNodePort,
    pub value: AudioGraphNodePort,
    pub finished: AudioGraphNodePort,
    pub scale: f32,
    pub retrigger_from_start: bool,
}

pub trait AdsrNodeDataTrait: AudioGraphNodeDataTrait {
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release(&self) -> &AudioGraphNodePort;
    fn release_mut(&mut self) -> &mut AudioGraphNodePort;
    fn a(&self) -> &AudioGraphNodePort;
    fn a_mut(&mut self) -> &mut AudioGraphNodePort;
    fn d(&self) -> &AudioGraphNodePort;
    fn d_mut(&mut self) -> &mut AudioGraphNodePort;
    fn s(&self) -> &AudioGraphNodePort;
    fn s_mut(&mut self) -> &mut AudioGraphNodePort;
    fn r(&self) -> &AudioGraphNodePort;
    fn r_mut(&mut self) -> &mut AudioGraphNodePort;
    fn value(&self) -> &AudioGraphNodePort;
    fn value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn finished(&self) -> &AudioGraphNodePort;
    fn finished_mut(&mut self) -> &mut AudioGraphNodePort;
    fn scale(&self) -> &f32;
    fn scale_mut(&mut self) -> &mut f32;
    fn retrigger_from_start(&self) -> &bool;
    fn retrigger_from_start_mut(&mut self) -> &mut bool;
}

impl AdsrNodeDataTrait for AdsrNodeData {
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn release(&self) -> &AudioGraphNodePort {
        &self.release
    }
    fn release_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release
    }
    fn a(&self) -> &AudioGraphNodePort {
        &self.a
    }
    fn a_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.a
    }
    fn d(&self) -> &AudioGraphNodePort {
        &self.d
    }
    fn d_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.d
    }
    fn s(&self) -> &AudioGraphNodePort {
        &self.s
    }
    fn s_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.s
    }
    fn r(&self) -> &AudioGraphNodePort {
        &self.r
    }
    fn r_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r
    }
    fn value(&self) -> &AudioGraphNodePort {
        &self.value
    }
    fn value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.value
    }
    fn finished(&self) -> &AudioGraphNodePort {
        &self.finished
    }
    fn finished_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.finished
    }
    fn scale(&self) -> &f32 {
        &self.scale
    }
    fn scale_mut(&mut self) -> &mut f32 {
        &mut self.scale
    }
    fn retrigger_from_start(&self) -> &bool {
        &self.retrigger_from_start
    }
    fn retrigger_from_start_mut(&mut self) -> &mut bool {
        &mut self.retrigger_from_start
    }
}

impl AudioGraphNodeDataTrait for AdsrNodeData {
}

impl super::core::DataContainerTrait for AdsrNodeData {
}

pub static ADSRNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AdsrNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AdsrNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, trigger),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, release),
            },
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, a),
            },
            FieldInfoData {
                name: "D",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, d),
            },
            FieldInfoData {
                name: "S",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, s),
            },
            FieldInfoData {
                name: "R",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, r),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, value),
            },
            FieldInfoData {
                name: "Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AdsrNodeData, finished),
            },
            FieldInfoData {
                name: "Scale",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AdsrNodeData, scale),
            },
            FieldInfoData {
                name: "RetriggerFromStart",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(AdsrNodeData, retrigger_from_start),
            },
        ],
    }),
    array_type: Some(ADSRNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AdsrNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        ADSRNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ADSRNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AdsrNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AdsrNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabelToValueNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub source: VoiceOverValueConnection,
    pub result: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub label_array: Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>,
    pub default_result: Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>,
    pub assert_when_no_label: bool,
    pub assert_when_several_labels: bool,
}

pub trait VoiceOverLabelToValueNodeTrait: VoiceOverExpressionNodeTrait {
    fn source(&self) -> &VoiceOverValueConnection;
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn result(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn label_array(&self) -> &Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>;
    fn label_array_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>;
    fn default_result(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
    fn default_result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
    fn assert_when_no_label(&self) -> &bool;
    fn assert_when_no_label_mut(&mut self) -> &mut bool;
    fn assert_when_several_labels(&self) -> &bool;
    fn assert_when_several_labels_mut(&mut self) -> &mut bool;
}

impl VoiceOverLabelToValueNodeTrait for VoiceOverLabelToValueNode {
    fn source(&self) -> &VoiceOverValueConnection {
        &self.source
    }
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.source
    }
    fn result(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.result
    }
    fn result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.result
    }
    fn label_array(&self) -> &Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>> {
        &self.label_array
    }
    fn label_array_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>> {
        &mut self.label_array
    }
    fn default_result(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &self.default_result
    }
    fn default_result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &mut self.default_result
    }
    fn assert_when_no_label(&self) -> &bool {
        &self.assert_when_no_label
    }
    fn assert_when_no_label_mut(&mut self) -> &mut bool {
        &mut self.assert_when_no_label
    }
    fn assert_when_several_labels(&self) -> &bool {
        &self.assert_when_several_labels
    }
    fn assert_when_several_labels_mut(&mut self) -> &mut bool {
        &mut self.assert_when_several_labels
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverLabelToValueNode {
}

impl VoiceOverNodeTrait for VoiceOverLabelToValueNode {
}

impl super::core::DataContainerTrait for VoiceOverLabelToValueNode {
}

pub static VOICEOVERLABELTOVALUENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelToValueNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabelToValueNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverLabelToValueNode, source),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverLabelToValueNode, result),
            },
            FieldInfoData {
                name: "LabelArray",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelArray",
                rust_offset: offset_of!(VoiceOverLabelToValueNode, label_array),
            },
            FieldInfoData {
                name: "DefaultResult",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConstantValue",
                rust_offset: offset_of!(VoiceOverLabelToValueNode, default_result),
            },
            FieldInfoData {
                name: "AssertWhenNoLabel",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverLabelToValueNode, assert_when_no_label),
            },
            FieldInfoData {
                name: "AssertWhenSeveralLabels",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverLabelToValueNode, assert_when_several_labels),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELTOVALUENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelToValueNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELTOVALUENODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABELTOVALUENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelToValueNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelToValueNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverSystemAsset {
    pub _glacier_base: super::core::Asset,
    pub intervals: Vec<Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>>,
    pub labels: Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>,
    pub types: Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>>,
    pub objects: Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>>,
    pub constants: Vec<Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>>,
    pub master_language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub default_pronunciation: Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>,
    pub pronunciations: Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>>,
    pub queue_groups: Vec<Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>>,
    pub default_positioned_queue_group: Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>,
    pub default_unpositioned_queue_group: Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>,
    pub label_arrays: Vec<Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>>,
}

pub trait VoiceOverSystemAssetTrait: super::core::AssetTrait {
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>>;
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>>;
    fn labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn types(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>>;
    fn types_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>>;
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>>;
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>>;
    fn constants(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>>;
    fn constants_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>>;
    fn master_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn master_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn default_pronunciation(&self) -> &Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>;
    fn default_pronunciation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>;
    fn pronunciations(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>>;
    fn pronunciations_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>>;
    fn queue_groups(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>>;
    fn queue_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>>;
    fn default_positioned_queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn default_positioned_queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn default_unpositioned_queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn default_unpositioned_queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn label_arrays(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>>;
    fn label_arrays_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>>;
}

impl VoiceOverSystemAssetTrait for VoiceOverSystemAsset {
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>> {
        &self.intervals
    }
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>> {
        &mut self.intervals
    }
    fn labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &self.labels
    }
    fn labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &mut self.labels
    }
    fn types(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>> {
        &self.types
    }
    fn types_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>> {
        &mut self.types
    }
    fn objects(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>> {
        &self.objects
    }
    fn objects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>> {
        &mut self.objects
    }
    fn constants(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>> {
        &self.constants
    }
    fn constants_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>> {
        &mut self.constants
    }
    fn master_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.master_language
    }
    fn master_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.master_language
    }
    fn default_pronunciation(&self) -> &Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>> {
        &self.default_pronunciation
    }
    fn default_pronunciation_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>> {
        &mut self.default_pronunciation
    }
    fn pronunciations(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>> {
        &self.pronunciations
    }
    fn pronunciations_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>> {
        &mut self.pronunciations
    }
    fn queue_groups(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>> {
        &self.queue_groups
    }
    fn queue_groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>> {
        &mut self.queue_groups
    }
    fn default_positioned_queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &self.default_positioned_queue_group
    }
    fn default_positioned_queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &mut self.default_positioned_queue_group
    }
    fn default_unpositioned_queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &self.default_unpositioned_queue_group
    }
    fn default_unpositioned_queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &mut self.default_unpositioned_queue_group
    }
    fn label_arrays(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>> {
        &self.label_arrays
    }
    fn label_arrays_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelArrayTrait>>>> {
        &mut self.label_arrays
    }
}

impl super::core::AssetTrait for VoiceOverSystemAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverSystemAsset {
}

pub static VOICEOVERSYSTEMASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverSystemAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverSystemAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverInterval-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, intervals),
            },
            FieldInfoData {
                name: "Labels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, labels),
            },
            FieldInfoData {
                name: "Types",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverObject-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, types),
            },
            FieldInfoData {
                name: "Objects",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverObject-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, objects),
            },
            FieldInfoData {
                name: "Constants",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverGlobalConstantValue-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, constants),
            },
            FieldInfoData {
                name: "MasterLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(VoiceOverSystemAsset, master_language),
            },
            FieldInfoData {
                name: "DefaultPronunciation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverPronunciation",
                rust_offset: offset_of!(VoiceOverSystemAsset, default_pronunciation),
            },
            FieldInfoData {
                name: "Pronunciations",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverPronunciation-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, pronunciations),
            },
            FieldInfoData {
                name: "QueueGroups",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverConversationQueueGroup-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, queue_groups),
            },
            FieldInfoData {
                name: "DefaultPositionedQueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationQueueGroup",
                rust_offset: offset_of!(VoiceOverSystemAsset, default_positioned_queue_group),
            },
            FieldInfoData {
                name: "DefaultUnpositionedQueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationQueueGroup",
                rust_offset: offset_of!(VoiceOverSystemAsset, default_unpositioned_queue_group),
            },
            FieldInfoData {
                name: "LabelArrays",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabelArray-Array",
                rust_offset: offset_of!(VoiceOverSystemAsset, label_arrays),
            },
        ],
    }),
    array_type: Some(VOICEOVERSYSTEMASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverSystemAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERSYSTEMASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERSYSTEMASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverSystemAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverSystemAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabelArray {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub label_values: Vec<Option<Arc<Mutex<dyn VoiceOverLabelValueTrait>>>>,
}

pub trait VoiceOverLabelArrayTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn label_values(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelValueTrait>>>>;
    fn label_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelValueTrait>>>>;
}

impl VoiceOverLabelArrayTrait for VoiceOverLabelArray {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn label_values(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelValueTrait>>>> {
        &self.label_values
    }
    fn label_values_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelValueTrait>>>> {
        &mut self.label_values
    }
}

impl super::core::DataContainerTrait for VoiceOverLabelArray {
}

pub static VOICEOVERLABELARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelArray",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabelArray as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverLabelArray, name),
            },
            FieldInfoData {
                name: "LabelValues",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabelValue-Array",
                rust_offset: offset_of!(VoiceOverLabelArray, label_values),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELARRAY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelArray {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELARRAY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABELARRAY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelArray-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelArray"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabelValue {
    pub _glacier_base: super::core::DataContainer,
    pub label: Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>,
    pub source: Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>,
}

pub trait VoiceOverLabelValueTrait: super::core::DataContainerTrait {
    fn label(&self) -> &Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>;
    fn label_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>;
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
}

impl VoiceOverLabelValueTrait for VoiceOverLabelValue {
    fn label(&self) -> &Option<Arc<Mutex<dyn VoiceOverLabelTrait>>> {
        &self.label
    }
    fn label_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLabelTrait>>> {
        &mut self.label
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &mut self.source
    }
}

impl super::core::DataContainerTrait for VoiceOverLabelValue {
}

pub static VOICEOVERLABELVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabelValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Label",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabel",
                rust_offset: offset_of!(VoiceOverLabelValue, label),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConstantValue",
                rust_offset: offset_of!(VoiceOverLabelValue, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABELVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverPronunciation {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub primary_language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub secondary_language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub secondary_fallback: VoiceOverPronunciationFallback,
}

pub trait VoiceOverPronunciationTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn primary_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn primary_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn secondary_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn secondary_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn secondary_fallback(&self) -> &VoiceOverPronunciationFallback;
    fn secondary_fallback_mut(&mut self) -> &mut VoiceOverPronunciationFallback;
}

impl VoiceOverPronunciationTrait for VoiceOverPronunciation {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn primary_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.primary_language
    }
    fn primary_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.primary_language
    }
    fn secondary_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.secondary_language
    }
    fn secondary_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.secondary_language
    }
    fn secondary_fallback(&self) -> &VoiceOverPronunciationFallback {
        &self.secondary_fallback
    }
    fn secondary_fallback_mut(&mut self) -> &mut VoiceOverPronunciationFallback {
        &mut self.secondary_fallback
    }
}

impl super::core::DataContainerTrait for VoiceOverPronunciation {
}

pub static VOICEOVERPRONUNCIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciation",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverPronunciation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverPronunciation, name),
            },
            FieldInfoData {
                name: "PrimaryLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(VoiceOverPronunciation, primary_language),
            },
            FieldInfoData {
                name: "SecondaryLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(VoiceOverPronunciation, secondary_language),
            },
            FieldInfoData {
                name: "SecondaryFallback",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverPronunciationFallback",
                rust_offset: offset_of!(VoiceOverPronunciation, secondary_fallback),
            },
        ],
    }),
    array_type: Some(VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverPronunciation {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERPRONUNCIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERPRONUNCIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverPronunciation"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverPronunciationFallback {
    #[default]
    VoiceOverPronunciationFallback_None = 0,
    VoiceOverPronunciationFallback_Master = 1,
}

pub static VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciationFallback",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERPRONUNCIATIONFALLBACK_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverPronunciationFallback {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERPRONUNCIATIONFALLBACK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERPRONUNCIATIONFALLBACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverPronunciationFallback-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverPronunciationFallback"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationQueueGroup {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub polyphony_mode: VoiceOverConversationQueueGroupPolyphony,
    pub polyphony: u32,
}

pub trait VoiceOverConversationQueueGroupTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn polyphony_mode(&self) -> &VoiceOverConversationQueueGroupPolyphony;
    fn polyphony_mode_mut(&mut self) -> &mut VoiceOverConversationQueueGroupPolyphony;
    fn polyphony(&self) -> &u32;
    fn polyphony_mut(&mut self) -> &mut u32;
}

impl VoiceOverConversationQueueGroupTrait for VoiceOverConversationQueueGroup {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn polyphony_mode(&self) -> &VoiceOverConversationQueueGroupPolyphony {
        &self.polyphony_mode
    }
    fn polyphony_mode_mut(&mut self) -> &mut VoiceOverConversationQueueGroupPolyphony {
        &mut self.polyphony_mode
    }
    fn polyphony(&self) -> &u32 {
        &self.polyphony
    }
    fn polyphony_mut(&mut self) -> &mut u32 {
        &mut self.polyphony
    }
}

impl super::core::DataContainerTrait for VoiceOverConversationQueueGroup {
}

pub static VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationQueueGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverConversationQueueGroup, name),
            },
            FieldInfoData {
                name: "PolyphonyMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationQueueGroupPolyphony",
                rust_offset: offset_of!(VoiceOverConversationQueueGroup, polyphony_mode),
            },
            FieldInfoData {
                name: "Polyphony",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverConversationQueueGroup, polyphony),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationQueueGroup {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONQUEUEGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONQUEUEGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationQueueGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverConversationQueueGroupPolyphony {
    #[default]
    VoiceOverConversationQueueGroupPolyphony_Sources = 0,
    VoiceOverConversationQueueGroupPolyphony_GlobalSources = 1,
    VoiceOverConversationQueueGroupPolyphony_Conversations = 2,
}

pub static VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroupPolyphony",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverConversationQueueGroupPolyphony {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONVERSATIONQUEUEGROUPPOLYPHONY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueGroupPolyphony-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationQueueGroupPolyphony"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FinalDraftManuscriptAsset {
    pub _glacier_base: VoiceOverManuscriptAsset,
    pub spreadsheet_file_name: String,
}

pub trait FinalDraftManuscriptAssetTrait: VoiceOverManuscriptAssetTrait {
    fn spreadsheet_file_name(&self) -> &String;
    fn spreadsheet_file_name_mut(&mut self) -> &mut String;
}

impl FinalDraftManuscriptAssetTrait for FinalDraftManuscriptAsset {
    fn spreadsheet_file_name(&self) -> &String {
        &self.spreadsheet_file_name
    }
    fn spreadsheet_file_name_mut(&mut self) -> &mut String {
        &mut self.spreadsheet_file_name
    }
}

impl VoiceOverManuscriptAssetTrait for FinalDraftManuscriptAsset {
    fn master_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        self._glacier_base.master_language()
    }
    fn master_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        self._glacier_base.master_language_mut()
    }
    fn languages(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>> {
        self._glacier_base.languages()
    }
    fn languages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>> {
        self._glacier_base.languages_mut()
    }
    fn name_translation(&self) -> &VoiceOverWaveNameTranslation {
        self._glacier_base.name_translation()
    }
    fn name_translation_mut(&mut self) -> &mut VoiceOverWaveNameTranslation {
        self._glacier_base.name_translation_mut()
    }
    fn keep_path(&self) -> &bool {
        self._glacier_base.keep_path()
    }
    fn keep_path_mut(&mut self) -> &mut bool {
        self._glacier_base.keep_path_mut()
    }
    fn variation_underscore_count(&self) -> &u32 {
        self._glacier_base.variation_underscore_count()
    }
    fn variation_underscore_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.variation_underscore_count_mut()
    }
    fn string_id_column(&self) -> &String {
        self._glacier_base.string_id_column()
    }
    fn string_id_column_mut(&mut self) -> &mut String {
        self._glacier_base.string_id_column_mut()
    }
    fn file_name_column(&self) -> &String {
        self._glacier_base.file_name_column()
    }
    fn file_name_column_mut(&mut self) -> &mut String {
        self._glacier_base.file_name_column_mut()
    }
    fn path_column(&self) -> &String {
        self._glacier_base.path_column()
    }
    fn path_column_mut(&mut self) -> &mut String {
        self._glacier_base.path_column_mut()
    }
    fn wave_asset_status_column(&self) -> &String {
        self._glacier_base.wave_asset_status_column()
    }
    fn wave_asset_status_column_mut(&mut self) -> &mut String {
        self._glacier_base.wave_asset_status_column_mut()
    }
    fn sheet_name(&self) -> &String {
        self._glacier_base.sheet_name()
    }
    fn sheet_name_mut(&mut self) -> &mut String {
        self._glacier_base.sheet_name_mut()
    }
    fn voice_column(&self) -> &String {
        self._glacier_base.voice_column()
    }
    fn voice_column_mut(&mut self) -> &mut String {
        self._glacier_base.voice_column_mut()
    }
    fn character_column(&self) -> &String {
        self._glacier_base.character_column()
    }
    fn character_column_mut(&mut self) -> &mut String {
        self._glacier_base.character_column_mut()
    }
    fn language_columns(&self) -> &Vec<VoiceOverManuscriptLanguageColumns> {
        self._glacier_base.language_columns()
    }
    fn language_columns_mut(&mut self) -> &mut Vec<VoiceOverManuscriptLanguageColumns> {
        self._glacier_base.language_columns_mut()
    }
    fn first_content_row(&self) -> &i32 {
        self._glacier_base.first_content_row()
    }
    fn first_content_row_mut(&mut self) -> &mut i32 {
        self._glacier_base.first_content_row_mut()
    }
    fn string_id_prefix(&self) -> &String {
        self._glacier_base.string_id_prefix()
    }
    fn string_id_prefix_mut(&mut self) -> &mut String {
        self._glacier_base.string_id_prefix_mut()
    }
    fn string_id_upper_case(&self) -> &bool {
        self._glacier_base.string_id_upper_case()
    }
    fn string_id_upper_case_mut(&mut self) -> &mut bool {
        self._glacier_base.string_id_upper_case_mut()
    }
    fn output_path(&self) -> &String {
        self._glacier_base.output_path()
    }
    fn output_path_mut(&mut self) -> &mut String {
        self._glacier_base.output_path_mut()
    }
    fn allow_delete(&self) -> &bool {
        self._glacier_base.allow_delete()
    }
    fn allow_delete_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_delete_mut()
    }
    fn enable_subtitles(&self) -> &bool {
        self._glacier_base.enable_subtitles()
    }
    fn enable_subtitles_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_subtitles_mut()
    }
}

impl super::core::AssetTrait for FinalDraftManuscriptAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for FinalDraftManuscriptAsset {
}

pub static FINALDRAFTMANUSCRIPTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftManuscriptAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERMANUSCRIPTASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FinalDraftManuscriptAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SpreadsheetFileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(FinalDraftManuscriptAsset, spreadsheet_file_name),
            },
        ],
    }),
    array_type: Some(FINALDRAFTMANUSCRIPTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FinalDraftManuscriptAsset {
    fn type_info(&self) -> &'static TypeInfo {
        FINALDRAFTMANUSCRIPTASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FINALDRAFTMANUSCRIPTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftManuscriptAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FinalDraftManuscriptAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FinalDraftLineInfo {
    pub _glacier_base: super::core::DataContainer,
}

pub trait FinalDraftLineInfoTrait: super::core::DataContainerTrait {
}

impl FinalDraftLineInfoTrait for FinalDraftLineInfo {
}

impl super::core::DataContainerTrait for FinalDraftLineInfo {
}

pub static FINALDRAFTLINEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftLineInfo",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FinalDraftLineInfo as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(FINALDRAFTLINEINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FinalDraftLineInfo {
    fn type_info(&self) -> &'static TypeInfo {
        FINALDRAFTLINEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FINALDRAFTLINEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FinalDraftLineInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FinalDraftLineInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverManuscriptAsset {
    pub _glacier_base: super::core::Asset,
    pub master_language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub languages: Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>>,
    pub name_translation: VoiceOverWaveNameTranslation,
    pub keep_path: bool,
    pub variation_underscore_count: u32,
    pub string_id_column: String,
    pub file_name_column: String,
    pub path_column: String,
    pub wave_asset_status_column: String,
    pub sheet_name: String,
    pub voice_column: String,
    pub character_column: String,
    pub language_columns: Vec<VoiceOverManuscriptLanguageColumns>,
    pub first_content_row: i32,
    pub string_id_prefix: String,
    pub string_id_upper_case: bool,
    pub output_path: String,
    pub allow_delete: bool,
    pub enable_subtitles: bool,
}

pub trait VoiceOverManuscriptAssetTrait: super::core::AssetTrait {
    fn master_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn master_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn languages(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>>;
    fn languages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>>;
    fn name_translation(&self) -> &VoiceOverWaveNameTranslation;
    fn name_translation_mut(&mut self) -> &mut VoiceOverWaveNameTranslation;
    fn keep_path(&self) -> &bool;
    fn keep_path_mut(&mut self) -> &mut bool;
    fn variation_underscore_count(&self) -> &u32;
    fn variation_underscore_count_mut(&mut self) -> &mut u32;
    fn string_id_column(&self) -> &String;
    fn string_id_column_mut(&mut self) -> &mut String;
    fn file_name_column(&self) -> &String;
    fn file_name_column_mut(&mut self) -> &mut String;
    fn path_column(&self) -> &String;
    fn path_column_mut(&mut self) -> &mut String;
    fn wave_asset_status_column(&self) -> &String;
    fn wave_asset_status_column_mut(&mut self) -> &mut String;
    fn sheet_name(&self) -> &String;
    fn sheet_name_mut(&mut self) -> &mut String;
    fn voice_column(&self) -> &String;
    fn voice_column_mut(&mut self) -> &mut String;
    fn character_column(&self) -> &String;
    fn character_column_mut(&mut self) -> &mut String;
    fn language_columns(&self) -> &Vec<VoiceOverManuscriptLanguageColumns>;
    fn language_columns_mut(&mut self) -> &mut Vec<VoiceOverManuscriptLanguageColumns>;
    fn first_content_row(&self) -> &i32;
    fn first_content_row_mut(&mut self) -> &mut i32;
    fn string_id_prefix(&self) -> &String;
    fn string_id_prefix_mut(&mut self) -> &mut String;
    fn string_id_upper_case(&self) -> &bool;
    fn string_id_upper_case_mut(&mut self) -> &mut bool;
    fn output_path(&self) -> &String;
    fn output_path_mut(&mut self) -> &mut String;
    fn allow_delete(&self) -> &bool;
    fn allow_delete_mut(&mut self) -> &mut bool;
    fn enable_subtitles(&self) -> &bool;
    fn enable_subtitles_mut(&mut self) -> &mut bool;
}

impl VoiceOverManuscriptAssetTrait for VoiceOverManuscriptAsset {
    fn master_language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.master_language
    }
    fn master_language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.master_language
    }
    fn languages(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>> {
        &self.languages
    }
    fn languages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLanguageRootTrait>>>> {
        &mut self.languages
    }
    fn name_translation(&self) -> &VoiceOverWaveNameTranslation {
        &self.name_translation
    }
    fn name_translation_mut(&mut self) -> &mut VoiceOverWaveNameTranslation {
        &mut self.name_translation
    }
    fn keep_path(&self) -> &bool {
        &self.keep_path
    }
    fn keep_path_mut(&mut self) -> &mut bool {
        &mut self.keep_path
    }
    fn variation_underscore_count(&self) -> &u32 {
        &self.variation_underscore_count
    }
    fn variation_underscore_count_mut(&mut self) -> &mut u32 {
        &mut self.variation_underscore_count
    }
    fn string_id_column(&self) -> &String {
        &self.string_id_column
    }
    fn string_id_column_mut(&mut self) -> &mut String {
        &mut self.string_id_column
    }
    fn file_name_column(&self) -> &String {
        &self.file_name_column
    }
    fn file_name_column_mut(&mut self) -> &mut String {
        &mut self.file_name_column
    }
    fn path_column(&self) -> &String {
        &self.path_column
    }
    fn path_column_mut(&mut self) -> &mut String {
        &mut self.path_column
    }
    fn wave_asset_status_column(&self) -> &String {
        &self.wave_asset_status_column
    }
    fn wave_asset_status_column_mut(&mut self) -> &mut String {
        &mut self.wave_asset_status_column
    }
    fn sheet_name(&self) -> &String {
        &self.sheet_name
    }
    fn sheet_name_mut(&mut self) -> &mut String {
        &mut self.sheet_name
    }
    fn voice_column(&self) -> &String {
        &self.voice_column
    }
    fn voice_column_mut(&mut self) -> &mut String {
        &mut self.voice_column
    }
    fn character_column(&self) -> &String {
        &self.character_column
    }
    fn character_column_mut(&mut self) -> &mut String {
        &mut self.character_column
    }
    fn language_columns(&self) -> &Vec<VoiceOverManuscriptLanguageColumns> {
        &self.language_columns
    }
    fn language_columns_mut(&mut self) -> &mut Vec<VoiceOverManuscriptLanguageColumns> {
        &mut self.language_columns
    }
    fn first_content_row(&self) -> &i32 {
        &self.first_content_row
    }
    fn first_content_row_mut(&mut self) -> &mut i32 {
        &mut self.first_content_row
    }
    fn string_id_prefix(&self) -> &String {
        &self.string_id_prefix
    }
    fn string_id_prefix_mut(&mut self) -> &mut String {
        &mut self.string_id_prefix
    }
    fn string_id_upper_case(&self) -> &bool {
        &self.string_id_upper_case
    }
    fn string_id_upper_case_mut(&mut self) -> &mut bool {
        &mut self.string_id_upper_case
    }
    fn output_path(&self) -> &String {
        &self.output_path
    }
    fn output_path_mut(&mut self) -> &mut String {
        &mut self.output_path
    }
    fn allow_delete(&self) -> &bool {
        &self.allow_delete
    }
    fn allow_delete_mut(&mut self) -> &mut bool {
        &mut self.allow_delete
    }
    fn enable_subtitles(&self) -> &bool {
        &self.enable_subtitles
    }
    fn enable_subtitles_mut(&mut self) -> &mut bool {
        &mut self.enable_subtitles
    }
}

impl super::core::AssetTrait for VoiceOverManuscriptAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverManuscriptAsset {
}

pub static VOICEOVERMANUSCRIPTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverManuscriptAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MasterLanguage",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, master_language),
            },
            FieldInfoData {
                name: "Languages",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLanguageRoot-Array",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, languages),
            },
            FieldInfoData {
                name: "NameTranslation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverWaveNameTranslation",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, name_translation),
            },
            FieldInfoData {
                name: "KeepPath",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, keep_path),
            },
            FieldInfoData {
                name: "VariationUnderscoreCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, variation_underscore_count),
            },
            FieldInfoData {
                name: "StringIdColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, string_id_column),
            },
            FieldInfoData {
                name: "FileNameColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, file_name_column),
            },
            FieldInfoData {
                name: "PathColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, path_column),
            },
            FieldInfoData {
                name: "WaveAssetStatusColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, wave_asset_status_column),
            },
            FieldInfoData {
                name: "SheetName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, sheet_name),
            },
            FieldInfoData {
                name: "VoiceColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, voice_column),
            },
            FieldInfoData {
                name: "CharacterColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, character_column),
            },
            FieldInfoData {
                name: "LanguageColumns",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverManuscriptLanguageColumns-Array",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, language_columns),
            },
            FieldInfoData {
                name: "FirstContentRow",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, first_content_row),
            },
            FieldInfoData {
                name: "StringIdPrefix",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, string_id_prefix),
            },
            FieldInfoData {
                name: "StringIdUpperCase",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, string_id_upper_case),
            },
            FieldInfoData {
                name: "OutputPath",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, output_path),
            },
            FieldInfoData {
                name: "AllowDelete",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, allow_delete),
            },
            FieldInfoData {
                name: "EnableSubtitles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverManuscriptAsset, enable_subtitles),
            },
        ],
    }),
    array_type: Some(VOICEOVERMANUSCRIPTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverManuscriptAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERMANUSCRIPTASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERMANUSCRIPTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverManuscriptAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverManuscriptLanguageColumns {
    pub language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub text_column: String,
    pub subtitle_offset_column: String,
}

pub trait VoiceOverManuscriptLanguageColumnsTrait: TypeObject {
    fn language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn text_column(&self) -> &String;
    fn text_column_mut(&mut self) -> &mut String;
    fn subtitle_offset_column(&self) -> &String;
    fn subtitle_offset_column_mut(&mut self) -> &mut String;
}

impl VoiceOverManuscriptLanguageColumnsTrait for VoiceOverManuscriptLanguageColumns {
    fn language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.language
    }
    fn language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.language
    }
    fn text_column(&self) -> &String {
        &self.text_column
    }
    fn text_column_mut(&mut self) -> &mut String {
        &mut self.text_column
    }
    fn subtitle_offset_column(&self) -> &String {
        &self.subtitle_offset_column
    }
    fn subtitle_offset_column_mut(&mut self) -> &mut String {
        &mut self.subtitle_offset_column
    }
}

pub static VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptLanguageColumns",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverManuscriptLanguageColumns as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Language",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(VoiceOverManuscriptLanguageColumns, language),
            },
            FieldInfoData {
                name: "TextColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptLanguageColumns, text_column),
            },
            FieldInfoData {
                name: "SubtitleOffsetColumn",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverManuscriptLanguageColumns, subtitle_offset_column),
            },
        ],
    }),
    array_type: Some(VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverManuscriptLanguageColumns {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERMANUSCRIPTLANGUAGECOLUMNS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverManuscriptLanguageColumns-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverManuscriptLanguageColumns"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverWaveNameTranslation {
    #[default]
    VoiceOverWaveNameTranslation_FullName = 0,
    VoiceOverWaveNameTranslation_PathOnly = 1,
    VoiceOverWaveNameTranslation_NameOnly = 2,
}

pub static VOICEOVERWAVENAMETRANSLATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverWaveNameTranslation",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERWAVENAMETRANSLATION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverWaveNameTranslation {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERWAVENAMETRANSLATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERWAVENAMETRANSLATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverWaveNameTranslation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverWaveNameTranslation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLanguageRoot {
    pub _glacier_base: super::core::DataContainer,
    pub language: Option<Arc<Mutex<dyn AudioLanguageTrait>>>,
    pub path: String,
}

pub trait VoiceOverLanguageRootTrait: super::core::DataContainerTrait {
    fn language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>>;
    fn path(&self) -> &String;
    fn path_mut(&mut self) -> &mut String;
}

impl VoiceOverLanguageRootTrait for VoiceOverLanguageRoot {
    fn language(&self) -> &Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &self.language
    }
    fn language_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioLanguageTrait>>> {
        &mut self.language
    }
    fn path(&self) -> &String {
        &self.path
    }
    fn path_mut(&mut self) -> &mut String {
        &mut self.path
    }
}

impl super::core::DataContainerTrait for VoiceOverLanguageRoot {
}

pub static VOICEOVERLANGUAGEROOT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLanguageRoot",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLanguageRoot as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Language",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioLanguage",
                rust_offset: offset_of!(VoiceOverLanguageRoot, language),
            },
            FieldInfoData {
                name: "Path",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverLanguageRoot, path),
            },
        ],
    }),
    array_type: Some(VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLanguageRoot {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLANGUAGEROOT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLANGUAGEROOT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLanguageRoot-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLanguageRoot"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLogicAsset {
    pub _glacier_base: super::core::Asset,
    pub events: Vec<Option<Arc<Mutex<dyn VoiceOverEventTrait>>>>,
    pub groups: Vec<Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>>,
    pub flows: Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>>,
    pub flow_configs: Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowConfigDataTrait>>>>,
    pub system: Option<Arc<Mutex<dyn VoiceOverSystemAssetTrait>>>,
}

pub trait VoiceOverLogicAssetTrait: super::core::AssetTrait {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverEventTrait>>>>;
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverEventTrait>>>>;
    fn groups(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>>;
    fn groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>>;
    fn flows(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>>;
    fn flows_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>>;
    fn flow_configs(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowConfigDataTrait>>>>;
    fn flow_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowConfigDataTrait>>>>;
    fn system(&self) -> &Option<Arc<Mutex<dyn VoiceOverSystemAssetTrait>>>;
    fn system_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverSystemAssetTrait>>>;
}

impl VoiceOverLogicAssetTrait for VoiceOverLogicAsset {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverEventTrait>>>> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverEventTrait>>>> {
        &mut self.events
    }
    fn groups(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>> {
        &self.groups
    }
    fn groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>> {
        &mut self.groups
    }
    fn flows(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>> {
        &self.flows
    }
    fn flows_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>> {
        &mut self.flows
    }
    fn flow_configs(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowConfigDataTrait>>>> {
        &self.flow_configs
    }
    fn flow_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLogicFlowConfigDataTrait>>>> {
        &mut self.flow_configs
    }
    fn system(&self) -> &Option<Arc<Mutex<dyn VoiceOverSystemAssetTrait>>> {
        &self.system
    }
    fn system_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverSystemAssetTrait>>> {
        &mut self.system
    }
}

impl super::core::AssetTrait for VoiceOverLogicAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverLogicAsset {
}

pub static VOICEOVERLOGICASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLogicAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverEvent-Array",
                rust_offset: offset_of!(VoiceOverLogicAsset, events),
            },
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverGroup-Array",
                rust_offset: offset_of!(VoiceOverLogicAsset, groups),
            },
            FieldInfoData {
                name: "Flows",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLogicFlow-Array",
                rust_offset: offset_of!(VoiceOverLogicAsset, flows),
            },
            FieldInfoData {
                name: "FlowConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLogicFlowConfigData-Array",
                rust_offset: offset_of!(VoiceOverLogicAsset, flow_configs),
            },
            FieldInfoData {
                name: "System",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverSystemAsset",
                rust_offset: offset_of!(VoiceOverLogicAsset, system),
            },
        ],
    }),
    array_type: Some(VOICEOVERLOGICASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLogicAsset {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLOGICASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLOGICASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverGroup {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub priority: i32,
}

pub trait VoiceOverGroupTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
}

impl VoiceOverGroupTrait for VoiceOverGroup {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
}

impl super::core::DataContainerTrait for VoiceOverGroup {
}

pub static VOICEOVERGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverGroup, name),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoiceOverGroup, priority),
            },
        ],
    }),
    array_type: Some(VOICEOVERGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGroup {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLogicFlowConfigData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub owner: Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>,
    pub group: Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>,
    pub locals: Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>>,
    pub roots: Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeConfigDataTrait>>>>,
    pub flow: Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>,
    pub node_configs: Vec<Option<Arc<Mutex<dyn VoiceOverNodeConfigDataTrait>>>>,
}

pub trait VoiceOverLogicFlowConfigDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn owner(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>;
    fn owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>;
    fn group(&self) -> &Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>;
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>;
    fn locals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>>;
    fn locals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>>;
    fn roots(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeConfigDataTrait>>>>;
    fn roots_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeConfigDataTrait>>>>;
    fn flow(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>;
    fn flow_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>>;
    fn node_configs(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverNodeConfigDataTrait>>>>;
    fn node_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverNodeConfigDataTrait>>>>;
}

impl VoiceOverLogicFlowConfigDataTrait for VoiceOverLogicFlowConfigData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn owner(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>> {
        &self.owner
    }
    fn owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>> {
        &mut self.owner
    }
    fn group(&self) -> &Option<Arc<Mutex<dyn VoiceOverGroupTrait>>> {
        &self.group
    }
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverGroupTrait>>> {
        &mut self.group
    }
    fn locals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>> {
        &self.locals
    }
    fn locals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>> {
        &mut self.locals
    }
    fn roots(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeConfigDataTrait>>>> {
        &self.roots
    }
    fn roots_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeConfigDataTrait>>>> {
        &mut self.roots
    }
    fn flow(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>> {
        &self.flow
    }
    fn flow_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicFlowTrait>>> {
        &mut self.flow
    }
    fn node_configs(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverNodeConfigDataTrait>>>> {
        &self.node_configs
    }
    fn node_configs_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverNodeConfigDataTrait>>>> {
        &mut self.node_configs
    }
}

impl super::core::DataContainerTrait for VoiceOverLogicFlowConfigData {
}

pub static VOICEOVERLOGICFLOWCONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLogicFlowConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, name),
            },
            FieldInfoData {
                name: "Owner",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLogicAsset",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, owner),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverGroup",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, group),
            },
            FieldInfoData {
                name: "Locals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverValue-Array",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, locals),
            },
            FieldInfoData {
                name: "Roots",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverEventNodeConfigData-Array",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, roots),
            },
            FieldInfoData {
                name: "Flow",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLogicFlow",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, flow),
            },
            FieldInfoData {
                name: "NodeConfigs",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverNodeConfigData-Array",
                rust_offset: offset_of!(VoiceOverLogicFlowConfigData, node_configs),
            },
        ],
    }),
    array_type: Some(VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLogicFlowConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLOGICFLOWCONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLOGICFLOWCONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicFlowConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLogicFlow {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub owner: Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>,
    pub group: Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>,
    pub locals: Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>>,
    pub roots: Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeTrait>>>>,
}

pub trait VoiceOverLogicFlowTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn owner(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>;
    fn owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>;
    fn group(&self) -> &Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>;
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverGroupTrait>>>;
    fn locals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>>;
    fn locals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>>;
    fn roots(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeTrait>>>>;
    fn roots_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeTrait>>>>;
}

impl VoiceOverLogicFlowTrait for VoiceOverLogicFlow {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn owner(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>> {
        &self.owner
    }
    fn owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>> {
        &mut self.owner
    }
    fn group(&self) -> &Option<Arc<Mutex<dyn VoiceOverGroupTrait>>> {
        &self.group
    }
    fn group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverGroupTrait>>> {
        &mut self.group
    }
    fn locals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>> {
        &self.locals
    }
    fn locals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueTrait>>>> {
        &mut self.locals
    }
    fn roots(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeTrait>>>> {
        &self.roots
    }
    fn roots_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverEventNodeTrait>>>> {
        &mut self.roots
    }
}

impl super::core::DataContainerTrait for VoiceOverLogicFlow {
}

pub static VOICEOVERLOGICFLOW_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlow",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLogicFlow as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverLogicFlow, name),
            },
            FieldInfoData {
                name: "Owner",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLogicAsset",
                rust_offset: offset_of!(VoiceOverLogicFlow, owner),
            },
            FieldInfoData {
                name: "Group",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverGroup",
                rust_offset: offset_of!(VoiceOverLogicFlow, group),
            },
            FieldInfoData {
                name: "Locals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverValue-Array",
                rust_offset: offset_of!(VoiceOverLogicFlow, locals),
            },
            FieldInfoData {
                name: "Roots",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverEventNode-Array",
                rust_offset: offset_of!(VoiceOverLogicFlow, roots),
            },
        ],
    }),
    array_type: Some(VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLogicFlow {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLOGICFLOW_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLOGICFLOW_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlow-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicFlow"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverRandomContainerNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub flow_outputs: Vec<VoiceOverRandomContainerOutput>,
}

pub trait VoiceOverRandomContainerNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn flow_outputs(&self) -> &Vec<VoiceOverRandomContainerOutput>;
    fn flow_outputs_mut(&mut self) -> &mut Vec<VoiceOverRandomContainerOutput>;
}

impl VoiceOverRandomContainerNodeConfigDataTrait for VoiceOverRandomContainerNodeConfigData {
    fn flow_outputs(&self) -> &Vec<VoiceOverRandomContainerOutput> {
        &self.flow_outputs
    }
    fn flow_outputs_mut(&mut self) -> &mut Vec<VoiceOverRandomContainerOutput> {
        &mut self.flow_outputs
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverRandomContainerNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverRandomContainerNodeConfigData {
}

pub static VOICEOVERRANDOMCONTAINERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverRandomContainerNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FlowOutputs",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverRandomContainerOutput-Array",
                rust_offset: offset_of!(VoiceOverRandomContainerNodeConfigData, flow_outputs),
            },
        ],
    }),
    array_type: Some(VOICEOVERRANDOMCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRandomContainerNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERRANDOMCONTAINERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERRANDOMCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRandomContainerNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverRandomContainerNode {
    pub _glacier_base: VoiceOverStructureNode,
    pub intervals: Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>,
    pub flow_outputs: Vec<VoiceOverRandomContainerOutput>,
}

pub trait VoiceOverRandomContainerNodeTrait: VoiceOverStructureNodeTrait {
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn flow_outputs(&self) -> &Vec<VoiceOverRandomContainerOutput>;
    fn flow_outputs_mut(&mut self) -> &mut Vec<VoiceOverRandomContainerOutput>;
}

impl VoiceOverRandomContainerNodeTrait for VoiceOverRandomContainerNode {
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &self.intervals
    }
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &mut self.intervals
    }
    fn flow_outputs(&self) -> &Vec<VoiceOverRandomContainerOutput> {
        &self.flow_outputs
    }
    fn flow_outputs_mut(&mut self) -> &mut Vec<VoiceOverRandomContainerOutput> {
        &mut self.flow_outputs
    }
}

impl VoiceOverStructureNodeTrait for VoiceOverRandomContainerNode {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode()
    }
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode_mut()
    }
}

impl VoiceOverNodeTrait for VoiceOverRandomContainerNode {
}

impl super::core::DataContainerTrait for VoiceOverRandomContainerNode {
}

pub static VOICEOVERRANDOMCONTAINERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverRandomContainerNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverIntervalNode-Array",
                rust_offset: offset_of!(VoiceOverRandomContainerNode, intervals),
            },
            FieldInfoData {
                name: "FlowOutputs",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverRandomContainerOutput-Array",
                rust_offset: offset_of!(VoiceOverRandomContainerNode, flow_outputs),
            },
        ],
    }),
    array_type: Some(VOICEOVERRANDOMCONTAINERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRandomContainerNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERRANDOMCONTAINERNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERRANDOMCONTAINERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRandomContainerNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverRandomContainerOutput {
    pub output_relationship: Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>,
    pub weight: u32,
}

pub trait VoiceOverRandomContainerOutputTrait: TypeObject {
    fn output_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn output_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn weight(&self) -> &u32;
    fn weight_mut(&mut self) -> &mut u32;
}

impl VoiceOverRandomContainerOutputTrait for VoiceOverRandomContainerOutput {
    fn output_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &self.output_relationship
    }
    fn output_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &mut self.output_relationship
    }
    fn weight(&self) -> &u32 {
        &self.weight
    }
    fn weight_mut(&mut self) -> &mut u32 {
        &mut self.weight
    }
}

pub static VOICEOVERRANDOMCONTAINEROUTPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerOutput",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverRandomContainerOutput as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OutputRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverStructureNode-Array",
                rust_offset: offset_of!(VoiceOverRandomContainerOutput, output_relationship),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverRandomContainerOutput, weight),
            },
        ],
    }),
    array_type: Some(VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRandomContainerOutput {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERRANDOMCONTAINEROUTPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERRANDOMCONTAINEROUTPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRandomContainerOutput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRandomContainerOutput"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverTriggerNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub delay: f32,
    pub parameters: Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>>,
    pub event: Option<Arc<Mutex<dyn VoiceOverEventTrait>>>,
}

pub trait VoiceOverTriggerNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>>;
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>>;
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
}

impl VoiceOverTriggerNodeConfigDataTrait for VoiceOverTriggerNodeConfigData {
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>> {
        &mut self.parameters
    }
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &mut self.event
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverTriggerNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverTriggerNodeConfigData {
}

pub static VOICEOVERTRIGGERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverTriggerNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverTriggerNodeConfigData, delay),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverTriggerParameter-Array",
                rust_offset: offset_of!(VoiceOverTriggerNodeConfigData, parameters),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(VoiceOverTriggerNodeConfigData, event),
            },
        ],
    }),
    array_type: Some(VOICEOVERTRIGGERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverTriggerNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERTRIGGERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERTRIGGERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverTriggerNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverTriggerNode {
    pub _glacier_base: VoiceOverStructureNode,
    pub parameters: Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>>,
    pub delay: f32,
    pub event: Option<Arc<Mutex<dyn VoiceOverEventTrait>>>,
}

pub trait VoiceOverTriggerNodeTrait: VoiceOverStructureNodeTrait {
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>>;
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>>;
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
}

impl VoiceOverTriggerNodeTrait for VoiceOverTriggerNode {
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverTriggerParameterTrait>>>> {
        &mut self.parameters
    }
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &mut self.event
    }
}

impl VoiceOverStructureNodeTrait for VoiceOverTriggerNode {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode()
    }
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode_mut()
    }
}

impl VoiceOverNodeTrait for VoiceOverTriggerNode {
}

impl super::core::DataContainerTrait for VoiceOverTriggerNode {
}

pub static VOICEOVERTRIGGERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverTriggerNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverTriggerParameter-Array",
                rust_offset: offset_of!(VoiceOverTriggerNode, parameters),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverTriggerNode, delay),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(VoiceOverTriggerNode, event),
            },
        ],
    }),
    array_type: Some(VOICEOVERTRIGGERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverTriggerNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERTRIGGERNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERTRIGGERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverTriggerNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverTriggerParameter {
    pub _glacier_base: super::core::DataContainer,
    pub source: VoiceOverValueConnection,
    pub event_parameter: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
}

pub trait VoiceOverTriggerParameterTrait: super::core::DataContainerTrait {
    fn source(&self) -> &VoiceOverValueConnection;
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn event_parameter(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn event_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
}

impl VoiceOverTriggerParameterTrait for VoiceOverTriggerParameter {
    fn source(&self) -> &VoiceOverValueConnection {
        &self.source
    }
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.source
    }
    fn event_parameter(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.event_parameter
    }
    fn event_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.event_parameter
    }
}

impl super::core::DataContainerTrait for VoiceOverTriggerParameter {
}

pub static VOICEOVERTRIGGERPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverTriggerParameter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverTriggerParameter, source),
            },
            FieldInfoData {
                name: "EventParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverTriggerParameter, event_parameter),
            },
        ],
    }),
    array_type: Some(VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverTriggerParameter {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERTRIGGERPARAMETER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERTRIGGERPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverTriggerParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverTriggerParameter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverEventNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub redirects: Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>>,
    pub event: Option<Arc<Mutex<dyn VoiceOverEventTrait>>>,
    pub debug_enabled: bool,
    pub debug_color: super::core::Vec3,
    pub debug_interval_time: f32,
}

pub trait VoiceOverEventNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn redirects(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>>;
    fn redirects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>>;
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
    fn debug_enabled(&self) -> &bool;
    fn debug_enabled_mut(&mut self) -> &mut bool;
    fn debug_color(&self) -> &super::core::Vec3;
    fn debug_color_mut(&mut self) -> &mut super::core::Vec3;
    fn debug_interval_time(&self) -> &f32;
    fn debug_interval_time_mut(&mut self) -> &mut f32;
}

impl VoiceOverEventNodeConfigDataTrait for VoiceOverEventNodeConfigData {
    fn redirects(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>> {
        &self.redirects
    }
    fn redirects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>> {
        &mut self.redirects
    }
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &mut self.event
    }
    fn debug_enabled(&self) -> &bool {
        &self.debug_enabled
    }
    fn debug_enabled_mut(&mut self) -> &mut bool {
        &mut self.debug_enabled
    }
    fn debug_color(&self) -> &super::core::Vec3 {
        &self.debug_color
    }
    fn debug_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.debug_color
    }
    fn debug_interval_time(&self) -> &f32 {
        &self.debug_interval_time
    }
    fn debug_interval_time_mut(&mut self) -> &mut f32 {
        &mut self.debug_interval_time
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverEventNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverEventNodeConfigData {
}

pub static VOICEOVEREVENTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverEventNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Redirects",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverValueRedirect-Array",
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, redirects),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, event),
            },
            FieldInfoData {
                name: "DebugEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, debug_enabled),
            },
            FieldInfoData {
                name: "DebugColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, debug_color),
            },
            FieldInfoData {
                name: "DebugIntervalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverEventNodeConfigData, debug_interval_time),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverEventNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEREVENTNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEREVENTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverEventNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverEventNode {
    pub _glacier_base: VoiceOverStructureNode,
    pub intervals: Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>,
    pub relationship: Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>,
    pub redirects: Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>>,
    pub event: Option<Arc<Mutex<dyn VoiceOverEventTrait>>>,
    pub debug_enabled: bool,
    pub debug_color: super::core::Vec3,
    pub debug_interval_time: f32,
}

pub trait VoiceOverEventNodeTrait: VoiceOverStructureNodeTrait {
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn redirects(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>>;
    fn redirects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>>;
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>>;
    fn debug_enabled(&self) -> &bool;
    fn debug_enabled_mut(&mut self) -> &mut bool;
    fn debug_color(&self) -> &super::core::Vec3;
    fn debug_color_mut(&mut self) -> &mut super::core::Vec3;
    fn debug_interval_time(&self) -> &f32;
    fn debug_interval_time_mut(&mut self) -> &mut f32;
}

impl VoiceOverEventNodeTrait for VoiceOverEventNode {
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &self.intervals
    }
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &mut self.intervals
    }
    fn relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &self.relationship
    }
    fn relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &mut self.relationship
    }
    fn redirects(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>> {
        &self.redirects
    }
    fn redirects_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverValueRedirectTrait>>>> {
        &mut self.redirects
    }
    fn event(&self) -> &Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverEventTrait>>> {
        &mut self.event
    }
    fn debug_enabled(&self) -> &bool {
        &self.debug_enabled
    }
    fn debug_enabled_mut(&mut self) -> &mut bool {
        &mut self.debug_enabled
    }
    fn debug_color(&self) -> &super::core::Vec3 {
        &self.debug_color
    }
    fn debug_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.debug_color
    }
    fn debug_interval_time(&self) -> &f32 {
        &self.debug_interval_time
    }
    fn debug_interval_time_mut(&mut self) -> &mut f32 {
        &mut self.debug_interval_time
    }
}

impl VoiceOverStructureNodeTrait for VoiceOverEventNode {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode()
    }
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode_mut()
    }
}

impl VoiceOverNodeTrait for VoiceOverEventNode {
}

impl super::core::DataContainerTrait for VoiceOverEventNode {
}

pub static VOICEOVEREVENTNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverEventNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverIntervalNode-Array",
                rust_offset: offset_of!(VoiceOverEventNode, intervals),
            },
            FieldInfoData {
                name: "Relationship",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverStructureNode-Array",
                rust_offset: offset_of!(VoiceOverEventNode, relationship),
            },
            FieldInfoData {
                name: "Redirects",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverValueRedirect-Array",
                rust_offset: offset_of!(VoiceOverEventNode, redirects),
            },
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverEvent",
                rust_offset: offset_of!(VoiceOverEventNode, event),
            },
            FieldInfoData {
                name: "DebugEnabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverEventNode, debug_enabled),
            },
            FieldInfoData {
                name: "DebugColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VoiceOverEventNode, debug_color),
            },
            FieldInfoData {
                name: "DebugIntervalTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverEventNode, debug_interval_time),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENTNODE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverEventNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEREVENTNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEREVENTNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEventNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverEventNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub conversation: VoiceOverConversationInfo,
}

pub trait VoiceOverConversationNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode;
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode;
    fn probability(&self) -> &f32;
    fn probability_mut(&mut self) -> &mut f32;
    fn conversation(&self) -> &VoiceOverConversationInfo;
    fn conversation_mut(&mut self) -> &mut VoiceOverConversationInfo;
}

impl VoiceOverConversationNodeConfigDataTrait for VoiceOverConversationNodeConfigData {
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode {
        &self.condition_mode
    }
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode {
        &mut self.condition_mode
    }
    fn probability(&self) -> &f32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut f32 {
        &mut self.probability
    }
    fn conversation(&self) -> &VoiceOverConversationInfo {
        &self.conversation
    }
    fn conversation_mut(&mut self) -> &mut VoiceOverConversationInfo {
        &mut self.conversation
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverConversationNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverConversationNodeConfigData {
}

pub static VOICEOVERCONVERSATIONNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverContainerConditionMode",
                rust_offset: offset_of!(VoiceOverConversationNodeConfigData, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationNodeConfigData, probability),
            },
            FieldInfoData {
                name: "Conversation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationInfo",
                rust_offset: offset_of!(VoiceOverConversationNodeConfigData, conversation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationNode {
    pub _glacier_base: VoiceOverStructureNode,
    pub condition: Vec<VoiceOverValueConnection>,
    pub pronunciation_index: VoiceOverValueConnection,
    pub intervals: Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>,
    pub finished_relationship: Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>,
    pub blocked_relationship: Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>,
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub conversation: VoiceOverConversationInfo,
}

pub trait VoiceOverConversationNodeTrait: VoiceOverStructureNodeTrait {
    fn condition(&self) -> &Vec<VoiceOverValueConnection>;
    fn condition_mut(&mut self) -> &mut Vec<VoiceOverValueConnection>;
    fn pronunciation_index(&self) -> &VoiceOverValueConnection;
    fn pronunciation_index_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn finished_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn finished_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn blocked_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn blocked_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode;
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode;
    fn probability(&self) -> &f32;
    fn probability_mut(&mut self) -> &mut f32;
    fn conversation(&self) -> &VoiceOverConversationInfo;
    fn conversation_mut(&mut self) -> &mut VoiceOverConversationInfo;
}

impl VoiceOverConversationNodeTrait for VoiceOverConversationNode {
    fn condition(&self) -> &Vec<VoiceOverValueConnection> {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut Vec<VoiceOverValueConnection> {
        &mut self.condition
    }
    fn pronunciation_index(&self) -> &VoiceOverValueConnection {
        &self.pronunciation_index
    }
    fn pronunciation_index_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.pronunciation_index
    }
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &self.intervals
    }
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &mut self.intervals
    }
    fn finished_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &self.finished_relationship
    }
    fn finished_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &mut self.finished_relationship
    }
    fn blocked_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &self.blocked_relationship
    }
    fn blocked_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &mut self.blocked_relationship
    }
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode {
        &self.condition_mode
    }
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode {
        &mut self.condition_mode
    }
    fn probability(&self) -> &f32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut f32 {
        &mut self.probability
    }
    fn conversation(&self) -> &VoiceOverConversationInfo {
        &self.conversation
    }
    fn conversation_mut(&mut self) -> &mut VoiceOverConversationInfo {
        &mut self.conversation
    }
}

impl VoiceOverStructureNodeTrait for VoiceOverConversationNode {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode()
    }
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode_mut()
    }
}

impl VoiceOverNodeTrait for VoiceOverConversationNode {
}

impl super::core::DataContainerTrait for VoiceOverConversationNode {
}

pub static VOICEOVERCONVERSATIONNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverValueConnection-Array",
                rust_offset: offset_of!(VoiceOverConversationNode, condition),
            },
            FieldInfoData {
                name: "PronunciationIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverConversationNode, pronunciation_index),
            },
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverIntervalNode-Array",
                rust_offset: offset_of!(VoiceOverConversationNode, intervals),
            },
            FieldInfoData {
                name: "FinishedRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverStructureNode-Array",
                rust_offset: offset_of!(VoiceOverConversationNode, finished_relationship),
            },
            FieldInfoData {
                name: "BlockedRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverStructureNode-Array",
                rust_offset: offset_of!(VoiceOverConversationNode, blocked_relationship),
            },
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverContainerConditionMode",
                rust_offset: offset_of!(VoiceOverConversationNode, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationNode, probability),
            },
            FieldInfoData {
                name: "Conversation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationInfo",
                rust_offset: offset_of!(VoiceOverConversationNode, conversation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationInfo {
    pub groups: Vec<Option<Arc<Mutex<dyn VoiceOverDialogGroupTrait>>>>,
    pub tracks: Vec<Option<Arc<Mutex<dyn VoiceOverDialogTrackTrait>>>>,
    pub pronunciations: Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>>,
    pub interrupt_mode: VoiceOverConversationInterruptMode,
    pub priority: i32,
    pub queue_mode: VoiceOverConversationQueueMode,
    pub relevancy: f32,
    pub last_sequence_index: u8,
}

pub trait VoiceOverConversationInfoTrait: TypeObject {
    fn groups(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogGroupTrait>>>>;
    fn groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogGroupTrait>>>>;
    fn tracks(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogTrackTrait>>>>;
    fn tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogTrackTrait>>>>;
    fn pronunciations(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>>;
    fn pronunciations_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>>;
    fn interrupt_mode(&self) -> &VoiceOverConversationInterruptMode;
    fn interrupt_mode_mut(&mut self) -> &mut VoiceOverConversationInterruptMode;
    fn priority(&self) -> &i32;
    fn priority_mut(&mut self) -> &mut i32;
    fn queue_mode(&self) -> &VoiceOverConversationQueueMode;
    fn queue_mode_mut(&mut self) -> &mut VoiceOverConversationQueueMode;
    fn relevancy(&self) -> &f32;
    fn relevancy_mut(&mut self) -> &mut f32;
    fn last_sequence_index(&self) -> &u8;
    fn last_sequence_index_mut(&mut self) -> &mut u8;
}

impl VoiceOverConversationInfoTrait for VoiceOverConversationInfo {
    fn groups(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogGroupTrait>>>> {
        &self.groups
    }
    fn groups_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogGroupTrait>>>> {
        &mut self.groups
    }
    fn tracks(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogTrackTrait>>>> {
        &self.tracks
    }
    fn tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogTrackTrait>>>> {
        &mut self.tracks
    }
    fn pronunciations(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>> {
        &self.pronunciations
    }
    fn pronunciations_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverPronunciationTrait>>>> {
        &mut self.pronunciations
    }
    fn interrupt_mode(&self) -> &VoiceOverConversationInterruptMode {
        &self.interrupt_mode
    }
    fn interrupt_mode_mut(&mut self) -> &mut VoiceOverConversationInterruptMode {
        &mut self.interrupt_mode
    }
    fn priority(&self) -> &i32 {
        &self.priority
    }
    fn priority_mut(&mut self) -> &mut i32 {
        &mut self.priority
    }
    fn queue_mode(&self) -> &VoiceOverConversationQueueMode {
        &self.queue_mode
    }
    fn queue_mode_mut(&mut self) -> &mut VoiceOverConversationQueueMode {
        &mut self.queue_mode
    }
    fn relevancy(&self) -> &f32 {
        &self.relevancy
    }
    fn relevancy_mut(&mut self) -> &mut f32 {
        &mut self.relevancy
    }
    fn last_sequence_index(&self) -> &u8 {
        &self.last_sequence_index
    }
    fn last_sequence_index_mut(&mut self) -> &mut u8 {
        &mut self.last_sequence_index
    }
}

pub static VOICEOVERCONVERSATIONINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Groups",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogGroup-Array",
                rust_offset: offset_of!(VoiceOverConversationInfo, groups),
            },
            FieldInfoData {
                name: "Tracks",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogTrack-Array",
                rust_offset: offset_of!(VoiceOverConversationInfo, tracks),
            },
            FieldInfoData {
                name: "Pronunciations",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverPronunciation-Array",
                rust_offset: offset_of!(VoiceOverConversationInfo, pronunciations),
            },
            FieldInfoData {
                name: "InterruptMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationInterruptMode",
                rust_offset: offset_of!(VoiceOverConversationInfo, interrupt_mode),
            },
            FieldInfoData {
                name: "Priority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoiceOverConversationInfo, priority),
            },
            FieldInfoData {
                name: "QueueMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationQueueMode",
                rust_offset: offset_of!(VoiceOverConversationInfo, queue_mode),
            },
            FieldInfoData {
                name: "Relevancy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConversationInfo, relevancy),
            },
            FieldInfoData {
                name: "LastSequenceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VoiceOverConversationInfo, last_sequence_index),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationInfo {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONVERSATIONINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverConversationQueueMode {
    #[default]
    VoiceOverConversationQueueMode_Always = 0,
    VoiceOverConversationQueueMode_Never = 1,
    VoiceOverConversationQueueMode_SamePriority = 2,
}

pub static VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONVERSATIONQUEUEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverConversationQueueMode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONQUEUEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONVERSATIONQUEUEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationQueueMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationQueueMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverConversationInterruptMode {
    #[default]
    VoiceOverConversationInterruptMode_Disallow = 0,
    VoiceOverConversationInterruptMode_Allow = 1,
    VoiceOverConversationInterruptMode_AllowSame = 2,
}

pub static VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInterruptMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONVERSATIONINTERRUPTMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverConversationInterruptMode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONINTERRUPTMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONVERSATIONINTERRUPTMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationInterruptMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationInterruptMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogGroup {
    pub _glacier_base: super::core::DataContainer,
    pub sound: Option<Arc<Mutex<dyn SoundAssetTrait>>>,
    pub parameters: Vec<VoiceOverDialogSoundParameter>,
    pub output_events: Vec<VoiceOverDialogOutputEvent>,
    pub track_count: u8,
}

pub trait VoiceOverDialogGroupTrait: super::core::DataContainerTrait {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn parameters(&self) -> &Vec<VoiceOverDialogSoundParameter>;
    fn parameters_mut(&mut self) -> &mut Vec<VoiceOverDialogSoundParameter>;
    fn output_events(&self) -> &Vec<VoiceOverDialogOutputEvent>;
    fn output_events_mut(&mut self) -> &mut Vec<VoiceOverDialogOutputEvent>;
    fn track_count(&self) -> &u8;
    fn track_count_mut(&mut self) -> &mut u8;
}

impl VoiceOverDialogGroupTrait for VoiceOverDialogGroup {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &mut self.sound
    }
    fn parameters(&self) -> &Vec<VoiceOverDialogSoundParameter> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<VoiceOverDialogSoundParameter> {
        &mut self.parameters
    }
    fn output_events(&self) -> &Vec<VoiceOverDialogOutputEvent> {
        &self.output_events
    }
    fn output_events_mut(&mut self) -> &mut Vec<VoiceOverDialogOutputEvent> {
        &mut self.output_events
    }
    fn track_count(&self) -> &u8 {
        &self.track_count
    }
    fn track_count_mut(&mut self) -> &mut u8 {
        &mut self.track_count
    }
}

impl super::core::DataContainerTrait for VoiceOverDialogGroup {
}

pub static VOICEOVERDIALOGGROUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogGroup",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogGroup as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(VoiceOverDialogGroup, sound),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogSoundParameter-Array",
                rust_offset: offset_of!(VoiceOverDialogGroup, parameters),
            },
            FieldInfoData {
                name: "OutputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogOutputEvent-Array",
                rust_offset: offset_of!(VoiceOverDialogGroup, output_events),
            },
            FieldInfoData {
                name: "TrackCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VoiceOverDialogGroup, track_count),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogGroup {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGGROUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDIALOGGROUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogGroup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogGroup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogOutputEvent {
    pub event: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
}

pub trait VoiceOverDialogOutputEventTrait: TypeObject {
    fn event(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
}

impl VoiceOverDialogOutputEventTrait for VoiceOverDialogOutputEvent {
    fn event(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.event
    }
}

pub static VOICEOVERDIALOGOUTPUTEVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogOutputEvent",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogOutputEvent as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(VoiceOverDialogOutputEvent, event),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogOutputEvent {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGOUTPUTEVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERDIALOGOUTPUTEVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogOutputEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogOutputEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogSoundParameter {
    pub source: VoiceOverValueConnection,
    pub entity_source_port_id: u32,
    pub target: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub behavior: VoiceOverDialogSoundParameterBehavior,
}

pub trait VoiceOverDialogSoundParameterTrait: TypeObject {
    fn source(&self) -> &VoiceOverValueConnection;
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn entity_source_port_id(&self) -> &u32;
    fn entity_source_port_id_mut(&mut self) -> &mut u32;
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn behavior(&self) -> &VoiceOverDialogSoundParameterBehavior;
    fn behavior_mut(&mut self) -> &mut VoiceOverDialogSoundParameterBehavior;
}

impl VoiceOverDialogSoundParameterTrait for VoiceOverDialogSoundParameter {
    fn source(&self) -> &VoiceOverValueConnection {
        &self.source
    }
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.source
    }
    fn entity_source_port_id(&self) -> &u32 {
        &self.entity_source_port_id
    }
    fn entity_source_port_id_mut(&mut self) -> &mut u32 {
        &mut self.entity_source_port_id
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.target
    }
    fn behavior(&self) -> &VoiceOverDialogSoundParameterBehavior {
        &self.behavior
    }
    fn behavior_mut(&mut self) -> &mut VoiceOverDialogSoundParameterBehavior {
        &mut self.behavior
    }
}

pub static VOICEOVERDIALOGSOUNDPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameter",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogSoundParameter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, source),
            },
            FieldInfoData {
                name: "EntitySourcePortId",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, entity_source_port_id),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, target),
            },
            FieldInfoData {
                name: "Behavior",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverDialogSoundParameterBehavior",
                rust_offset: offset_of!(VoiceOverDialogSoundParameter, behavior),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogSoundParameter {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGSOUNDPARAMETER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERDIALOGSOUNDPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogSoundParameter"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverDialogSoundParameterBehavior {
    #[default]
    VoiceOverDialogSoundParameterBehavior_StartOnly = 0,
    VoiceOverDialogSoundParameterBehavior_Continuous = 1,
}

pub static VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameterBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverDialogSoundParameterBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERDIALOGSOUNDPARAMETERBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogSoundParameterBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogSoundParameterBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogTrack {
    pub _glacier_base: super::core::DataContainer,
    pub source: VoiceOverValueConnection,
    pub take_control: VoiceOverValueConnection,
    pub take_index_mapping: Vec<VoiceOverDialogTakeMapping>,
    pub take_switching: VoiceOverDialogTakeBehavior,
    pub take_switching_on_resume: bool,
    pub parent_track_index: u8,
    pub group_index: u8,
    pub output: Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>,
    pub sampler_node: Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>,
    pub queue_group: Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>,
    pub clips: Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>>,
}

pub trait VoiceOverDialogTrackTrait: super::core::DataContainerTrait {
    fn source(&self) -> &VoiceOverValueConnection;
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn take_control(&self) -> &VoiceOverValueConnection;
    fn take_control_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn take_index_mapping(&self) -> &Vec<VoiceOverDialogTakeMapping>;
    fn take_index_mapping_mut(&mut self) -> &mut Vec<VoiceOverDialogTakeMapping>;
    fn take_switching(&self) -> &VoiceOverDialogTakeBehavior;
    fn take_switching_mut(&mut self) -> &mut VoiceOverDialogTakeBehavior;
    fn take_switching_on_resume(&self) -> &bool;
    fn take_switching_on_resume_mut(&mut self) -> &mut bool;
    fn parent_track_index(&self) -> &u8;
    fn parent_track_index_mut(&mut self) -> &mut u8;
    fn group_index(&self) -> &u8;
    fn group_index_mut(&mut self) -> &mut u8;
    fn output(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn output_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn sampler_node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn sampler_node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn clips(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>>;
    fn clips_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>>;
}

impl VoiceOverDialogTrackTrait for VoiceOverDialogTrack {
    fn source(&self) -> &VoiceOverValueConnection {
        &self.source
    }
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.source
    }
    fn take_control(&self) -> &VoiceOverValueConnection {
        &self.take_control
    }
    fn take_control_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.take_control
    }
    fn take_index_mapping(&self) -> &Vec<VoiceOverDialogTakeMapping> {
        &self.take_index_mapping
    }
    fn take_index_mapping_mut(&mut self) -> &mut Vec<VoiceOverDialogTakeMapping> {
        &mut self.take_index_mapping
    }
    fn take_switching(&self) -> &VoiceOverDialogTakeBehavior {
        &self.take_switching
    }
    fn take_switching_mut(&mut self) -> &mut VoiceOverDialogTakeBehavior {
        &mut self.take_switching
    }
    fn take_switching_on_resume(&self) -> &bool {
        &self.take_switching_on_resume
    }
    fn take_switching_on_resume_mut(&mut self) -> &mut bool {
        &mut self.take_switching_on_resume
    }
    fn parent_track_index(&self) -> &u8 {
        &self.parent_track_index
    }
    fn parent_track_index_mut(&mut self) -> &mut u8 {
        &mut self.parent_track_index
    }
    fn group_index(&self) -> &u8 {
        &self.group_index
    }
    fn group_index_mut(&mut self) -> &mut u8 {
        &mut self.group_index
    }
    fn output(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &self.output
    }
    fn output_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &mut self.output
    }
    fn sampler_node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &self.sampler_node
    }
    fn sampler_node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &mut self.sampler_node
    }
    fn queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &self.queue_group
    }
    fn queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &mut self.queue_group
    }
    fn clips(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>> {
        &self.clips
    }
    fn clips_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>> {
        &mut self.clips
    }
}

impl super::core::DataContainerTrait for VoiceOverDialogTrack {
}

pub static VOICEOVERDIALOGTRACK_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTrack",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogTrack as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDialogTrack, source),
            },
            FieldInfoData {
                name: "TakeControl",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDialogTrack, take_control),
            },
            FieldInfoData {
                name: "TakeIndexMapping",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogTakeMapping-Array",
                rust_offset: offset_of!(VoiceOverDialogTrack, take_index_mapping),
            },
            FieldInfoData {
                name: "TakeSwitching",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverDialogTakeBehavior",
                rust_offset: offset_of!(VoiceOverDialogTrack, take_switching),
            },
            FieldInfoData {
                name: "TakeSwitchingOnResume",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverDialogTrack, take_switching_on_resume),
            },
            FieldInfoData {
                name: "ParentTrackIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VoiceOverDialogTrack, parent_track_index),
            },
            FieldInfoData {
                name: "GroupIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VoiceOverDialogTrack, group_index),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodeData",
                rust_offset: offset_of!(VoiceOverDialogTrack, output),
            },
            FieldInfoData {
                name: "SamplerNode",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodeData",
                rust_offset: offset_of!(VoiceOverDialogTrack, sampler_node),
            },
            FieldInfoData {
                name: "QueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationQueueGroup",
                rust_offset: offset_of!(VoiceOverDialogTrack, queue_group),
            },
            FieldInfoData {
                name: "Clips",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogClip-Array",
                rust_offset: offset_of!(VoiceOverDialogTrack, clips),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogTrack {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGTRACK_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDIALOGTRACK_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTrack-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTrack"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverDialogTakeBehavior {
    #[default]
    VoiceOverDialogTakeBehavior_Start = 0,
    VoiceOverDialogTakeBehavior_Clip = 1,
    VoiceOverDialogTakeBehavior_Continuous = 2,
}

pub static VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeBehavior",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERDIALOGTAKEBEHAVIOR_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverDialogTakeBehavior {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGTAKEBEHAVIOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERDIALOGTAKEBEHAVIOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeBehavior-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTakeBehavior"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogTakeMapping {
    pub take_control_min: f32,
    pub take_control_max: f32,
    pub take_index: u8,
}

pub trait VoiceOverDialogTakeMappingTrait: TypeObject {
    fn take_control_min(&self) -> &f32;
    fn take_control_min_mut(&mut self) -> &mut f32;
    fn take_control_max(&self) -> &f32;
    fn take_control_max_mut(&mut self) -> &mut f32;
    fn take_index(&self) -> &u8;
    fn take_index_mut(&mut self) -> &mut u8;
}

impl VoiceOverDialogTakeMappingTrait for VoiceOverDialogTakeMapping {
    fn take_control_min(&self) -> &f32 {
        &self.take_control_min
    }
    fn take_control_min_mut(&mut self) -> &mut f32 {
        &mut self.take_control_min
    }
    fn take_control_max(&self) -> &f32 {
        &self.take_control_max
    }
    fn take_control_max_mut(&mut self) -> &mut f32 {
        &mut self.take_control_max
    }
    fn take_index(&self) -> &u8 {
        &self.take_index
    }
    fn take_index_mut(&mut self) -> &mut u8 {
        &mut self.take_index
    }
}

pub static VOICEOVERDIALOGTAKEMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeMapping",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogTakeMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TakeControlMin",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDialogTakeMapping, take_control_min),
            },
            FieldInfoData {
                name: "TakeControlMax",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDialogTakeMapping, take_control_max),
            },
            FieldInfoData {
                name: "TakeIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VoiceOverDialogTakeMapping, take_index),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for VoiceOverDialogTakeMapping {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGTAKEMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERDIALOGTAKEMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTakeMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTakeMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogClip {
    pub _glacier_base: super::core::DataContainer,
    pub min_offset: f32,
    pub max_offset: f32,
    pub takes: Vec<VoiceOverDialogTake>,
    pub offset_references: Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>>,
    pub sequence_index: u8,
    pub events: Option<Arc<Mutex<dyn VoiceOverDialogClipEventsTrait>>>,
}

pub trait VoiceOverDialogClipTrait: super::core::DataContainerTrait {
    fn min_offset(&self) -> &f32;
    fn min_offset_mut(&mut self) -> &mut f32;
    fn max_offset(&self) -> &f32;
    fn max_offset_mut(&mut self) -> &mut f32;
    fn takes(&self) -> &Vec<VoiceOverDialogTake>;
    fn takes_mut(&mut self) -> &mut Vec<VoiceOverDialogTake>;
    fn offset_references(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>>;
    fn offset_references_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>>;
    fn sequence_index(&self) -> &u8;
    fn sequence_index_mut(&mut self) -> &mut u8;
    fn events(&self) -> &Option<Arc<Mutex<dyn VoiceOverDialogClipEventsTrait>>>;
    fn events_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverDialogClipEventsTrait>>>;
}

impl VoiceOverDialogClipTrait for VoiceOverDialogClip {
    fn min_offset(&self) -> &f32 {
        &self.min_offset
    }
    fn min_offset_mut(&mut self) -> &mut f32 {
        &mut self.min_offset
    }
    fn max_offset(&self) -> &f32 {
        &self.max_offset
    }
    fn max_offset_mut(&mut self) -> &mut f32 {
        &mut self.max_offset
    }
    fn takes(&self) -> &Vec<VoiceOverDialogTake> {
        &self.takes
    }
    fn takes_mut(&mut self) -> &mut Vec<VoiceOverDialogTake> {
        &mut self.takes
    }
    fn offset_references(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>> {
        &self.offset_references
    }
    fn offset_references_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverDialogClipTrait>>>> {
        &mut self.offset_references
    }
    fn sequence_index(&self) -> &u8 {
        &self.sequence_index
    }
    fn sequence_index_mut(&mut self) -> &mut u8 {
        &mut self.sequence_index
    }
    fn events(&self) -> &Option<Arc<Mutex<dyn VoiceOverDialogClipEventsTrait>>> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverDialogClipEventsTrait>>> {
        &mut self.events
    }
}

impl super::core::DataContainerTrait for VoiceOverDialogClip {
}

pub static VOICEOVERDIALOGCLIP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClip",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogClip as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDialogClip, min_offset),
            },
            FieldInfoData {
                name: "MaxOffset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDialogClip, max_offset),
            },
            FieldInfoData {
                name: "Takes",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogTake-Array",
                rust_offset: offset_of!(VoiceOverDialogClip, takes),
            },
            FieldInfoData {
                name: "OffsetReferences",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverDialogClip-Array",
                rust_offset: offset_of!(VoiceOverDialogClip, offset_references),
            },
            FieldInfoData {
                name: "SequenceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(VoiceOverDialogClip, sequence_index),
            },
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverDialogClipEvents",
                rust_offset: offset_of!(VoiceOverDialogClip, events),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogClip {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGCLIP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDIALOGCLIP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClip-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogClip"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogClipEvents {
    pub _glacier_base: super::core::DataContainer,
    pub started_name_hash: u32,
    pub finished_name_hash: u32,
}

pub trait VoiceOverDialogClipEventsTrait: super::core::DataContainerTrait {
    fn started_name_hash(&self) -> &u32;
    fn started_name_hash_mut(&mut self) -> &mut u32;
    fn finished_name_hash(&self) -> &u32;
    fn finished_name_hash_mut(&mut self) -> &mut u32;
}

impl VoiceOverDialogClipEventsTrait for VoiceOverDialogClipEvents {
    fn started_name_hash(&self) -> &u32 {
        &self.started_name_hash
    }
    fn started_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.started_name_hash
    }
    fn finished_name_hash(&self) -> &u32 {
        &self.finished_name_hash
    }
    fn finished_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.finished_name_hash
    }
}

impl super::core::DataContainerTrait for VoiceOverDialogClipEvents {
}

pub static VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClipEvents",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogClipEvents as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "StartedNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverDialogClipEvents, started_name_hash),
            },
            FieldInfoData {
                name: "FinishedNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverDialogClipEvents, finished_name_hash),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGCLIPEVENTS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogClipEvents {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGCLIPEVENTS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDIALOGCLIPEVENTS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogClipEvents-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogClipEvents"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDialogTake {
    pub wave: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
}

pub trait VoiceOverDialogTakeTrait: TypeObject {
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
}

impl VoiceOverDialogTakeTrait for VoiceOverDialogTake {
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.wave
    }
}

pub static VOICEOVERDIALOGTAKE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTake",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDialogTake as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(VoiceOverDialogTake, wave),
            },
        ],
    }),
    array_type: Some(VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDialogTake {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDIALOGTAKE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERDIALOGTAKE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDialogTake-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDialogTake"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverContainerNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub always_reset_interval: bool,
}

pub trait VoiceOverContainerNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode;
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode;
    fn probability(&self) -> &f32;
    fn probability_mut(&mut self) -> &mut f32;
    fn always_reset_interval(&self) -> &bool;
    fn always_reset_interval_mut(&mut self) -> &mut bool;
}

impl VoiceOverContainerNodeConfigDataTrait for VoiceOverContainerNodeConfigData {
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode {
        &self.condition_mode
    }
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode {
        &mut self.condition_mode
    }
    fn probability(&self) -> &f32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut f32 {
        &mut self.probability
    }
    fn always_reset_interval(&self) -> &bool {
        &self.always_reset_interval
    }
    fn always_reset_interval_mut(&mut self) -> &mut bool {
        &mut self.always_reset_interval
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverContainerNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverContainerNodeConfigData {
}

pub static VOICEOVERCONTAINERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverContainerNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverContainerConditionMode",
                rust_offset: offset_of!(VoiceOverContainerNodeConfigData, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverContainerNodeConfigData, probability),
            },
            FieldInfoData {
                name: "AlwaysResetInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverContainerNodeConfigData, always_reset_interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverContainerNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONTAINERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONTAINERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverContainerNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverContainerNode {
    pub _glacier_base: VoiceOverStructureNode,
    pub condition: Vec<VoiceOverValueConnection>,
    pub intervals: Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>,
    pub true_relationship: Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>,
    pub false_relationship: Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>,
    pub condition_mode: VoiceOverContainerConditionMode,
    pub probability: f32,
    pub always_reset_interval: bool,
}

pub trait VoiceOverContainerNodeTrait: VoiceOverStructureNodeTrait {
    fn condition(&self) -> &Vec<VoiceOverValueConnection>;
    fn condition_mut(&mut self) -> &mut Vec<VoiceOverValueConnection>;
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>>;
    fn true_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn true_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn false_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn false_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>>;
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode;
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode;
    fn probability(&self) -> &f32;
    fn probability_mut(&mut self) -> &mut f32;
    fn always_reset_interval(&self) -> &bool;
    fn always_reset_interval_mut(&mut self) -> &mut bool;
}

impl VoiceOverContainerNodeTrait for VoiceOverContainerNode {
    fn condition(&self) -> &Vec<VoiceOverValueConnection> {
        &self.condition
    }
    fn condition_mut(&mut self) -> &mut Vec<VoiceOverValueConnection> {
        &mut self.condition
    }
    fn intervals(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &self.intervals
    }
    fn intervals_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverIntervalNodeTrait>>>> {
        &mut self.intervals
    }
    fn true_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &self.true_relationship
    }
    fn true_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &mut self.true_relationship
    }
    fn false_relationship(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &self.false_relationship
    }
    fn false_relationship_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>> {
        &mut self.false_relationship
    }
    fn condition_mode(&self) -> &VoiceOverContainerConditionMode {
        &self.condition_mode
    }
    fn condition_mode_mut(&mut self) -> &mut VoiceOverContainerConditionMode {
        &mut self.condition_mode
    }
    fn probability(&self) -> &f32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut f32 {
        &mut self.probability
    }
    fn always_reset_interval(&self) -> &bool {
        &self.always_reset_interval
    }
    fn always_reset_interval_mut(&mut self) -> &mut bool {
        &mut self.always_reset_interval
    }
}

impl VoiceOverStructureNodeTrait for VoiceOverContainerNode {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode()
    }
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode {
        self._glacier_base.flow_mode_mut()
    }
}

impl VoiceOverNodeTrait for VoiceOverContainerNode {
}

impl super::core::DataContainerTrait for VoiceOverContainerNode {
}

pub static VOICEOVERCONTAINERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERSTRUCTURENODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverContainerNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Condition",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverValueConnection-Array",
                rust_offset: offset_of!(VoiceOverContainerNode, condition),
            },
            FieldInfoData {
                name: "Intervals",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverIntervalNode-Array",
                rust_offset: offset_of!(VoiceOverContainerNode, intervals),
            },
            FieldInfoData {
                name: "TrueRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverStructureNode-Array",
                rust_offset: offset_of!(VoiceOverContainerNode, true_relationship),
            },
            FieldInfoData {
                name: "FalseRelationship",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverStructureNode-Array",
                rust_offset: offset_of!(VoiceOverContainerNode, false_relationship),
            },
            FieldInfoData {
                name: "ConditionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverContainerConditionMode",
                rust_offset: offset_of!(VoiceOverContainerNode, condition_mode),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverContainerNode, probability),
            },
            FieldInfoData {
                name: "AlwaysResetInterval",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverContainerNode, always_reset_interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONTAINERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverContainerNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONTAINERNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONTAINERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverContainerNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverContainerConditionMode {
    #[default]
    VoiceOverContainerConditionMode_All = 0,
    VoiceOverContainerConditionMode_Any = 1,
}

pub static VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerConditionMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCONTAINERCONDITIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverContainerConditionMode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONTAINERCONDITIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCONTAINERCONDITIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverContainerConditionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverContainerConditionMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverStructureNode {
    pub _glacier_base: VoiceOverNode,
    pub flow_mode: VoiceOverLogicFlowMode,
}

pub trait VoiceOverStructureNodeTrait: VoiceOverNodeTrait {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode;
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode;
}

impl VoiceOverStructureNodeTrait for VoiceOverStructureNode {
    fn flow_mode(&self) -> &VoiceOverLogicFlowMode {
        &self.flow_mode
    }
    fn flow_mode_mut(&mut self) -> &mut VoiceOverLogicFlowMode {
        &mut self.flow_mode
    }
}

impl VoiceOverNodeTrait for VoiceOverStructureNode {
}

impl super::core::DataContainerTrait for VoiceOverStructureNode {
}

pub static VOICEOVERSTRUCTURENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverStructureNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FlowMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLogicFlowMode",
                rust_offset: offset_of!(VoiceOverStructureNode, flow_mode),
            },
        ],
    }),
    array_type: Some(VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverStructureNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERSTRUCTURENODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERSTRUCTURENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverStructureNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverLogicFlowMode {
    #[default]
    VoiceOverLogicFlowMode_All = 0,
    VoiceOverLogicFlowMode_One = 1,
}

pub static VOICEOVERLOGICFLOWMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERLOGICFLOWMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverLogicFlowMode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLOGICFLOWMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERLOGICFLOWMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLogicFlowMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLogicFlowMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverVariableNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub source: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
}

pub trait VoiceOverVariableNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
}

impl VoiceOverVariableNodeConfigDataTrait for VoiceOverVariableNodeConfigData {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.source
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverVariableNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverVariableNodeConfigData {
}

pub static VOICEOVERVARIABLENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverVariableNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverVariableNodeConfigData, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERVARIABLENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverVariableNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERVARIABLENODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERVARIABLENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverVariableNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverVariableNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub value: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub source: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
}

pub trait VoiceOverVariableNodeTrait: VoiceOverExpressionNodeTrait {
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
}

impl VoiceOverVariableNodeTrait for VoiceOverVariableNode {
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.value
    }
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.value
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.source
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverVariableNode {
}

impl VoiceOverNodeTrait for VoiceOverVariableNode {
}

impl super::core::DataContainerTrait for VoiceOverVariableNode {
}

pub static VOICEOVERVARIABLENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverVariableNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverVariableNode, value),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverVariableNode, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERVARIABLENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverVariableNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERVARIABLENODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERVARIABLENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverVariableNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverVariableNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverProbabilityNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub probability: f32,
}

pub trait VoiceOverProbabilityNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn probability(&self) -> &f32;
    fn probability_mut(&mut self) -> &mut f32;
}

impl VoiceOverProbabilityNodeConfigDataTrait for VoiceOverProbabilityNodeConfigData {
    fn probability(&self) -> &f32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut f32 {
        &mut self.probability
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverProbabilityNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverProbabilityNodeConfigData {
}

pub static VOICEOVERPROBABILITYNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverProbabilityNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverProbabilityNodeConfigData, probability),
            },
        ],
    }),
    array_type: Some(VOICEOVERPROBABILITYNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverProbabilityNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERPROBABILITYNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERPROBABILITYNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverProbabilityNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverProbabilityNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub r#false: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#true: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub probability: f32,
}

pub trait VoiceOverProbabilityNodeTrait: VoiceOverExpressionNodeTrait {
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn probability(&self) -> &f32;
    fn probability_mut(&mut self) -> &mut f32;
}

impl VoiceOverProbabilityNodeTrait for VoiceOverProbabilityNode {
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#false
    }
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#false
    }
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#true
    }
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#true
    }
    fn probability(&self) -> &f32 {
        &self.probability
    }
    fn probability_mut(&mut self) -> &mut f32 {
        &mut self.probability
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverProbabilityNode {
}

impl VoiceOverNodeTrait for VoiceOverProbabilityNode {
}

impl super::core::DataContainerTrait for VoiceOverProbabilityNode {
}

pub static VOICEOVERPROBABILITYNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverProbabilityNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverProbabilityNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverProbabilityNode, r#true),
            },
            FieldInfoData {
                name: "Probability",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverProbabilityNode, probability),
            },
        ],
    }),
    array_type: Some(VOICEOVERPROBABILITYNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverProbabilityNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERPROBABILITYNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERPROBABILITYNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverProbabilityNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverProbabilityNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabelNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub wanted_labels: Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>,
    pub unwanted_labels: Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>,
    pub source_mode: VoiceOverLabelSourceMode,
    pub wanted_compare_mode: VoiceOverLabelCompareMode,
    pub unwanted_compare_mode: VoiceOverLabelCompareMode,
}

pub trait VoiceOverLabelNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn wanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn wanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn unwanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn unwanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn source_mode(&self) -> &VoiceOverLabelSourceMode;
    fn source_mode_mut(&mut self) -> &mut VoiceOverLabelSourceMode;
    fn wanted_compare_mode(&self) -> &VoiceOverLabelCompareMode;
    fn wanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode;
    fn unwanted_compare_mode(&self) -> &VoiceOverLabelCompareMode;
    fn unwanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode;
}

impl VoiceOverLabelNodeConfigDataTrait for VoiceOverLabelNodeConfigData {
    fn wanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &self.wanted_labels
    }
    fn wanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &mut self.wanted_labels
    }
    fn unwanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &self.unwanted_labels
    }
    fn unwanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &mut self.unwanted_labels
    }
    fn source_mode(&self) -> &VoiceOverLabelSourceMode {
        &self.source_mode
    }
    fn source_mode_mut(&mut self) -> &mut VoiceOverLabelSourceMode {
        &mut self.source_mode
    }
    fn wanted_compare_mode(&self) -> &VoiceOverLabelCompareMode {
        &self.wanted_compare_mode
    }
    fn wanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode {
        &mut self.wanted_compare_mode
    }
    fn unwanted_compare_mode(&self) -> &VoiceOverLabelCompareMode {
        &self.unwanted_compare_mode
    }
    fn unwanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode {
        &mut self.unwanted_compare_mode
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverLabelNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverLabelNodeConfigData {
}

pub static VOICEOVERLABELNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabelNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, wanted_labels),
            },
            FieldInfoData {
                name: "UnwantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, unwanted_labels),
            },
            FieldInfoData {
                name: "SourceMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelSourceMode",
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, source_mode),
            },
            FieldInfoData {
                name: "WantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelCompareMode",
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, wanted_compare_mode),
            },
            FieldInfoData {
                name: "UnwantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelCompareMode",
                rust_offset: offset_of!(VoiceOverLabelNodeConfigData, unwanted_compare_mode),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABELNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabelNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub sources: Vec<Option<Arc<Mutex<dyn VoiceOverLabelSourceTrait>>>>,
    pub r#false: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#true: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub wanted_labels: Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>,
    pub unwanted_labels: Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>,
    pub source_mode: VoiceOverLabelSourceMode,
    pub wanted_compare_mode: VoiceOverLabelCompareMode,
    pub unwanted_compare_mode: VoiceOverLabelCompareMode,
}

pub trait VoiceOverLabelNodeTrait: VoiceOverExpressionNodeTrait {
    fn sources(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelSourceTrait>>>>;
    fn sources_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelSourceTrait>>>>;
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn wanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn wanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn unwanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn unwanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn source_mode(&self) -> &VoiceOverLabelSourceMode;
    fn source_mode_mut(&mut self) -> &mut VoiceOverLabelSourceMode;
    fn wanted_compare_mode(&self) -> &VoiceOverLabelCompareMode;
    fn wanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode;
    fn unwanted_compare_mode(&self) -> &VoiceOverLabelCompareMode;
    fn unwanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode;
}

impl VoiceOverLabelNodeTrait for VoiceOverLabelNode {
    fn sources(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelSourceTrait>>>> {
        &self.sources
    }
    fn sources_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelSourceTrait>>>> {
        &mut self.sources
    }
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#false
    }
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#false
    }
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#true
    }
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#true
    }
    fn wanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &self.wanted_labels
    }
    fn wanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &mut self.wanted_labels
    }
    fn unwanted_labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &self.unwanted_labels
    }
    fn unwanted_labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &mut self.unwanted_labels
    }
    fn source_mode(&self) -> &VoiceOverLabelSourceMode {
        &self.source_mode
    }
    fn source_mode_mut(&mut self) -> &mut VoiceOverLabelSourceMode {
        &mut self.source_mode
    }
    fn wanted_compare_mode(&self) -> &VoiceOverLabelCompareMode {
        &self.wanted_compare_mode
    }
    fn wanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode {
        &mut self.wanted_compare_mode
    }
    fn unwanted_compare_mode(&self) -> &VoiceOverLabelCompareMode {
        &self.unwanted_compare_mode
    }
    fn unwanted_compare_mode_mut(&mut self) -> &mut VoiceOverLabelCompareMode {
        &mut self.unwanted_compare_mode
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverLabelNode {
}

impl VoiceOverNodeTrait for VoiceOverLabelNode {
}

impl super::core::DataContainerTrait for VoiceOverLabelNode {
}

pub static VOICEOVERLABELNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabelNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sources",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabelSource-Array",
                rust_offset: offset_of!(VoiceOverLabelNode, sources),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverLabelNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverLabelNode, r#true),
            },
            FieldInfoData {
                name: "WantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(VoiceOverLabelNode, wanted_labels),
            },
            FieldInfoData {
                name: "UnwantedLabels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(VoiceOverLabelNode, unwanted_labels),
            },
            FieldInfoData {
                name: "SourceMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelSourceMode",
                rust_offset: offset_of!(VoiceOverLabelNode, source_mode),
            },
            FieldInfoData {
                name: "WantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelCompareMode",
                rust_offset: offset_of!(VoiceOverLabelNode, wanted_compare_mode),
            },
            FieldInfoData {
                name: "UnwantedCompareMode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLabelCompareMode",
                rust_offset: offset_of!(VoiceOverLabelNode, unwanted_compare_mode),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABELNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabelSource {
    pub _glacier_base: super::core::DataContainer,
    pub source: VoiceOverValueConnection,
}

pub trait VoiceOverLabelSourceTrait: super::core::DataContainerTrait {
    fn source(&self) -> &VoiceOverValueConnection;
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection;
}

impl VoiceOverLabelSourceTrait for VoiceOverLabelSource {
    fn source(&self) -> &VoiceOverValueConnection {
        &self.source
    }
    fn source_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.source
    }
}

impl super::core::DataContainerTrait for VoiceOverLabelSource {
}

pub static VOICEOVERLABELSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSource",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabelSource as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverLabelSource, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabelSource {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELSOURCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABELSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelSource"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverLabelCompareMode {
    #[default]
    VoiceOverLabelCompareMode_Any = 0,
    VoiceOverLabelCompareMode_All = 1,
    VoiceOverLabelCompareMode_One = 2,
}

pub static VOICEOVERLABELCOMPAREMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelCompareMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERLABELCOMPAREMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverLabelCompareMode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELCOMPAREMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERLABELCOMPAREMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelCompareMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelCompareMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverLabelSourceMode {
    #[default]
    VoiceOverLabelSourceMode_Combined = 0,
    VoiceOverLabelSourceMode_Shared = 1,
}

pub static VOICEOVERLABELSOURCEMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSourceMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERLABELSOURCEMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverLabelSourceMode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABELSOURCEMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERLABELSOURCEMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabelSourceMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabelSourceMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverIntervalNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub interval: Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>,
}

pub trait VoiceOverIntervalNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn interval(&self) -> &Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>;
    fn interval_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>;
}

impl VoiceOverIntervalNodeConfigDataTrait for VoiceOverIntervalNodeConfigData {
    fn interval(&self) -> &Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>> {
        &self.interval
    }
    fn interval_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>> {
        &mut self.interval
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverIntervalNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverIntervalNodeConfigData {
}

pub static VOICEOVERINTERVALNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverIntervalNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverInterval",
                rust_offset: offset_of!(VoiceOverIntervalNodeConfigData, interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERINTERVALNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverIntervalNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERINTERVALNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERINTERVALNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverIntervalNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverIntervalNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub threshold: VoiceOverValueConnection,
    pub time: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#false: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#true: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub interval: Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>,
}

pub trait VoiceOverIntervalNodeTrait: VoiceOverExpressionNodeTrait {
    fn threshold(&self) -> &VoiceOverValueConnection;
    fn threshold_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn time(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn time_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn interval(&self) -> &Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>;
    fn interval_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>>;
}

impl VoiceOverIntervalNodeTrait for VoiceOverIntervalNode {
    fn threshold(&self) -> &VoiceOverValueConnection {
        &self.threshold
    }
    fn threshold_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.threshold
    }
    fn time(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.time
    }
    fn time_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.time
    }
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#false
    }
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#false
    }
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#true
    }
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#true
    }
    fn interval(&self) -> &Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>> {
        &self.interval
    }
    fn interval_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverIntervalTrait>>> {
        &mut self.interval
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverIntervalNode {
}

impl VoiceOverNodeTrait for VoiceOverIntervalNode {
}

impl super::core::DataContainerTrait for VoiceOverIntervalNode {
}

pub static VOICEOVERINTERVALNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverIntervalNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverIntervalNode, threshold),
            },
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverIntervalNode, time),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverIntervalNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverIntervalNode, r#true),
            },
            FieldInfoData {
                name: "Interval",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverInterval",
                rust_offset: offset_of!(VoiceOverIntervalNode, interval),
            },
        ],
    }),
    array_type: Some(VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverIntervalNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERINTERVALNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERINTERVALNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverIntervalNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverIntervalNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverInfoNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub field: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
    pub expected_type: Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>,
}

pub trait VoiceOverInfoNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn expected_type(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
    fn expected_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
}

impl VoiceOverInfoNodeConfigDataTrait for VoiceOverInfoNodeConfigData {
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.field
    }
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.field
    }
    fn expected_type(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &self.expected_type
    }
    fn expected_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &mut self.expected_type
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverInfoNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverInfoNodeConfigData {
}

pub static VOICEOVERINFONODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverInfoNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverInfoNodeConfigData, field),
            },
            FieldInfoData {
                name: "ExpectedType",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverObject",
                rust_offset: offset_of!(VoiceOverInfoNodeConfigData, expected_type),
            },
        ],
    }),
    array_type: Some(VOICEOVERINFONODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverInfoNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERINFONODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERINFONODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverInfoNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverInfoNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub object: VoiceOverValueConnection,
    pub value: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub field: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
    pub expected_type: Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>,
}

pub trait VoiceOverInfoNodeTrait: VoiceOverExpressionNodeTrait {
    fn object(&self) -> &VoiceOverValueConnection;
    fn object_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn expected_type(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
    fn expected_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
}

impl VoiceOverInfoNodeTrait for VoiceOverInfoNode {
    fn object(&self) -> &VoiceOverValueConnection {
        &self.object
    }
    fn object_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.object
    }
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.value
    }
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.value
    }
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.field
    }
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.field
    }
    fn expected_type(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &self.expected_type
    }
    fn expected_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &mut self.expected_type
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverInfoNode {
}

impl VoiceOverNodeTrait for VoiceOverInfoNode {
}

impl super::core::DataContainerTrait for VoiceOverInfoNode {
}

pub static VOICEOVERINFONODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverInfoNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverInfoNode, object),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverInfoNode, value),
            },
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverInfoNode, field),
            },
            FieldInfoData {
                name: "ExpectedType",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverObject",
                rust_offset: offset_of!(VoiceOverInfoNode, expected_type),
            },
        ],
    }),
    array_type: Some(VOICEOVERINFONODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverInfoNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERINFONODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERINFONODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInfoNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverInfoNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverGlobalNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub field: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
    pub object: Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>,
}

pub trait VoiceOverGlobalNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn object(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
}

impl VoiceOverGlobalNodeConfigDataTrait for VoiceOverGlobalNodeConfigData {
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.field
    }
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.field
    }
    fn object(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &self.object
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &mut self.object
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverGlobalNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverGlobalNodeConfigData {
}

pub static VOICEOVERGLOBALNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverGlobalNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverGlobalNodeConfigData, field),
            },
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverObject",
                rust_offset: offset_of!(VoiceOverGlobalNodeConfigData, object),
            },
        ],
    }),
    array_type: Some(VOICEOVERGLOBALNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGlobalNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERGLOBALNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERGLOBALNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGlobalNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverGlobalNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub value: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub field: Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>,
    pub object: Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>,
}

pub trait VoiceOverGlobalNodeTrait: VoiceOverExpressionNodeTrait {
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>;
    fn object(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
}

impl VoiceOverGlobalNodeTrait for VoiceOverGlobalNode {
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.value
    }
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.value
    }
    fn field(&self) -> &Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &self.field
    }
    fn field_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>> {
        &mut self.field
    }
    fn object(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &self.object
    }
    fn object_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &mut self.object
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverGlobalNode {
}

impl VoiceOverNodeTrait for VoiceOverGlobalNode {
}

impl super::core::DataContainerTrait for VoiceOverGlobalNode {
}

pub static VOICEOVERGLOBALNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverGlobalNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverGlobalNode, value),
            },
            FieldInfoData {
                name: "Field",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNamedValue",
                rust_offset: offset_of!(VoiceOverGlobalNode, field),
            },
            FieldInfoData {
                name: "Object",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverObject",
                rust_offset: offset_of!(VoiceOverGlobalNode, object),
            },
        ],
    }),
    array_type: Some(VOICEOVERGLOBALNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGlobalNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERGLOBALNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERGLOBALNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGlobalNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDistanceNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub operation: VoiceOverCompareExpressionType,
}

pub trait VoiceOverDistanceNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn operation(&self) -> &VoiceOverCompareExpressionType;
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType;
}

impl VoiceOverDistanceNodeConfigDataTrait for VoiceOverDistanceNodeConfigData {
    fn operation(&self) -> &VoiceOverCompareExpressionType {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType {
        &mut self.operation
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverDistanceNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverDistanceNodeConfigData {
}

pub static VOICEOVERDISTANCENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDistanceNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverCompareExpressionType",
                rust_offset: offset_of!(VoiceOverDistanceNodeConfigData, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERDISTANCENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDistanceNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDISTANCENODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDISTANCENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDistanceNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDistanceNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub a: VoiceOverValueConnection,
    pub b: VoiceOverValueConnection,
    pub threshold: VoiceOverValueConnection,
    pub distance: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#false: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#true: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub operation: VoiceOverCompareExpressionType,
}

pub trait VoiceOverDistanceNodeTrait: VoiceOverExpressionNodeTrait {
    fn a(&self) -> &VoiceOverValueConnection;
    fn a_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn b(&self) -> &VoiceOverValueConnection;
    fn b_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn threshold(&self) -> &VoiceOverValueConnection;
    fn threshold_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn distance(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn distance_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn operation(&self) -> &VoiceOverCompareExpressionType;
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType;
}

impl VoiceOverDistanceNodeTrait for VoiceOverDistanceNode {
    fn a(&self) -> &VoiceOverValueConnection {
        &self.a
    }
    fn a_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.a
    }
    fn b(&self) -> &VoiceOverValueConnection {
        &self.b
    }
    fn b_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.b
    }
    fn threshold(&self) -> &VoiceOverValueConnection {
        &self.threshold
    }
    fn threshold_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.threshold
    }
    fn distance(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.distance
    }
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#false
    }
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#false
    }
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#true
    }
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#true
    }
    fn operation(&self) -> &VoiceOverCompareExpressionType {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType {
        &mut self.operation
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverDistanceNode {
}

impl VoiceOverNodeTrait for VoiceOverDistanceNode {
}

impl super::core::DataContainerTrait for VoiceOverDistanceNode {
}

pub static VOICEOVERDISTANCENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDistanceNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDistanceNode, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDistanceNode, b),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDistanceNode, threshold),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverDistanceNode, distance),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverDistanceNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverDistanceNode, r#true),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverCompareExpressionType",
                rust_offset: offset_of!(VoiceOverDistanceNode, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERDISTANCENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverDistanceNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDISTANCENODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDISTANCENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDistanceNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDistanceNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDebugValueNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub name: String,
    pub color: super::core::Vec3,
    pub display_time: f32,
    pub enabled: bool,
}

pub trait VoiceOverDebugValueNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn display_time(&self) -> &f32;
    fn display_time_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl VoiceOverDebugValueNodeConfigDataTrait for VoiceOverDebugValueNodeConfigData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn display_time(&self) -> &f32 {
        &self.display_time
    }
    fn display_time_mut(&mut self) -> &mut f32 {
        &mut self.display_time
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverDebugValueNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverDebugValueNodeConfigData {
}

pub static VOICEOVERDEBUGVALUENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDebugValueNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, name),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, color),
            },
            FieldInfoData {
                name: "DisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, display_time),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverDebugValueNodeConfigData, enabled),
            },
        ],
    }),
    array_type: Some(VOICEOVERDEBUGVALUENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverDebugValueNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDEBUGVALUENODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDEBUGVALUENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDebugValueNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverDebugValueNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub r#in: VoiceOverValueConnection,
    pub out: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub value_name: String,
    pub plot: bool,
    pub min: f32,
    pub max: f32,
    pub color: super::core::Vec3,
    pub display_time: f32,
    pub enabled: bool,
}

pub trait VoiceOverDebugValueNodeTrait: VoiceOverExpressionNodeTrait {
    fn r#in(&self) -> &VoiceOverValueConnection;
    fn r#in_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn out(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn out_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn value_name(&self) -> &String;
    fn value_name_mut(&mut self) -> &mut String;
    fn plot(&self) -> &bool;
    fn plot_mut(&mut self) -> &mut bool;
    fn min(&self) -> &f32;
    fn min_mut(&mut self) -> &mut f32;
    fn max(&self) -> &f32;
    fn max_mut(&mut self) -> &mut f32;
    fn color(&self) -> &super::core::Vec3;
    fn color_mut(&mut self) -> &mut super::core::Vec3;
    fn display_time(&self) -> &f32;
    fn display_time_mut(&mut self) -> &mut f32;
    fn enabled(&self) -> &bool;
    fn enabled_mut(&mut self) -> &mut bool;
}

impl VoiceOverDebugValueNodeTrait for VoiceOverDebugValueNode {
    fn r#in(&self) -> &VoiceOverValueConnection {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.r#in
    }
    fn out(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.out
    }
    fn out_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.out
    }
    fn value_name(&self) -> &String {
        &self.value_name
    }
    fn value_name_mut(&mut self) -> &mut String {
        &mut self.value_name
    }
    fn plot(&self) -> &bool {
        &self.plot
    }
    fn plot_mut(&mut self) -> &mut bool {
        &mut self.plot
    }
    fn min(&self) -> &f32 {
        &self.min
    }
    fn min_mut(&mut self) -> &mut f32 {
        &mut self.min
    }
    fn max(&self) -> &f32 {
        &self.max
    }
    fn max_mut(&mut self) -> &mut f32 {
        &mut self.max
    }
    fn color(&self) -> &super::core::Vec3 {
        &self.color
    }
    fn color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.color
    }
    fn display_time(&self) -> &f32 {
        &self.display_time
    }
    fn display_time_mut(&mut self) -> &mut f32 {
        &mut self.display_time
    }
    fn enabled(&self) -> &bool {
        &self.enabled
    }
    fn enabled_mut(&mut self) -> &mut bool {
        &mut self.enabled
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverDebugValueNode {
}

impl VoiceOverNodeTrait for VoiceOverDebugValueNode {
}

impl super::core::DataContainerTrait for VoiceOverDebugValueNode {
}

pub static VOICEOVERDEBUGVALUENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverDebugValueNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverDebugValueNode, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverDebugValueNode, out),
            },
            FieldInfoData {
                name: "ValueName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverDebugValueNode, value_name),
            },
            FieldInfoData {
                name: "Plot",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverDebugValueNode, plot),
            },
            FieldInfoData {
                name: "Min",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDebugValueNode, min),
            },
            FieldInfoData {
                name: "Max",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDebugValueNode, max),
            },
            FieldInfoData {
                name: "Color",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(VoiceOverDebugValueNode, color),
            },
            FieldInfoData {
                name: "DisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverDebugValueNode, display_time),
            },
            FieldInfoData {
                name: "Enabled",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverDebugValueNode, enabled),
            },
        ],
    }),
    array_type: Some(VOICEOVERDEBUGVALUENODE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverDebugValueNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERDEBUGVALUENODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERDEBUGVALUENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverDebugValueNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverDebugValueNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub source: Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>,
}

pub trait VoiceOverConstantNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
}

impl VoiceOverConstantNodeConfigDataTrait for VoiceOverConstantNodeConfigData {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &mut self.source
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverConstantNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverConstantNodeConfigData {
}

pub static VOICEOVERCONSTANTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConstantValue",
                rust_offset: offset_of!(VoiceOverConstantNodeConfigData, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub value: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub source: Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>,
}

pub trait VoiceOverConstantNodeTrait: VoiceOverExpressionNodeTrait {
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
}

impl VoiceOverConstantNodeTrait for VoiceOverConstantNode {
    fn value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.value
    }
    fn value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.value
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &mut self.source
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverConstantNode {
}

impl VoiceOverNodeTrait for VoiceOverConstantNode {
}

impl super::core::DataContainerTrait for VoiceOverConstantNode {
}

pub static VOICEOVERCONSTANTNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverConstantNode, value),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConstantValue",
                rust_offset: offset_of!(VoiceOverConstantNode, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantVectorValue {
    pub _glacier_base: VoiceOverConstantValue,
    pub value: super::core::Vec4,
}

pub trait VoiceOverConstantVectorValueTrait: VoiceOverConstantValueTrait {
    fn value(&self) -> &super::core::Vec4;
    fn value_mut(&mut self) -> &mut super::core::Vec4;
}

impl VoiceOverConstantVectorValueTrait for VoiceOverConstantVectorValue {
    fn value(&self) -> &super::core::Vec4 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut super::core::Vec4 {
        &mut self.value
    }
}

impl VoiceOverConstantValueTrait for VoiceOverConstantVectorValue {
}

impl super::core::DataContainerTrait for VoiceOverConstantVectorValue {
}

pub static VOICEOVERCONSTANTVECTORVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantVectorValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantVectorValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec4",
                rust_offset: offset_of!(VoiceOverConstantVectorValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTVECTORVALUE_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for VoiceOverConstantVectorValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTVECTORVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTVECTORVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantVectorValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantVectorValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantGlobalValue {
    pub _glacier_base: VoiceOverConstantValue,
    pub source: Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>,
}

pub trait VoiceOverConstantGlobalValueTrait: VoiceOverConstantValueTrait {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>>;
}

impl VoiceOverConstantGlobalValueTrait for VoiceOverConstantGlobalValue {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverGlobalConstantValueTrait>>> {
        &mut self.source
    }
}

impl VoiceOverConstantValueTrait for VoiceOverConstantGlobalValue {
}

impl super::core::DataContainerTrait for VoiceOverConstantGlobalValue {
}

pub static VOICEOVERCONSTANTGLOBALVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantGlobalValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantGlobalValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverGlobalConstantValue",
                rust_offset: offset_of!(VoiceOverConstantGlobalValue, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTGLOBALVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantGlobalValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTGLOBALVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTGLOBALVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantGlobalValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantGlobalValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantFloatValue {
    pub _glacier_base: VoiceOverConstantValue,
    pub value: f32,
}

pub trait VoiceOverConstantFloatValueTrait: VoiceOverConstantValueTrait {
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl VoiceOverConstantFloatValueTrait for VoiceOverConstantFloatValue {
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

impl VoiceOverConstantValueTrait for VoiceOverConstantFloatValue {
}

impl super::core::DataContainerTrait for VoiceOverConstantFloatValue {
}

pub static VOICEOVERCONSTANTFLOATVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantFloatValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantFloatValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VoiceOverConstantFloatValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTFLOATVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantFloatValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTFLOATVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTFLOATVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantFloatValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantFloatValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantIntegerValue {
    pub _glacier_base: VoiceOverConstantValue,
    pub value: i32,
}

pub trait VoiceOverConstantIntegerValueTrait: VoiceOverConstantValueTrait {
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl VoiceOverConstantIntegerValueTrait for VoiceOverConstantIntegerValue {
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

impl VoiceOverConstantValueTrait for VoiceOverConstantIntegerValue {
}

impl super::core::DataContainerTrait for VoiceOverConstantIntegerValue {
}

pub static VOICEOVERCONSTANTINTEGERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantIntegerValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantIntegerValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VoiceOverConstantIntegerValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTINTEGERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantIntegerValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTINTEGERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTINTEGERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantIntegerValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantIntegerValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantBooleanValue {
    pub _glacier_base: VoiceOverConstantValue,
    pub value: bool,
}

pub trait VoiceOverConstantBooleanValueTrait: VoiceOverConstantValueTrait {
    fn value(&self) -> &bool;
    fn value_mut(&mut self) -> &mut bool;
}

impl VoiceOverConstantBooleanValueTrait for VoiceOverConstantBooleanValue {
    fn value(&self) -> &bool {
        &self.value
    }
    fn value_mut(&mut self) -> &mut bool {
        &mut self.value
    }
}

impl VoiceOverConstantValueTrait for VoiceOverConstantBooleanValue {
}

impl super::core::DataContainerTrait for VoiceOverConstantBooleanValue {
}

pub static VOICEOVERCONSTANTBOOLEANVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantBooleanValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERCONSTANTVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantBooleanValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VoiceOverConstantBooleanValue, value),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTBOOLEANVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantBooleanValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTBOOLEANVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTBOOLEANVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantBooleanValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantBooleanValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverGlobalConstantValue {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub source: Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>,
}

pub trait VoiceOverGlobalConstantValueTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>>;
}

impl VoiceOverGlobalConstantValueTrait for VoiceOverGlobalConstantValue {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConstantValueTrait>>> {
        &mut self.source
    }
}

impl super::core::DataContainerTrait for VoiceOverGlobalConstantValue {
}

pub static VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalConstantValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverGlobalConstantValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverGlobalConstantValue, name),
            },
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConstantValue",
                rust_offset: offset_of!(VoiceOverGlobalConstantValue, source),
            },
        ],
    }),
    array_type: Some(VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverGlobalConstantValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERGLOBALCONSTANTVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERGLOBALCONSTANTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverGlobalConstantValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverGlobalConstantValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConstantValue {
    pub _glacier_base: super::core::DataContainer,
}

pub trait VoiceOverConstantValueTrait: super::core::DataContainerTrait {
}

impl VoiceOverConstantValueTrait for VoiceOverConstantValue {
}

impl super::core::DataContainerTrait for VoiceOverConstantValue {
}

pub static VOICEOVERCONSTANTVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConstantValue as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERCONSTANTVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConstantValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONSTANTVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONSTANTVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConstantValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConstantValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverCompareNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub operation: VoiceOverCompareExpressionType,
}

pub trait VoiceOverCompareNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn operation(&self) -> &VoiceOverCompareExpressionType;
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType;
}

impl VoiceOverCompareNodeConfigDataTrait for VoiceOverCompareNodeConfigData {
    fn operation(&self) -> &VoiceOverCompareExpressionType {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType {
        &mut self.operation
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverCompareNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverCompareNodeConfigData {
}

pub static VOICEOVERCOMPARENODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverCompareNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverCompareExpressionType",
                rust_offset: offset_of!(VoiceOverCompareNodeConfigData, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCOMPARENODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverCompareNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCOMPARENODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCOMPARENODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverCompareNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverCompareNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub a: VoiceOverValueConnection,
    pub b: VoiceOverValueConnection,
    pub r#false: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub r#true: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub operation: VoiceOverCompareExpressionType,
}

pub trait VoiceOverCompareNodeTrait: VoiceOverExpressionNodeTrait {
    fn a(&self) -> &VoiceOverValueConnection;
    fn a_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn b(&self) -> &VoiceOverValueConnection;
    fn b_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn operation(&self) -> &VoiceOverCompareExpressionType;
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType;
}

impl VoiceOverCompareNodeTrait for VoiceOverCompareNode {
    fn a(&self) -> &VoiceOverValueConnection {
        &self.a
    }
    fn a_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.a
    }
    fn b(&self) -> &VoiceOverValueConnection {
        &self.b
    }
    fn b_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.b
    }
    fn r#false(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#false
    }
    fn r#false_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#false
    }
    fn r#true(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.r#true
    }
    fn r#true_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.r#true
    }
    fn operation(&self) -> &VoiceOverCompareExpressionType {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut VoiceOverCompareExpressionType {
        &mut self.operation
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverCompareNode {
}

impl VoiceOverNodeTrait for VoiceOverCompareNode {
}

impl super::core::DataContainerTrait for VoiceOverCompareNode {
}

pub static VOICEOVERCOMPARENODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverCompareNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverCompareNode, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverCompareNode, b),
            },
            FieldInfoData {
                name: "False",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverCompareNode, r#false),
            },
            FieldInfoData {
                name: "True",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverCompareNode, r#true),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverCompareExpressionType",
                rust_offset: offset_of!(VoiceOverCompareNode, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERCOMPARENODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverCompareNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCOMPARENODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCOMPARENODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverCompareNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverCompareExpressionType {
    #[default]
    VoiceOverCompareExpressionType_Equals = 0,
    VoiceOverCompareExpressionType_Differs = 1,
    VoiceOverCompareExpressionType_Greater = 2,
    VoiceOverCompareExpressionType_Less = 3,
    VoiceOverCompareExpressionType_GreaterOrEquals = 4,
    VoiceOverCompareExpressionType_LessOrEquals = 5,
}

pub static VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareExpressionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERCOMPAREEXPRESSIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverCompareExpressionType {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCOMPAREEXPRESSIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERCOMPAREEXPRESSIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverCompareExpressionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverCompareExpressionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverArithmeticNodeConfigData {
    pub _glacier_base: VoiceOverNodeConfigData,
    pub operation: VoiceOverArithmeticExpressionType,
}

pub trait VoiceOverArithmeticNodeConfigDataTrait: VoiceOverNodeConfigDataTrait {
    fn operation(&self) -> &VoiceOverArithmeticExpressionType;
    fn operation_mut(&mut self) -> &mut VoiceOverArithmeticExpressionType;
}

impl VoiceOverArithmeticNodeConfigDataTrait for VoiceOverArithmeticNodeConfigData {
    fn operation(&self) -> &VoiceOverArithmeticExpressionType {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut VoiceOverArithmeticExpressionType {
        &mut self.operation
    }
}

impl VoiceOverNodeConfigDataTrait for VoiceOverArithmeticNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        self._glacier_base.node_mut()
    }
}

impl super::core::DataContainerTrait for VoiceOverArithmeticNodeConfigData {
}

pub static VOICEOVERARITHMETICNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverArithmeticNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverArithmeticExpressionType",
                rust_offset: offset_of!(VoiceOverArithmeticNodeConfigData, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERARITHMETICNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverArithmeticNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERARITHMETICNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERARITHMETICNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverArithmeticNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverArithmeticNode {
    pub _glacier_base: VoiceOverExpressionNode,
    pub a: VoiceOverValueConnection,
    pub b: VoiceOverValueConnection,
    pub result: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub operation: VoiceOverArithmeticExpressionType,
}

pub trait VoiceOverArithmeticNodeTrait: VoiceOverExpressionNodeTrait {
    fn a(&self) -> &VoiceOverValueConnection;
    fn a_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn b(&self) -> &VoiceOverValueConnection;
    fn b_mut(&mut self) -> &mut VoiceOverValueConnection;
    fn result(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn operation(&self) -> &VoiceOverArithmeticExpressionType;
    fn operation_mut(&mut self) -> &mut VoiceOverArithmeticExpressionType;
}

impl VoiceOverArithmeticNodeTrait for VoiceOverArithmeticNode {
    fn a(&self) -> &VoiceOverValueConnection {
        &self.a
    }
    fn a_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.a
    }
    fn b(&self) -> &VoiceOverValueConnection {
        &self.b
    }
    fn b_mut(&mut self) -> &mut VoiceOverValueConnection {
        &mut self.b
    }
    fn result(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.result
    }
    fn result_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.result
    }
    fn operation(&self) -> &VoiceOverArithmeticExpressionType {
        &self.operation
    }
    fn operation_mut(&mut self) -> &mut VoiceOverArithmeticExpressionType {
        &mut self.operation
    }
}

impl VoiceOverExpressionNodeTrait for VoiceOverArithmeticNode {
}

impl VoiceOverNodeTrait for VoiceOverArithmeticNode {
}

impl super::core::DataContainerTrait for VoiceOverArithmeticNode {
}

pub static VOICEOVERARITHMETICNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVEREXPRESSIONNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverArithmeticNode as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "A",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverArithmeticNode, a),
            },
            FieldInfoData {
                name: "B",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueConnection",
                rust_offset: offset_of!(VoiceOverArithmeticNode, b),
            },
            FieldInfoData {
                name: "Result",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverArithmeticNode, result),
            },
            FieldInfoData {
                name: "Operation",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverArithmeticExpressionType",
                rust_offset: offset_of!(VoiceOverArithmeticNode, operation),
            },
        ],
    }),
    array_type: Some(VOICEOVERARITHMETICNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverArithmeticNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERARITHMETICNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERARITHMETICNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverArithmeticNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverArithmeticExpressionType {
    #[default]
    VoiceOverArithmeticExpressionType_Addition = 0,
    VoiceOverArithmeticExpressionType_Subtraction = 1,
    VoiceOverArithmeticExpressionType_Multiplication = 2,
    VoiceOverArithmeticExpressionType_Division = 3,
    VoiceOverArithmeticExpressionType_Difference = 4,
}

pub static VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticExpressionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERARITHMETICEXPRESSIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverArithmeticExpressionType {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERARITHMETICEXPRESSIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERARITHMETICEXPRESSIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverArithmeticExpressionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverArithmeticExpressionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverStructureConnection {
    pub _glacier_base: super::core::DataContainer,
    pub target_node: Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>,
    pub target_input: Option<Arc<Mutex<dyn VoiceOverRelationshipInputTrait>>>,
}

pub trait VoiceOverStructureConnectionTrait: super::core::DataContainerTrait {
    fn target_node(&self) -> &Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>;
    fn target_node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>>;
    fn target_input(&self) -> &Option<Arc<Mutex<dyn VoiceOverRelationshipInputTrait>>>;
    fn target_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverRelationshipInputTrait>>>;
}

impl VoiceOverStructureConnectionTrait for VoiceOverStructureConnection {
    fn target_node(&self) -> &Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>> {
        &self.target_node
    }
    fn target_node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverStructureNodeTrait>>> {
        &mut self.target_node
    }
    fn target_input(&self) -> &Option<Arc<Mutex<dyn VoiceOverRelationshipInputTrait>>> {
        &self.target_input
    }
    fn target_input_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverRelationshipInputTrait>>> {
        &mut self.target_input
    }
}

impl super::core::DataContainerTrait for VoiceOverStructureConnection {
}

pub static VOICEOVERSTRUCTURECONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureConnection",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverStructureConnection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetNode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverStructureNode",
                rust_offset: offset_of!(VoiceOverStructureConnection, target_node),
            },
            FieldInfoData {
                name: "TargetInput",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverRelationshipInput",
                rust_offset: offset_of!(VoiceOverStructureConnection, target_input),
            },
        ],
    }),
    array_type: Some(VOICEOVERSTRUCTURECONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverStructureConnection {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERSTRUCTURECONNECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERSTRUCTURECONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverStructureConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverStructureConnection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverRelationshipInput {
    pub _glacier_base: super::core::DataContainer,
}

pub trait VoiceOverRelationshipInputTrait: super::core::DataContainerTrait {
}

impl VoiceOverRelationshipInputTrait for VoiceOverRelationshipInput {
}

impl super::core::DataContainerTrait for VoiceOverRelationshipInput {
}

pub static VOICEOVERRELATIONSHIPINPUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRelationshipInput",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverRelationshipInput as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERRELATIONSHIPINPUT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverRelationshipInput {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERRELATIONSHIPINPUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERRELATIONSHIPINPUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverRelationshipInput-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverRelationshipInput"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverValueConnection {
    pub target_node: Option<Arc<Mutex<dyn VoiceOverExpressionNodeTrait>>>,
    pub target_value: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
}

pub trait VoiceOverValueConnectionTrait: TypeObject {
    fn target_node(&self) -> &Option<Arc<Mutex<dyn VoiceOverExpressionNodeTrait>>>;
    fn target_node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverExpressionNodeTrait>>>;
    fn target_value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn target_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
}

impl VoiceOverValueConnectionTrait for VoiceOverValueConnection {
    fn target_node(&self) -> &Option<Arc<Mutex<dyn VoiceOverExpressionNodeTrait>>> {
        &self.target_node
    }
    fn target_node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverExpressionNodeTrait>>> {
        &mut self.target_node
    }
    fn target_value(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.target_value
    }
    fn target_value_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.target_value
    }
}

pub static VOICEOVERVALUECONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueConnection",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverValueConnection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TargetNode",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverExpressionNode",
                rust_offset: offset_of!(VoiceOverValueConnection, target_node),
            },
            FieldInfoData {
                name: "TargetValue",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverValueConnection, target_value),
            },
        ],
    }),
    array_type: Some(VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverValueConnection {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERVALUECONNECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERVALUECONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValueConnection"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverExpressionNode {
    pub _glacier_base: VoiceOverNode,
}

pub trait VoiceOverExpressionNodeTrait: VoiceOverNodeTrait {
}

impl VoiceOverExpressionNodeTrait for VoiceOverExpressionNode {
}

impl VoiceOverNodeTrait for VoiceOverExpressionNode {
}

impl super::core::DataContainerTrait for VoiceOverExpressionNode {
}

pub static VOICEOVEREXPRESSIONNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverExpressionNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNODE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverExpressionNode as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVEREXPRESSIONNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverExpressionNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEREXPRESSIONNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEREXPRESSIONNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverExpressionNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverExpressionNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EntityVoiceOverInfo {
    pub _glacier_base: super::core::DataContainer,
    pub voice_over_type: Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>,
    pub labels: Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>,
}

pub trait EntityVoiceOverInfoTrait: super::core::DataContainerTrait {
    fn voice_over_type(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
    fn voice_over_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>>;
    fn labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
    fn labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>>;
}

impl EntityVoiceOverInfoTrait for EntityVoiceOverInfo {
    fn voice_over_type(&self) -> &Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &self.voice_over_type
    }
    fn voice_over_type_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverObjectTrait>>> {
        &mut self.voice_over_type
    }
    fn labels(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &self.labels
    }
    fn labels_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverLabelTrait>>>> {
        &mut self.labels
    }
}

impl super::core::DataContainerTrait for EntityVoiceOverInfo {
}

pub static ENTITYVOICEOVERINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityVoiceOverInfo",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EntityVoiceOverInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "VoiceOverType",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverObject",
                rust_offset: offset_of!(EntityVoiceOverInfo, voice_over_type),
            },
            FieldInfoData {
                name: "Labels",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverLabel-Array",
                rust_offset: offset_of!(EntityVoiceOverInfo, labels),
            },
        ],
    }),
    array_type: Some(ENTITYVOICEOVERINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EntityVoiceOverInfo {
    fn type_info(&self) -> &'static TypeInfo {
        ENTITYVOICEOVERINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENTITYVOICEOVERINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EntityVoiceOverInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EntityVoiceOverInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverInterval {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub name_hash: u32,
}

pub trait VoiceOverIntervalTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
}

impl VoiceOverIntervalTrait for VoiceOverInterval {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
}

impl super::core::DataContainerTrait for VoiceOverInterval {
}

pub static VOICEOVERINTERVAL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInterval",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverInterval as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverInterval, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverInterval, name_hash),
            },
        ],
    }),
    array_type: Some(VOICEOVERINTERVAL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverInterval {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERINTERVAL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERINTERVAL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverInterval-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverInterval"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverLabel {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub name_hash: u32,
}

pub trait VoiceOverLabelTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
}

impl VoiceOverLabelTrait for VoiceOverLabel {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
}

impl super::core::DataContainerTrait for VoiceOverLabel {
}

pub static VOICEOVERLABEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabel",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverLabel as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverLabel, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverLabel, name_hash),
            },
        ],
    }),
    array_type: Some(VOICEOVERLABEL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverLabel {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERLABEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERLABEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverLabel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverLabel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverValueRedirect {
    pub _glacier_base: super::core::DataContainer,
    pub source: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
    pub target: Option<Arc<Mutex<dyn VoiceOverValueTrait>>>,
}

pub trait VoiceOverValueRedirectTrait: super::core::DataContainerTrait {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn target(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>>;
}

impl VoiceOverValueRedirectTrait for VoiceOverValueRedirect {
    fn source(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.source
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverValueTrait>>> {
        &mut self.target
    }
}

impl super::core::DataContainerTrait for VoiceOverValueRedirect {
}

pub static VOICEOVERVALUEREDIRECT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueRedirect",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverValueRedirect as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverValueRedirect, source),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValue",
                rust_offset: offset_of!(VoiceOverValueRedirect, target),
            },
        ],
    }),
    array_type: Some(VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverValueRedirect {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERVALUEREDIRECT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERVALUEREDIRECT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueRedirect-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValueRedirect"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverNodeConfigData {
    pub _glacier_base: super::core::DataContainer,
    pub node: Option<Arc<Mutex<dyn VoiceOverNodeTrait>>>,
}

pub trait VoiceOverNodeConfigDataTrait: super::core::DataContainerTrait {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>>;
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>>;
}

impl VoiceOverNodeConfigDataTrait for VoiceOverNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        &self.node
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverNodeTrait>>> {
        &mut self.node
    }
}

impl super::core::DataContainerTrait for VoiceOverNodeConfigData {
}

pub static VOICEOVERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Node",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverNode",
                rust_offset: offset_of!(VoiceOverNodeConfigData, node),
            },
        ],
    }),
    array_type: Some(VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverNode {
    pub _glacier_base: super::core::DataContainer,
}

pub trait VoiceOverNodeTrait: super::core::DataContainerTrait {
}

impl VoiceOverNodeTrait for VoiceOverNode {
}

impl super::core::DataContainerTrait for VoiceOverNode {
}

pub static VOICEOVERNODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNode",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverNode as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERNODE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverNode {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERNODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERNODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverNode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverEvent {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub name_hash: u32,
    pub parameters: Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>>,
    pub owner: Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>,
}

pub trait VoiceOverEventTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>>;
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>>;
    fn owner(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>;
    fn owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>>;
}

impl VoiceOverEventTrait for VoiceOverEvent {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>> {
        &mut self.parameters
    }
    fn owner(&self) -> &Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>> {
        &self.owner
    }
    fn owner_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverLogicAssetTrait>>> {
        &mut self.owner
    }
}

impl super::core::DataContainerTrait for VoiceOverEvent {
}

pub static VOICEOVEREVENT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEvent",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverEvent as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverEvent, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverEvent, name_hash),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverNamedValue-Array",
                rust_offset: offset_of!(VoiceOverEvent, parameters),
            },
            FieldInfoData {
                name: "Owner",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverLogicAsset",
                rust_offset: offset_of!(VoiceOverEvent, owner),
            },
        ],
    }),
    array_type: Some(VOICEOVEREVENT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverEvent {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEREVENT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEREVENT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverEvent-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverEvent"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverObject {
    pub _glacier_base: VoiceOverNamedValue,
    pub properties: Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>>,
}

pub trait VoiceOverObjectTrait: VoiceOverNamedValueTrait {
    fn properties(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>>;
    fn properties_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>>;
}

impl VoiceOverObjectTrait for VoiceOverObject {
    fn properties(&self) -> &Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>> {
        &self.properties
    }
    fn properties_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn VoiceOverNamedValueTrait>>>> {
        &mut self.properties
    }
}

impl VoiceOverNamedValueTrait for VoiceOverObject {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
    fn value_type(&self) -> &VoiceOverValueType {
        self._glacier_base.value_type()
    }
    fn value_type_mut(&mut self) -> &mut VoiceOverValueType {
        self._glacier_base.value_type_mut()
    }
}

impl VoiceOverValueTrait for VoiceOverObject {
}

impl super::core::DataContainerTrait for VoiceOverObject {
}

pub static VOICEOVEROBJECT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObject",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERNAMEDVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverObject as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Properties",
                flags: MemberInfoFlags::new(144),
                field_type: "VoiceOverNamedValue-Array",
                rust_offset: offset_of!(VoiceOverObject, properties),
            },
        ],
    }),
    array_type: Some(VOICEOVEROBJECT_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverObject {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVEROBJECT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVEROBJECT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverObject-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverObject"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverNamedValue {
    pub _glacier_base: VoiceOverValue,
    pub name: String,
    pub name_hash: u32,
    pub value_type: VoiceOverValueType,
}

pub trait VoiceOverNamedValueTrait: VoiceOverValueTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn value_type(&self) -> &VoiceOverValueType;
    fn value_type_mut(&mut self) -> &mut VoiceOverValueType;
}

impl VoiceOverNamedValueTrait for VoiceOverNamedValue {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn value_type(&self) -> &VoiceOverValueType {
        &self.value_type
    }
    fn value_type_mut(&mut self) -> &mut VoiceOverValueType {
        &mut self.value_type
    }
}

impl VoiceOverValueTrait for VoiceOverNamedValue {
}

impl super::core::DataContainerTrait for VoiceOverNamedValue {
}

pub static VOICEOVERNAMEDVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNamedValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(VOICEOVERVALUE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverNamedValue as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(VoiceOverNamedValue, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(VoiceOverNamedValue, name_hash),
            },
            FieldInfoData {
                name: "ValueType",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverValueType",
                rust_offset: offset_of!(VoiceOverNamedValue, value_type),
            },
        ],
    }),
    array_type: Some(VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverNamedValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERNAMEDVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERNAMEDVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverNamedValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverNamedValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverValue {
    pub _glacier_base: super::core::DataContainer,
}

pub trait VoiceOverValueTrait: super::core::DataContainerTrait {
}

impl VoiceOverValueTrait for VoiceOverValue {
}

impl super::core::DataContainerTrait for VoiceOverValue {
}

pub static VOICEOVERVALUE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValue",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverValue as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(VOICEOVERVALUE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverValue {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERVALUE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERVALUE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValue-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValue"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VoiceOverValueType {
    #[default]
    VoiceOverValueType_Boolean = 0,
    VoiceOverValueType_Integer = 1,
    VoiceOverValueType_Float = 2,
    VoiceOverValueType_Vector = 3,
    VoiceOverValueType_Object = 4,
    VoiceOverValueTypeCount = 5,
}

pub static VOICEOVERVALUETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VOICEOVERVALUETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VoiceOverValueType {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERVALUETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VOICEOVERVALUETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverValueType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverValueType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub asset: Option<Arc<Mutex<dyn MusicBaseAssetTrait>>>,
}

pub trait MusicPlayerNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn asset(&self) -> &Option<Arc<Mutex<dyn MusicBaseAssetTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicBaseAssetTrait>>>;
}

impl MusicPlayerNodeConfigDataTrait for MusicPlayerNodeConfigData {
    fn asset(&self) -> &Option<Arc<Mutex<dyn MusicBaseAssetTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicBaseAssetTrait>>> {
        &mut self.asset
    }
}

impl AudioGraphNodeConfigDataTrait for MusicPlayerNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for MusicPlayerNodeConfigData {
}

pub static MUSICPLAYERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicBaseAsset",
                rust_offset: offset_of!(MusicPlayerNodeConfigData, asset),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPLAYERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub pitch: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub buffer: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub pause: AudioGraphNodePort,
    pub unpause: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub overlay: AudioGraphNodePort,
    pub is_buffered: AudioGraphNodePort,
    pub is_finished: AudioGraphNodePort,
    pub asset: Option<Arc<Mutex<dyn MusicBaseAssetTrait>>>,
    pub default_start_event_name_hash: u32,
    pub entries: Vec<Option<Arc<Mutex<dyn MusicPlayerEntryTrait>>>>,
    pub layers: Vec<Option<Arc<Mutex<dyn MusicLayerEntryTrait>>>>,
    pub plugins: Vec<MusicPlayerPlugins>,
    pub routed_voices: Vec<MusicPlayerRoutedVoice>,
    pub pitch_source: Option<Arc<Mutex<dyn OutputNodeDataTrait>>>,
    pub on_beat: AudioGraphNodePort,
    pub on_bar: AudioGraphNodePort,
    pub on_transition: AudioGraphNodePort,
}

pub trait MusicPlayerNodeDataTrait: AudioGraphNodeDataTrait {
    fn pitch(&self) -> &AudioGraphNodePort;
    fn pitch_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn buffer(&self) -> &AudioGraphNodePort;
    fn buffer_mut(&mut self) -> &mut AudioGraphNodePort;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn pause(&self) -> &AudioGraphNodePort;
    fn pause_mut(&mut self) -> &mut AudioGraphNodePort;
    fn unpause(&self) -> &AudioGraphNodePort;
    fn unpause_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn overlay(&self) -> &AudioGraphNodePort;
    fn overlay_mut(&mut self) -> &mut AudioGraphNodePort;
    fn is_buffered(&self) -> &AudioGraphNodePort;
    fn is_buffered_mut(&mut self) -> &mut AudioGraphNodePort;
    fn is_finished(&self) -> &AudioGraphNodePort;
    fn is_finished_mut(&mut self) -> &mut AudioGraphNodePort;
    fn asset(&self) -> &Option<Arc<Mutex<dyn MusicBaseAssetTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicBaseAssetTrait>>>;
    fn default_start_event_name_hash(&self) -> &u32;
    fn default_start_event_name_hash_mut(&mut self) -> &mut u32;
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MusicPlayerEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicPlayerEntryTrait>>>>;
    fn layers(&self) -> &Vec<Option<Arc<Mutex<dyn MusicLayerEntryTrait>>>>;
    fn layers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicLayerEntryTrait>>>>;
    fn plugins(&self) -> &Vec<MusicPlayerPlugins>;
    fn plugins_mut(&mut self) -> &mut Vec<MusicPlayerPlugins>;
    fn routed_voices(&self) -> &Vec<MusicPlayerRoutedVoice>;
    fn routed_voices_mut(&mut self) -> &mut Vec<MusicPlayerRoutedVoice>;
    fn pitch_source(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn pitch_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn on_beat(&self) -> &AudioGraphNodePort;
    fn on_beat_mut(&mut self) -> &mut AudioGraphNodePort;
    fn on_bar(&self) -> &AudioGraphNodePort;
    fn on_bar_mut(&mut self) -> &mut AudioGraphNodePort;
    fn on_transition(&self) -> &AudioGraphNodePort;
    fn on_transition_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MusicPlayerNodeDataTrait for MusicPlayerNodeData {
    fn pitch(&self) -> &AudioGraphNodePort {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pitch
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn buffer(&self) -> &AudioGraphNodePort {
        &self.buffer
    }
    fn buffer_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.buffer
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn pause(&self) -> &AudioGraphNodePort {
        &self.pause
    }
    fn pause_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pause
    }
    fn unpause(&self) -> &AudioGraphNodePort {
        &self.unpause
    }
    fn unpause_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.unpause
    }
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn overlay(&self) -> &AudioGraphNodePort {
        &self.overlay
    }
    fn overlay_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.overlay
    }
    fn is_buffered(&self) -> &AudioGraphNodePort {
        &self.is_buffered
    }
    fn is_buffered_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.is_buffered
    }
    fn is_finished(&self) -> &AudioGraphNodePort {
        &self.is_finished
    }
    fn is_finished_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.is_finished
    }
    fn asset(&self) -> &Option<Arc<Mutex<dyn MusicBaseAssetTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicBaseAssetTrait>>> {
        &mut self.asset
    }
    fn default_start_event_name_hash(&self) -> &u32 {
        &self.default_start_event_name_hash
    }
    fn default_start_event_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.default_start_event_name_hash
    }
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MusicPlayerEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicPlayerEntryTrait>>>> {
        &mut self.entries
    }
    fn layers(&self) -> &Vec<Option<Arc<Mutex<dyn MusicLayerEntryTrait>>>> {
        &self.layers
    }
    fn layers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicLayerEntryTrait>>>> {
        &mut self.layers
    }
    fn plugins(&self) -> &Vec<MusicPlayerPlugins> {
        &self.plugins
    }
    fn plugins_mut(&mut self) -> &mut Vec<MusicPlayerPlugins> {
        &mut self.plugins
    }
    fn routed_voices(&self) -> &Vec<MusicPlayerRoutedVoice> {
        &self.routed_voices
    }
    fn routed_voices_mut(&mut self) -> &mut Vec<MusicPlayerRoutedVoice> {
        &mut self.routed_voices
    }
    fn pitch_source(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &self.pitch_source
    }
    fn pitch_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &mut self.pitch_source
    }
    fn on_beat(&self) -> &AudioGraphNodePort {
        &self.on_beat
    }
    fn on_beat_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.on_beat
    }
    fn on_bar(&self) -> &AudioGraphNodePort {
        &self.on_bar
    }
    fn on_bar_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.on_bar
    }
    fn on_transition(&self) -> &AudioGraphNodePort {
        &self.on_transition
    }
    fn on_transition_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.on_transition
    }
}

impl AudioGraphNodeDataTrait for MusicPlayerNodeData {
}

impl super::core::DataContainerTrait for MusicPlayerNodeData {
}

pub static MUSICPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, pitch),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, amplitude),
            },
            FieldInfoData {
                name: "Buffer",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, buffer),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, stop),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, pause),
            },
            FieldInfoData {
                name: "Unpause",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, unpause),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, output),
            },
            FieldInfoData {
                name: "Overlay",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, overlay),
            },
            FieldInfoData {
                name: "IsBuffered",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, is_buffered),
            },
            FieldInfoData {
                name: "IsFinished",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, is_finished),
            },
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicBaseAsset",
                rust_offset: offset_of!(MusicPlayerNodeData, asset),
            },
            FieldInfoData {
                name: "DefaultStartEventNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicPlayerNodeData, default_start_event_name_hash),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicPlayerEntry-Array",
                rust_offset: offset_of!(MusicPlayerNodeData, entries),
            },
            FieldInfoData {
                name: "Layers",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicLayerEntry-Array",
                rust_offset: offset_of!(MusicPlayerNodeData, layers),
            },
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicPlayerPlugins-Array",
                rust_offset: offset_of!(MusicPlayerNodeData, plugins),
            },
            FieldInfoData {
                name: "RoutedVoices",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicPlayerRoutedVoice-Array",
                rust_offset: offset_of!(MusicPlayerNodeData, routed_voices),
            },
            FieldInfoData {
                name: "PitchSource",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputNodeData",
                rust_offset: offset_of!(MusicPlayerNodeData, pitch_source),
            },
            FieldInfoData {
                name: "OnBeat",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, on_beat),
            },
            FieldInfoData {
                name: "OnBar",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, on_bar),
            },
            FieldInfoData {
                name: "OnTransition",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerNodeData, on_transition),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicLayerEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub amplitude: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
}

pub trait MusicLayerEntryTrait: AudioGraphNodePortGroupTrait {
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MusicLayerEntryTrait for MusicLayerEntry {
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
}

impl AudioGraphNodePortGroupTrait for MusicLayerEntry {
}

impl super::core::DataContainerTrait for MusicLayerEntry {
}

pub static MUSICLAYERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicLayerEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicLayerEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicLayerEntry, amplitude),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicLayerEntry, output),
            },
        ],
    }),
    array_type: Some(MUSICLAYERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicLayerEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICLAYERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICLAYERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicLayerEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicLayerEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub target_name_hash: u32,
    pub is_event: bool,
}

pub trait MusicPlayerEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn target_name_hash(&self) -> &u32;
    fn target_name_hash_mut(&mut self) -> &mut u32;
    fn is_event(&self) -> &bool;
    fn is_event_mut(&mut self) -> &mut bool;
}

impl MusicPlayerEntryTrait for MusicPlayerEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn target_name_hash(&self) -> &u32 {
        &self.target_name_hash
    }
    fn target_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.target_name_hash
    }
    fn is_event(&self) -> &bool {
        &self.is_event
    }
    fn is_event_mut(&mut self) -> &mut bool {
        &mut self.is_event
    }
}

impl AudioGraphNodePortGroupTrait for MusicPlayerEntry {
}

impl super::core::DataContainerTrait for MusicPlayerEntry {
}

pub static MUSICPLAYERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MusicPlayerEntry, r#in),
            },
            FieldInfoData {
                name: "TargetNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicPlayerEntry, target_name_hash),
            },
            FieldInfoData {
                name: "IsEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MusicPlayerEntry, is_event),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPLAYERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerRoutedVoice {
    pub layer_count: u8,
    pub routed_plugins: Vec<MusicPlayerRoutedPlugins>,
    pub routed_target_plugins: Vec<MusicPlayerRoutedTargetPlugins>,
}

pub trait MusicPlayerRoutedVoiceTrait: TypeObject {
    fn layer_count(&self) -> &u8;
    fn layer_count_mut(&mut self) -> &mut u8;
    fn routed_plugins(&self) -> &Vec<MusicPlayerRoutedPlugins>;
    fn routed_plugins_mut(&mut self) -> &mut Vec<MusicPlayerRoutedPlugins>;
    fn routed_target_plugins(&self) -> &Vec<MusicPlayerRoutedTargetPlugins>;
    fn routed_target_plugins_mut(&mut self) -> &mut Vec<MusicPlayerRoutedTargetPlugins>;
}

impl MusicPlayerRoutedVoiceTrait for MusicPlayerRoutedVoice {
    fn layer_count(&self) -> &u8 {
        &self.layer_count
    }
    fn layer_count_mut(&mut self) -> &mut u8 {
        &mut self.layer_count
    }
    fn routed_plugins(&self) -> &Vec<MusicPlayerRoutedPlugins> {
        &self.routed_plugins
    }
    fn routed_plugins_mut(&mut self) -> &mut Vec<MusicPlayerRoutedPlugins> {
        &mut self.routed_plugins
    }
    fn routed_target_plugins(&self) -> &Vec<MusicPlayerRoutedTargetPlugins> {
        &self.routed_target_plugins
    }
    fn routed_target_plugins_mut(&mut self) -> &mut Vec<MusicPlayerRoutedTargetPlugins> {
        &mut self.routed_target_plugins
    }
}

pub static MUSICPLAYERROUTEDVOICE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedVoice",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerRoutedVoice as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayerCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MusicPlayerRoutedVoice, layer_count),
            },
            FieldInfoData {
                name: "RoutedPlugins",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicPlayerRoutedPlugins-Array",
                rust_offset: offset_of!(MusicPlayerRoutedVoice, routed_plugins),
            },
            FieldInfoData {
                name: "RoutedTargetPlugins",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicPlayerRoutedTargetPlugins-Array",
                rust_offset: offset_of!(MusicPlayerRoutedVoice, routed_target_plugins),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerRoutedVoice {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERROUTEDVOICE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICPLAYERROUTEDVOICE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedVoice-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerRoutedVoice"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerRoutedTargetPlugins {
    pub none: SoundGraphPluginRef,
}

pub trait MusicPlayerRoutedTargetPluginsTrait: TypeObject {
    fn none(&self) -> &SoundGraphPluginRef;
    fn none_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl MusicPlayerRoutedTargetPluginsTrait for MusicPlayerRoutedTargetPlugins {
    fn none(&self) -> &SoundGraphPluginRef {
        &self.none
    }
    fn none_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.none
    }
}

pub static MUSICPLAYERROUTEDTARGETPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedTargetPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerRoutedTargetPlugins as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "None",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerRoutedTargetPlugins, none),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPlayerRoutedTargetPlugins {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERROUTEDTARGETPLUGINS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICPLAYERROUTEDTARGETPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedTargetPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerRoutedTargetPlugins"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerRoutedPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub resample: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
    pub route: Vec<SoundGraphPluginRef>,
}

pub trait MusicPlayerRoutedPluginsTrait: TypeObject {
    fn snd_player(&self) -> &SoundGraphPluginRef;
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn resample(&self) -> &SoundGraphPluginRef;
    fn resample_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn pause(&self) -> &SoundGraphPluginRef;
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain(&self) -> &SoundGraphPluginRef;
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn route(&self) -> &Vec<SoundGraphPluginRef>;
    fn route_mut(&mut self) -> &mut Vec<SoundGraphPluginRef>;
}

impl MusicPlayerRoutedPluginsTrait for MusicPlayerRoutedPlugins {
    fn snd_player(&self) -> &SoundGraphPluginRef {
        &self.snd_player
    }
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.snd_player
    }
    fn resample(&self) -> &SoundGraphPluginRef {
        &self.resample
    }
    fn resample_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.resample
    }
    fn pause(&self) -> &SoundGraphPluginRef {
        &self.pause
    }
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pause
    }
    fn gain(&self) -> &SoundGraphPluginRef {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain
    }
    fn route(&self) -> &Vec<SoundGraphPluginRef> {
        &self.route
    }
    fn route_mut(&mut self) -> &mut Vec<SoundGraphPluginRef> {
        &mut self.route
    }
}

pub static MUSICPLAYERROUTEDPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedPlugins",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerRoutedPlugins as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, snd_player),
            },
            FieldInfoData {
                name: "Resample",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, resample),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, gain),
            },
            FieldInfoData {
                name: "Route",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphPluginRef-Array",
                rust_offset: offset_of!(MusicPlayerRoutedPlugins, route),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayerRoutedPlugins {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERROUTEDPLUGINS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICPLAYERROUTEDPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerRoutedPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerRoutedPlugins"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayerPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub rechannel: SoundGraphPluginRef,
    pub resample: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
}

pub trait MusicPlayerPluginsTrait: TypeObject {
    fn snd_player(&self) -> &SoundGraphPluginRef;
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn rechannel(&self) -> &SoundGraphPluginRef;
    fn rechannel_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn resample(&self) -> &SoundGraphPluginRef;
    fn resample_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn pause(&self) -> &SoundGraphPluginRef;
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain(&self) -> &SoundGraphPluginRef;
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl MusicPlayerPluginsTrait for MusicPlayerPlugins {
    fn snd_player(&self) -> &SoundGraphPluginRef {
        &self.snd_player
    }
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.snd_player
    }
    fn rechannel(&self) -> &SoundGraphPluginRef {
        &self.rechannel
    }
    fn rechannel_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.rechannel
    }
    fn resample(&self) -> &SoundGraphPluginRef {
        &self.resample
    }
    fn resample_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.resample
    }
    fn pause(&self) -> &SoundGraphPluginRef {
        &self.pause
    }
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pause
    }
    fn gain(&self) -> &SoundGraphPluginRef {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain
    }
}

pub static MUSICPLAYERPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayerPlugins as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerPlugins, snd_player),
            },
            FieldInfoData {
                name: "Rechannel",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerPlugins, rechannel),
            },
            FieldInfoData {
                name: "Resample",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerPlugins, resample),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MusicPlayerPlugins, gain),
            },
        ],
    }),
    array_type: Some(MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPlayerPlugins {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYERPLUGINS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICPLAYERPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayerPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayerPlugins"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LoadingMusicBundleAsset {
    pub _glacier_base: super::core::Asset,
    pub assets: Vec<Option<Arc<Mutex<dyn SoundAssetTrait>>>>,
    pub unique_id: String,
    pub super_bundle: String,
}

pub trait LoadingMusicBundleAssetTrait: super::core::AssetTrait {
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn SoundAssetTrait>>>>;
    fn assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundAssetTrait>>>>;
    fn unique_id(&self) -> &String;
    fn unique_id_mut(&mut self) -> &mut String;
    fn super_bundle(&self) -> &String;
    fn super_bundle_mut(&mut self) -> &mut String;
}

impl LoadingMusicBundleAssetTrait for LoadingMusicBundleAsset {
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn SoundAssetTrait>>>> {
        &self.assets
    }
    fn assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundAssetTrait>>>> {
        &mut self.assets
    }
    fn unique_id(&self) -> &String {
        &self.unique_id
    }
    fn unique_id_mut(&mut self) -> &mut String {
        &mut self.unique_id
    }
    fn super_bundle(&self) -> &String {
        &self.super_bundle
    }
    fn super_bundle_mut(&mut self) -> &mut String {
        &mut self.super_bundle
    }
}

impl super::core::AssetTrait for LoadingMusicBundleAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for LoadingMusicBundleAsset {
}

pub static LOADINGMUSICBUNDLEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicBundleAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LoadingMusicBundleAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Assets",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundAsset-Array",
                rust_offset: offset_of!(LoadingMusicBundleAsset, assets),
            },
            FieldInfoData {
                name: "UniqueId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LoadingMusicBundleAsset, unique_id),
            },
            FieldInfoData {
                name: "SuperBundle",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LoadingMusicBundleAsset, super_bundle),
            },
        ],
    }),
    array_type: Some(LOADINGMUSICBUNDLEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LoadingMusicBundleAsset {
    fn type_info(&self) -> &'static TypeInfo {
        LOADINGMUSICBUNDLEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOADINGMUSICBUNDLEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicBundleAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LoadingMusicBundleAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MusicMarkerType {
    #[default]
    MusicMarkerType_None = 0,
    MusicMarkerType_Beat = 1,
    MusicMarkerType_Bar = 2,
}

pub static MUSICMARKERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMarkerType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICMARKERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicMarkerType {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICMARKERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICMARKERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMarkerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicMarkerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MusicFadeType {
    #[default]
    MusicFadeType_Seconds = 0,
    MusicFadeType_Milliseconds = 1,
    MusicFadeType_Beats = 2,
    MusicFadeType_Bars = 3,
}

pub static MUSICFADETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICFADETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicFadeType {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICFADETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICFADETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicFadeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlaylistAsset {
    pub _glacier_base: MusicBaseAsset,
    pub playlist_type: MusicPlaylistType,
    pub assets: Vec<Option<Arc<Mutex<dyn MusicAssetTrait>>>>,
    pub selectors: Vec<Option<Arc<Mutex<dyn MusicPlaylistSelectorTrait>>>>,
    pub fade: Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>,
    pub repeat: bool,
    pub min_delay: f32,
    pub max_delay: f32,
}

pub trait MusicPlaylistAssetTrait: MusicBaseAssetTrait {
    fn playlist_type(&self) -> &MusicPlaylistType;
    fn playlist_type_mut(&mut self) -> &mut MusicPlaylistType;
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn MusicAssetTrait>>>>;
    fn assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicAssetTrait>>>>;
    fn selectors(&self) -> &Vec<Option<Arc<Mutex<dyn MusicPlaylistSelectorTrait>>>>;
    fn selectors_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicPlaylistSelectorTrait>>>>;
    fn fade(&self) -> &Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>;
    fn fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>;
    fn repeat(&self) -> &bool;
    fn repeat_mut(&mut self) -> &mut bool;
    fn min_delay(&self) -> &f32;
    fn min_delay_mut(&mut self) -> &mut f32;
    fn max_delay(&self) -> &f32;
    fn max_delay_mut(&mut self) -> &mut f32;
}

impl MusicPlaylistAssetTrait for MusicPlaylistAsset {
    fn playlist_type(&self) -> &MusicPlaylistType {
        &self.playlist_type
    }
    fn playlist_type_mut(&mut self) -> &mut MusicPlaylistType {
        &mut self.playlist_type
    }
    fn assets(&self) -> &Vec<Option<Arc<Mutex<dyn MusicAssetTrait>>>> {
        &self.assets
    }
    fn assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicAssetTrait>>>> {
        &mut self.assets
    }
    fn selectors(&self) -> &Vec<Option<Arc<Mutex<dyn MusicPlaylistSelectorTrait>>>> {
        &self.selectors
    }
    fn selectors_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicPlaylistSelectorTrait>>>> {
        &mut self.selectors
    }
    fn fade(&self) -> &Option<Arc<Mutex<dyn SynchedFadeDataTrait>>> {
        &self.fade
    }
    fn fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SynchedFadeDataTrait>>> {
        &mut self.fade
    }
    fn repeat(&self) -> &bool {
        &self.repeat
    }
    fn repeat_mut(&mut self) -> &mut bool {
        &mut self.repeat
    }
    fn min_delay(&self) -> &f32 {
        &self.min_delay
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        &mut self.min_delay
    }
    fn max_delay(&self) -> &f32 {
        &self.max_delay
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        &mut self.max_delay
    }
}

impl MusicBaseAssetTrait for MusicPlaylistAsset {
    fn interface(&self) -> &Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>> {
        self._glacier_base.interface_mut()
    }
    fn max_overlay_count(&self) -> &u32 {
        self._glacier_base.max_overlay_count()
    }
    fn max_overlay_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.max_overlay_count_mut()
    }
    fn channel_count(&self) -> &u8 {
        self._glacier_base.channel_count()
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.channel_count_mut()
    }
    fn overlay_channel_count(&self) -> &u8 {
        self._glacier_base.overlay_channel_count()
    }
    fn overlay_channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.overlay_channel_count_mut()
    }
}

impl super::core::AssetTrait for MusicPlaylistAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MusicPlaylistAsset {
}

pub static MUSICPLAYLISTASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICBASEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlaylistAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PlaylistType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicPlaylistType",
                rust_offset: offset_of!(MusicPlaylistAsset, playlist_type),
            },
            FieldInfoData {
                name: "Assets",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicAsset-Array",
                rust_offset: offset_of!(MusicPlaylistAsset, assets),
            },
            FieldInfoData {
                name: "Selectors",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicPlaylistSelector-Array",
                rust_offset: offset_of!(MusicPlaylistAsset, selectors),
            },
            FieldInfoData {
                name: "Fade",
                flags: MemberInfoFlags::new(0),
                field_type: "SynchedFadeData",
                rust_offset: offset_of!(MusicPlaylistAsset, fade),
            },
            FieldInfoData {
                name: "Repeat",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MusicPlaylistAsset, repeat),
            },
            FieldInfoData {
                name: "MinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlaylistAsset, min_delay),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlaylistAsset, max_delay),
            },
        ],
    }),
    array_type: Some(MUSICPLAYLISTASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlaylistAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYLISTASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPLAYLISTASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlaylistAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlaylistSelector {
    pub _glacier_base: super::core::DataContainer,
    pub event: Option<Arc<Mutex<dyn MusicEventDataTrait>>>,
    pub target: Option<Arc<Mutex<dyn MusicAssetTrait>>>,
    pub trigger_on_target: Option<Arc<Mutex<dyn MusicEventDataTrait>>>,
}

pub trait MusicPlaylistSelectorTrait: super::core::DataContainerTrait {
    fn event(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>>;
    fn target(&self) -> &Option<Arc<Mutex<dyn MusicAssetTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicAssetTrait>>>;
    fn trigger_on_target(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>>;
    fn trigger_on_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>>;
}

impl MusicPlaylistSelectorTrait for MusicPlaylistSelector {
    fn event(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        &mut self.event
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn MusicAssetTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicAssetTrait>>> {
        &mut self.target
    }
    fn trigger_on_target(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        &self.trigger_on_target
    }
    fn trigger_on_target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        &mut self.trigger_on_target
    }
}

impl super::core::DataContainerTrait for MusicPlaylistSelector {
}

pub static MUSICPLAYLISTSELECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistSelector",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlaylistSelector as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicEventData",
                rust_offset: offset_of!(MusicPlaylistSelector, event),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicAsset",
                rust_offset: offset_of!(MusicPlaylistSelector, target),
            },
            FieldInfoData {
                name: "TriggerOnTarget",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicEventData",
                rust_offset: offset_of!(MusicPlaylistSelector, trigger_on_target),
            },
        ],
    }),
    array_type: Some(MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlaylistSelector {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYLISTSELECTOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPLAYLISTSELECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistSelector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlaylistSelector"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MusicPlaylistType {
    #[default]
    MusicPlaylistType_PlayFirstAndShuffle = 0,
    MusicPlaylistType_Random = 1,
    MusicPlaylistType_Shuffle = 2,
    MusicPlaylistType_Sequential = 3,
}

pub static MUSICPLAYLISTTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICPLAYLISTTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPlaylistType {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYLISTTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICPLAYLISTTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlaylistType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlaylistType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicAsset {
    pub _glacier_base: MusicBaseAsset,
    pub name_hash: u32,
    pub metadata: Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>>,
    pub beats_per_minute: u32,
    pub beats_per_bar: u32,
    pub playables: Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>>,
    pub overlays: Vec<Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>>,
    pub selectors: Vec<Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>>,
    pub default_selector: Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>,
    pub fallback_transitions: Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>>,
    pub voice_priority: u8,
}

pub trait MusicAssetTrait: MusicBaseAssetTrait {
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
    fn metadata(&self) -> &Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>>;
    fn metadata_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>>;
    fn beats_per_minute(&self) -> &u32;
    fn beats_per_minute_mut(&mut self) -> &mut u32;
    fn beats_per_bar(&self) -> &u32;
    fn beats_per_bar_mut(&mut self) -> &mut u32;
    fn playables(&self) -> &Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>>;
    fn playables_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>>;
    fn overlays(&self) -> &Vec<Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>>;
    fn overlays_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>>;
    fn selectors(&self) -> &Vec<Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>>;
    fn selectors_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>>;
    fn default_selector(&self) -> &Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>;
    fn default_selector_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>;
    fn fallback_transitions(&self) -> &Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>>;
    fn fallback_transitions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>>;
    fn voice_priority(&self) -> &u8;
    fn voice_priority_mut(&mut self) -> &mut u8;
}

impl MusicAssetTrait for MusicAsset {
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
    fn metadata(&self) -> &Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        &self.metadata
    }
    fn metadata_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        &mut self.metadata
    }
    fn beats_per_minute(&self) -> &u32 {
        &self.beats_per_minute
    }
    fn beats_per_minute_mut(&mut self) -> &mut u32 {
        &mut self.beats_per_minute
    }
    fn beats_per_bar(&self) -> &u32 {
        &self.beats_per_bar
    }
    fn beats_per_bar_mut(&mut self) -> &mut u32 {
        &mut self.beats_per_bar
    }
    fn playables(&self) -> &Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>> {
        &self.playables
    }
    fn playables_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>> {
        &mut self.playables
    }
    fn overlays(&self) -> &Vec<Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>> {
        &self.overlays
    }
    fn overlays_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>> {
        &mut self.overlays
    }
    fn selectors(&self) -> &Vec<Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>> {
        &self.selectors
    }
    fn selectors_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>>> {
        &mut self.selectors
    }
    fn default_selector(&self) -> &Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>> {
        &self.default_selector
    }
    fn default_selector_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicSelectorBaseTrait>>> {
        &mut self.default_selector
    }
    fn fallback_transitions(&self) -> &Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>> {
        &self.fallback_transitions
    }
    fn fallback_transitions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>> {
        &mut self.fallback_transitions
    }
    fn voice_priority(&self) -> &u8 {
        &self.voice_priority
    }
    fn voice_priority_mut(&mut self) -> &mut u8 {
        &mut self.voice_priority
    }
}

impl MusicBaseAssetTrait for MusicAsset {
    fn interface(&self) -> &Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>> {
        self._glacier_base.interface()
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>> {
        self._glacier_base.interface_mut()
    }
    fn max_overlay_count(&self) -> &u32 {
        self._glacier_base.max_overlay_count()
    }
    fn max_overlay_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.max_overlay_count_mut()
    }
    fn channel_count(&self) -> &u8 {
        self._glacier_base.channel_count()
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.channel_count_mut()
    }
    fn overlay_channel_count(&self) -> &u8 {
        self._glacier_base.overlay_channel_count()
    }
    fn overlay_channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.overlay_channel_count_mut()
    }
}

impl super::core::AssetTrait for MusicAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MusicAsset {
}

pub static MUSICASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICBASEASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicAsset, name_hash),
            },
            FieldInfoData {
                name: "Metadata",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicMetadataBase",
                rust_offset: offset_of!(MusicAsset, metadata),
            },
            FieldInfoData {
                name: "BeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicAsset, beats_per_minute),
            },
            FieldInfoData {
                name: "BeatsPerBar",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicAsset, beats_per_bar),
            },
            FieldInfoData {
                name: "Playables",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicStreamableData-Array",
                rust_offset: offset_of!(MusicAsset, playables),
            },
            FieldInfoData {
                name: "Overlays",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicOverlayData-Array",
                rust_offset: offset_of!(MusicAsset, overlays),
            },
            FieldInfoData {
                name: "Selectors",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicSelectorBase-Array",
                rust_offset: offset_of!(MusicAsset, selectors),
            },
            FieldInfoData {
                name: "DefaultSelector",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicSelectorBase",
                rust_offset: offset_of!(MusicAsset, default_selector),
            },
            FieldInfoData {
                name: "FallbackTransitions",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicTransition-Array",
                rust_offset: offset_of!(MusicAsset, fallback_transitions),
            },
            FieldInfoData {
                name: "VoicePriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MusicAsset, voice_priority),
            },
        ],
    }),
    array_type: Some(MUSICASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicBaseAsset {
    pub _glacier_base: super::core::Asset,
    pub interface: Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>>,
    pub max_overlay_count: u32,
    pub channel_count: u8,
    pub overlay_channel_count: u8,
}

pub trait MusicBaseAssetTrait: super::core::AssetTrait {
    fn interface(&self) -> &Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>>;
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>>;
    fn max_overlay_count(&self) -> &u32;
    fn max_overlay_count_mut(&mut self) -> &mut u32;
    fn channel_count(&self) -> &u8;
    fn channel_count_mut(&mut self) -> &mut u8;
    fn overlay_channel_count(&self) -> &u8;
    fn overlay_channel_count_mut(&mut self) -> &mut u8;
}

impl MusicBaseAssetTrait for MusicBaseAsset {
    fn interface(&self) -> &Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>> {
        &self.interface
    }
    fn interface_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicInterfaceAssetTrait>>> {
        &mut self.interface
    }
    fn max_overlay_count(&self) -> &u32 {
        &self.max_overlay_count
    }
    fn max_overlay_count_mut(&mut self) -> &mut u32 {
        &mut self.max_overlay_count
    }
    fn channel_count(&self) -> &u8 {
        &self.channel_count
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        &mut self.channel_count
    }
    fn overlay_channel_count(&self) -> &u8 {
        &self.overlay_channel_count
    }
    fn overlay_channel_count_mut(&mut self) -> &mut u8 {
        &mut self.overlay_channel_count
    }
}

impl super::core::AssetTrait for MusicBaseAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MusicBaseAsset {
}

pub static MUSICBASEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicBaseAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicBaseAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Interface",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicInterfaceAsset",
                rust_offset: offset_of!(MusicBaseAsset, interface),
            },
            FieldInfoData {
                name: "MaxOverlayCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicBaseAsset, max_overlay_count),
            },
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MusicBaseAsset, channel_count),
            },
            FieldInfoData {
                name: "OverlayChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(MusicBaseAsset, overlay_channel_count),
            },
        ],
    }),
    array_type: Some(MUSICBASEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicBaseAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICBASEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICBASEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicBaseAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicBaseAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicTransition {
    pub _glacier_base: super::core::DataContainer,
    pub source: Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>,
    pub destination: Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>,
    pub fade: Option<Arc<Mutex<dyn BasicFadeDataTrait>>>,
    pub overlay_control: Option<Arc<Mutex<dyn OverlayControlTrait>>>,
}

pub trait MusicTransitionTrait: super::core::DataContainerTrait {
    fn source(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn destination(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn destination_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn fade(&self) -> &Option<Arc<Mutex<dyn BasicFadeDataTrait>>>;
    fn fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BasicFadeDataTrait>>>;
    fn overlay_control(&self) -> &Option<Arc<Mutex<dyn OverlayControlTrait>>>;
    fn overlay_control_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OverlayControlTrait>>>;
}

impl MusicTransitionTrait for MusicTransition {
    fn source(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &mut self.source
    }
    fn destination(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &self.destination
    }
    fn destination_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &mut self.destination
    }
    fn fade(&self) -> &Option<Arc<Mutex<dyn BasicFadeDataTrait>>> {
        &self.fade
    }
    fn fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn BasicFadeDataTrait>>> {
        &mut self.fade
    }
    fn overlay_control(&self) -> &Option<Arc<Mutex<dyn OverlayControlTrait>>> {
        &self.overlay_control
    }
    fn overlay_control_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OverlayControlTrait>>> {
        &mut self.overlay_control
    }
}

impl super::core::DataContainerTrait for MusicTransition {
}

pub static MUSICTRANSITION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicTransition",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicTransition as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicStreamableData",
                rust_offset: offset_of!(MusicTransition, source),
            },
            FieldInfoData {
                name: "Destination",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicStreamableData",
                rust_offset: offset_of!(MusicTransition, destination),
            },
            FieldInfoData {
                name: "Fade",
                flags: MemberInfoFlags::new(0),
                field_type: "BasicFadeData",
                rust_offset: offset_of!(MusicTransition, fade),
            },
            FieldInfoData {
                name: "OverlayControl",
                flags: MemberInfoFlags::new(0),
                field_type: "OverlayControl",
                rust_offset: offset_of!(MusicTransition, overlay_control),
            },
        ],
    }),
    array_type: Some(MUSICTRANSITION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicTransition {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICTRANSITION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICTRANSITION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicTransition-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicTransition"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicSelectorParameter {
    pub _glacier_base: MusicSelectorBase,
    pub parameter: Option<Arc<Mutex<dyn MusicParameterDataTrait>>>,
    pub selectors: Vec<Option<Arc<Mutex<dyn ParameterBoundSelectorTrait>>>>,
}

pub trait MusicSelectorParameterTrait: MusicSelectorBaseTrait {
    fn parameter(&self) -> &Option<Arc<Mutex<dyn MusicParameterDataTrait>>>;
    fn parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicParameterDataTrait>>>;
    fn selectors(&self) -> &Vec<Option<Arc<Mutex<dyn ParameterBoundSelectorTrait>>>>;
    fn selectors_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ParameterBoundSelectorTrait>>>>;
}

impl MusicSelectorParameterTrait for MusicSelectorParameter {
    fn parameter(&self) -> &Option<Arc<Mutex<dyn MusicParameterDataTrait>>> {
        &self.parameter
    }
    fn parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicParameterDataTrait>>> {
        &mut self.parameter
    }
    fn selectors(&self) -> &Vec<Option<Arc<Mutex<dyn ParameterBoundSelectorTrait>>>> {
        &self.selectors
    }
    fn selectors_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn ParameterBoundSelectorTrait>>>> {
        &mut self.selectors
    }
}

impl MusicSelectorBaseTrait for MusicSelectorParameter {
    fn event(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        self._glacier_base.event()
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        self._glacier_base.event_mut()
    }
}

impl super::core::DataContainerTrait for MusicSelectorParameter {
}

pub static MUSICSELECTORPARAMETER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorParameter",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSELECTORBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicSelectorParameter as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Parameter",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicParameterData",
                rust_offset: offset_of!(MusicSelectorParameter, parameter),
            },
            FieldInfoData {
                name: "Selectors",
                flags: MemberInfoFlags::new(144),
                field_type: "ParameterBoundSelector-Array",
                rust_offset: offset_of!(MusicSelectorParameter, selectors),
            },
        ],
    }),
    array_type: Some(MUSICSELECTORPARAMETER_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicSelectorParameter {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSELECTORPARAMETER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICSELECTORPARAMETER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorParameter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelectorParameter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ParameterBoundSelector {
    pub _glacier_base: super::core::DataContainer,
    pub parameter_value: f32,
    pub selector: Option<Arc<Mutex<dyn MusicSelectorTrait>>>,
}

pub trait ParameterBoundSelectorTrait: super::core::DataContainerTrait {
    fn parameter_value(&self) -> &f32;
    fn parameter_value_mut(&mut self) -> &mut f32;
    fn selector(&self) -> &Option<Arc<Mutex<dyn MusicSelectorTrait>>>;
    fn selector_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicSelectorTrait>>>;
}

impl ParameterBoundSelectorTrait for ParameterBoundSelector {
    fn parameter_value(&self) -> &f32 {
        &self.parameter_value
    }
    fn parameter_value_mut(&mut self) -> &mut f32 {
        &mut self.parameter_value
    }
    fn selector(&self) -> &Option<Arc<Mutex<dyn MusicSelectorTrait>>> {
        &self.selector
    }
    fn selector_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicSelectorTrait>>> {
        &mut self.selector
    }
}

impl super::core::DataContainerTrait for ParameterBoundSelector {
}

pub static PARAMETERBOUNDSELECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterBoundSelector",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ParameterBoundSelector as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ParameterValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ParameterBoundSelector, parameter_value),
            },
            FieldInfoData {
                name: "Selector",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicSelector",
                rust_offset: offset_of!(ParameterBoundSelector, selector),
            },
        ],
    }),
    array_type: Some(PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ParameterBoundSelector {
    fn type_info(&self) -> &'static TypeInfo {
        PARAMETERBOUNDSELECTOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PARAMETERBOUNDSELECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ParameterBoundSelector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ParameterBoundSelector"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicSelector {
    pub _glacier_base: MusicSelectorBase,
    pub trigger_type: MusicSelectorTriggerType,
    pub sync_type: MusicSyncType,
    pub target: Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>,
    pub default: Option<Arc<Mutex<dyn MusicTransitionTrait>>>,
    pub transitions: Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>>,
}

pub trait MusicSelectorTrait: MusicSelectorBaseTrait {
    fn trigger_type(&self) -> &MusicSelectorTriggerType;
    fn trigger_type_mut(&mut self) -> &mut MusicSelectorTriggerType;
    fn sync_type(&self) -> &MusicSyncType;
    fn sync_type_mut(&mut self) -> &mut MusicSyncType;
    fn target(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn default(&self) -> &Option<Arc<Mutex<dyn MusicTransitionTrait>>>;
    fn default_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicTransitionTrait>>>;
    fn transitions(&self) -> &Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>>;
    fn transitions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>>;
}

impl MusicSelectorTrait for MusicSelector {
    fn trigger_type(&self) -> &MusicSelectorTriggerType {
        &self.trigger_type
    }
    fn trigger_type_mut(&mut self) -> &mut MusicSelectorTriggerType {
        &mut self.trigger_type
    }
    fn sync_type(&self) -> &MusicSyncType {
        &self.sync_type
    }
    fn sync_type_mut(&mut self) -> &mut MusicSyncType {
        &mut self.sync_type
    }
    fn target(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &self.target
    }
    fn target_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &mut self.target
    }
    fn default(&self) -> &Option<Arc<Mutex<dyn MusicTransitionTrait>>> {
        &self.default
    }
    fn default_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicTransitionTrait>>> {
        &mut self.default
    }
    fn transitions(&self) -> &Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>> {
        &self.transitions
    }
    fn transitions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicTransitionTrait>>>> {
        &mut self.transitions
    }
}

impl MusicSelectorBaseTrait for MusicSelector {
    fn event(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        self._glacier_base.event()
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        self._glacier_base.event_mut()
    }
}

impl super::core::DataContainerTrait for MusicSelector {
}

pub static MUSICSELECTOR_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelector",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSELECTORBASE_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicSelector as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "TriggerType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicSelectorTriggerType",
                rust_offset: offset_of!(MusicSelector, trigger_type),
            },
            FieldInfoData {
                name: "SyncType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicSyncType",
                rust_offset: offset_of!(MusicSelector, sync_type),
            },
            FieldInfoData {
                name: "Target",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicStreamableData",
                rust_offset: offset_of!(MusicSelector, target),
            },
            FieldInfoData {
                name: "Default",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicTransition",
                rust_offset: offset_of!(MusicSelector, default),
            },
            FieldInfoData {
                name: "Transitions",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicTransition-Array",
                rust_offset: offset_of!(MusicSelector, transitions),
            },
        ],
    }),
    array_type: Some(MUSICSELECTOR_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicSelector {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSELECTOR_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICSELECTOR_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelector-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelector"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicSelectorBase {
    pub _glacier_base: super::core::DataContainer,
    pub event: Option<Arc<Mutex<dyn MusicEventDataTrait>>>,
}

pub trait MusicSelectorBaseTrait: super::core::DataContainerTrait {
    fn event(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>>;
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>>;
}

impl MusicSelectorBaseTrait for MusicSelectorBase {
    fn event(&self) -> &Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        &self.event
    }
    fn event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicEventDataTrait>>> {
        &mut self.event
    }
}

impl super::core::DataContainerTrait for MusicSelectorBase {
}

pub static MUSICSELECTORBASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorBase",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicSelectorBase as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Event",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicEventData",
                rust_offset: offset_of!(MusicSelectorBase, event),
            },
        ],
    }),
    array_type: Some(MUSICSELECTORBASE_ARRAY_TYPE_INFO),
    alignment: 0,
};

impl TypeObject for MusicSelectorBase {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSELECTORBASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICSELECTORBASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelectorBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OverlayControl {
    pub _glacier_base: super::core::DataContainer,
    pub overlay: Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>,
    pub sync: bool,
}

pub trait OverlayControlTrait: super::core::DataContainerTrait {
    fn overlay(&self) -> &Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>;
    fn overlay_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>;
    fn sync(&self) -> &bool;
    fn sync_mut(&mut self) -> &mut bool;
}

impl OverlayControlTrait for OverlayControl {
    fn overlay(&self) -> &Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        &self.overlay
    }
    fn overlay_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        &mut self.overlay
    }
    fn sync(&self) -> &bool {
        &self.sync
    }
    fn sync_mut(&mut self) -> &mut bool {
        &mut self.sync
    }
}

impl super::core::DataContainerTrait for OverlayControl {
}

pub static OVERLAYCONTROL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OverlayControl",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OverlayControl as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Overlay",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicOverlayData",
                rust_offset: offset_of!(OverlayControl, overlay),
            },
            FieldInfoData {
                name: "Sync",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OverlayControl, sync),
            },
        ],
    }),
    array_type: Some(OVERLAYCONTROL_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OverlayControl {
    fn type_info(&self) -> &'static TypeInfo {
        OVERLAYCONTROL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OVERLAYCONTROL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OverlayControl-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OverlayControl"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MusicSelectorTriggerType {
    #[default]
    MusicSelectorTriggerType_Interrupt = 0,
    MusicSelectorTriggerType_Queue = 1,
    MusicSelectorTriggerType_Fade = 2,
}

pub static MUSICSELECTORTRIGGERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorTriggerType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICSELECTORTRIGGERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicSelectorTriggerType {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSELECTORTRIGGERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICSELECTORTRIGGERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSelectorTriggerType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSelectorTriggerType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicInterfaceAsset {
    pub _glacier_base: super::core::Asset,
    pub events: Vec<Option<Arc<Mutex<dyn MusicEventDataTrait>>>>,
    pub parameters: Vec<Option<Arc<Mutex<dyn MusicParameterDataTrait>>>>,
}

pub trait MusicInterfaceAssetTrait: super::core::AssetTrait {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn MusicEventDataTrait>>>>;
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicEventDataTrait>>>>;
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn MusicParameterDataTrait>>>>;
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicParameterDataTrait>>>>;
}

impl MusicInterfaceAssetTrait for MusicInterfaceAsset {
    fn events(&self) -> &Vec<Option<Arc<Mutex<dyn MusicEventDataTrait>>>> {
        &self.events
    }
    fn events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicEventDataTrait>>>> {
        &mut self.events
    }
    fn parameters(&self) -> &Vec<Option<Arc<Mutex<dyn MusicParameterDataTrait>>>> {
        &self.parameters
    }
    fn parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicParameterDataTrait>>>> {
        &mut self.parameters
    }
}

impl super::core::AssetTrait for MusicInterfaceAsset {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
}

impl super::core::DataContainerTrait for MusicInterfaceAsset {
}

pub static MUSICINTERFACEASSET_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInterfaceAsset",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::ASSET_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicInterfaceAsset as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Events",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicEventData-Array",
                rust_offset: offset_of!(MusicInterfaceAsset, events),
            },
            FieldInfoData {
                name: "Parameters",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicParameterData-Array",
                rust_offset: offset_of!(MusicInterfaceAsset, parameters),
            },
        ],
    }),
    array_type: Some(MUSICINTERFACEASSET_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicInterfaceAsset {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICINTERFACEASSET_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICINTERFACEASSET_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInterfaceAsset-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicInterfaceAsset"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicOverlayData {
    pub _glacier_base: MusicPlayableData,
    pub variations: Vec<MusicOverlayVariation>,
}

pub trait MusicOverlayDataTrait: MusicPlayableDataTrait {
    fn variations(&self) -> &Vec<MusicOverlayVariation>;
    fn variations_mut(&mut self) -> &mut Vec<MusicOverlayVariation>;
}

impl MusicOverlayDataTrait for MusicOverlayData {
    fn variations(&self) -> &Vec<MusicOverlayVariation> {
        &self.variations
    }
    fn variations_mut(&mut self) -> &mut Vec<MusicOverlayVariation> {
        &mut self.variations
    }
}

impl MusicPlayableDataTrait for MusicOverlayData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn play_count(&self) -> &u32 {
        self._glacier_base.play_count()
    }
    fn play_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.play_count_mut()
    }
    fn min_delay(&self) -> &f32 {
        self._glacier_base.min_delay()
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_delay_mut()
    }
    fn max_delay(&self) -> &f32 {
        self._glacier_base.max_delay()
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_delay_mut()
    }
    fn transition_time(&self) -> &f32 {
        self._glacier_base.transition_time()
    }
    fn transition_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.transition_time_mut()
    }
    fn beats_per_minute(&self) -> &u32 {
        self._glacier_base.beats_per_minute()
    }
    fn beats_per_minute_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_minute_mut()
    }
    fn beats_per_bar(&self) -> &u32 {
        self._glacier_base.beats_per_bar()
    }
    fn beats_per_bar_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_bar_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn pitch(&self) -> &f32 {
        self._glacier_base.pitch()
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.pitch_mut()
    }
}

impl super::core::DataContainerTrait for MusicOverlayData {
}

pub static MUSICOVERLAYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICPLAYABLEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicOverlayData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Variations",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicOverlayVariation-Array",
                rust_offset: offset_of!(MusicOverlayData, variations),
            },
        ],
    }),
    array_type: Some(MUSICOVERLAYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicOverlayData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICOVERLAYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICOVERLAYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicOverlayData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicOverlayVariation {
    pub wave: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
    pub transient_point: f32,
}

pub trait MusicOverlayVariationTrait: TypeObject {
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn transient_point(&self) -> &f32;
    fn transient_point_mut(&mut self) -> &mut f32;
}

impl MusicOverlayVariationTrait for MusicOverlayVariation {
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.wave
    }
    fn transient_point(&self) -> &f32 {
        &self.transient_point
    }
    fn transient_point_mut(&mut self) -> &mut f32 {
        &mut self.transient_point
    }
}

pub static MUSICOVERLAYVARIATION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayVariation",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicOverlayVariation as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(MusicOverlayVariation, wave),
            },
            FieldInfoData {
                name: "TransientPoint",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicOverlayVariation, transient_point),
            },
        ],
    }),
    array_type: Some(MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicOverlayVariation {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICOVERLAYVARIATION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICOVERLAYVARIATION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicOverlayVariation-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicOverlayVariation"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPhraseData {
    pub _glacier_base: MusicStreamableData,
    pub selection_type: MusicPhraseSelectionType,
    pub selection_parameter: Option<Arc<Mutex<dyn MusicParameterDataTrait>>>,
    pub range_fade: Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>,
    pub playables: Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>>,
}

pub trait MusicPhraseDataTrait: MusicStreamableDataTrait {
    fn selection_type(&self) -> &MusicPhraseSelectionType;
    fn selection_type_mut(&mut self) -> &mut MusicPhraseSelectionType;
    fn selection_parameter(&self) -> &Option<Arc<Mutex<dyn MusicParameterDataTrait>>>;
    fn selection_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicParameterDataTrait>>>;
    fn range_fade(&self) -> &Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>;
    fn range_fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>;
    fn playables(&self) -> &Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>>;
    fn playables_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>>;
}

impl MusicPhraseDataTrait for MusicPhraseData {
    fn selection_type(&self) -> &MusicPhraseSelectionType {
        &self.selection_type
    }
    fn selection_type_mut(&mut self) -> &mut MusicPhraseSelectionType {
        &mut self.selection_type
    }
    fn selection_parameter(&self) -> &Option<Arc<Mutex<dyn MusicParameterDataTrait>>> {
        &self.selection_parameter
    }
    fn selection_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicParameterDataTrait>>> {
        &mut self.selection_parameter
    }
    fn range_fade(&self) -> &Option<Arc<Mutex<dyn SynchedFadeDataTrait>>> {
        &self.range_fade
    }
    fn range_fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SynchedFadeDataTrait>>> {
        &mut self.range_fade
    }
    fn playables(&self) -> &Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>> {
        &self.playables
    }
    fn playables_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>> {
        &mut self.playables
    }
}

impl MusicStreamableDataTrait for MusicPhraseData {
    fn range_value(&self) -> &f32 {
        self._glacier_base.range_value()
    }
    fn range_value_mut(&mut self) -> &mut f32 {
        self._glacier_base.range_value_mut()
    }
    fn allow_range_fade(&self) -> &bool {
        self._glacier_base.allow_range_fade()
    }
    fn allow_range_fade_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_range_fade_mut()
    }
    fn restart_if_already_playing(&self) -> &bool {
        self._glacier_base.restart_if_already_playing()
    }
    fn restart_if_already_playing_mut(&mut self) -> &mut bool {
        self._glacier_base.restart_if_already_playing_mut()
    }
    fn weight(&self) -> &i32 {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut i32 {
        self._glacier_base.weight_mut()
    }
    fn next_playable(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        self._glacier_base.next_playable()
    }
    fn next_playable_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        self._glacier_base.next_playable_mut()
    }
    fn on_next_playable_overlay(&self) -> &Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        self._glacier_base.on_next_playable_overlay()
    }
    fn on_next_playable_overlay_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        self._glacier_base.on_next_playable_overlay_mut()
    }
    fn next_playable_fade_in_time(&self) -> &f32 {
        self._glacier_base.next_playable_fade_in_time()
    }
    fn next_playable_fade_in_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.next_playable_fade_in_time_mut()
    }
    fn metadata(&self) -> &Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        self._glacier_base.metadata()
    }
    fn metadata_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        self._glacier_base.metadata_mut()
    }
}

impl MusicPlayableDataTrait for MusicPhraseData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn play_count(&self) -> &u32 {
        self._glacier_base.play_count()
    }
    fn play_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.play_count_mut()
    }
    fn min_delay(&self) -> &f32 {
        self._glacier_base.min_delay()
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_delay_mut()
    }
    fn max_delay(&self) -> &f32 {
        self._glacier_base.max_delay()
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_delay_mut()
    }
    fn transition_time(&self) -> &f32 {
        self._glacier_base.transition_time()
    }
    fn transition_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.transition_time_mut()
    }
    fn beats_per_minute(&self) -> &u32 {
        self._glacier_base.beats_per_minute()
    }
    fn beats_per_minute_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_minute_mut()
    }
    fn beats_per_bar(&self) -> &u32 {
        self._glacier_base.beats_per_bar()
    }
    fn beats_per_bar_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_bar_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn pitch(&self) -> &f32 {
        self._glacier_base.pitch()
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.pitch_mut()
    }
}

impl super::core::DataContainerTrait for MusicPhraseData {
}

pub static MUSICPHRASEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSTREAMABLEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPhraseData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SelectionType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicPhraseSelectionType",
                rust_offset: offset_of!(MusicPhraseData, selection_type),
            },
            FieldInfoData {
                name: "SelectionParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicParameterData",
                rust_offset: offset_of!(MusicPhraseData, selection_parameter),
            },
            FieldInfoData {
                name: "RangeFade",
                flags: MemberInfoFlags::new(0),
                field_type: "SynchedFadeData",
                rust_offset: offset_of!(MusicPhraseData, range_fade),
            },
            FieldInfoData {
                name: "Playables",
                flags: MemberInfoFlags::new(144),
                field_type: "MusicStreamableData-Array",
                rust_offset: offset_of!(MusicPhraseData, playables),
            },
        ],
    }),
    array_type: Some(MUSICPHRASEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPhraseData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPHRASEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPHRASEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPhraseData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicSegmentData {
    pub _glacier_base: MusicStreamableData,
    pub wave: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
    pub multitrack_layers: Option<Arc<Mutex<dyn MultitrackDataTrait>>>,
}

pub trait MusicSegmentDataTrait: MusicStreamableDataTrait {
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn multitrack_layers(&self) -> &Option<Arc<Mutex<dyn MultitrackDataTrait>>>;
    fn multitrack_layers_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MultitrackDataTrait>>>;
}

impl MusicSegmentDataTrait for MusicSegmentData {
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.wave
    }
    fn multitrack_layers(&self) -> &Option<Arc<Mutex<dyn MultitrackDataTrait>>> {
        &self.multitrack_layers
    }
    fn multitrack_layers_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MultitrackDataTrait>>> {
        &mut self.multitrack_layers
    }
}

impl MusicStreamableDataTrait for MusicSegmentData {
    fn range_value(&self) -> &f32 {
        self._glacier_base.range_value()
    }
    fn range_value_mut(&mut self) -> &mut f32 {
        self._glacier_base.range_value_mut()
    }
    fn allow_range_fade(&self) -> &bool {
        self._glacier_base.allow_range_fade()
    }
    fn allow_range_fade_mut(&mut self) -> &mut bool {
        self._glacier_base.allow_range_fade_mut()
    }
    fn restart_if_already_playing(&self) -> &bool {
        self._glacier_base.restart_if_already_playing()
    }
    fn restart_if_already_playing_mut(&mut self) -> &mut bool {
        self._glacier_base.restart_if_already_playing_mut()
    }
    fn weight(&self) -> &i32 {
        self._glacier_base.weight()
    }
    fn weight_mut(&mut self) -> &mut i32 {
        self._glacier_base.weight_mut()
    }
    fn next_playable(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        self._glacier_base.next_playable()
    }
    fn next_playable_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        self._glacier_base.next_playable_mut()
    }
    fn on_next_playable_overlay(&self) -> &Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        self._glacier_base.on_next_playable_overlay()
    }
    fn on_next_playable_overlay_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        self._glacier_base.on_next_playable_overlay_mut()
    }
    fn next_playable_fade_in_time(&self) -> &f32 {
        self._glacier_base.next_playable_fade_in_time()
    }
    fn next_playable_fade_in_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.next_playable_fade_in_time_mut()
    }
    fn metadata(&self) -> &Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        self._glacier_base.metadata()
    }
    fn metadata_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        self._glacier_base.metadata_mut()
    }
}

impl MusicPlayableDataTrait for MusicSegmentData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn play_count(&self) -> &u32 {
        self._glacier_base.play_count()
    }
    fn play_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.play_count_mut()
    }
    fn min_delay(&self) -> &f32 {
        self._glacier_base.min_delay()
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_delay_mut()
    }
    fn max_delay(&self) -> &f32 {
        self._glacier_base.max_delay()
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_delay_mut()
    }
    fn transition_time(&self) -> &f32 {
        self._glacier_base.transition_time()
    }
    fn transition_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.transition_time_mut()
    }
    fn beats_per_minute(&self) -> &u32 {
        self._glacier_base.beats_per_minute()
    }
    fn beats_per_minute_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_minute_mut()
    }
    fn beats_per_bar(&self) -> &u32 {
        self._glacier_base.beats_per_bar()
    }
    fn beats_per_bar_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_bar_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn pitch(&self) -> &f32 {
        self._glacier_base.pitch()
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.pitch_mut()
    }
}

impl super::core::DataContainerTrait for MusicSegmentData {
}

pub static MUSICSEGMENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSegmentData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICSTREAMABLEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicSegmentData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(MusicSegmentData, wave),
            },
            FieldInfoData {
                name: "MultitrackLayers",
                flags: MemberInfoFlags::new(0),
                field_type: "MultitrackData",
                rust_offset: offset_of!(MusicSegmentData, multitrack_layers),
            },
        ],
    }),
    array_type: Some(MUSICSEGMENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicSegmentData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSEGMENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICSEGMENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSegmentData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSegmentData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultitrackData {
    pub _glacier_base: super::core::DataContainer,
    pub layer_control_parameter: Option<Arc<Mutex<dyn MusicParameterDataTrait>>>,
    pub range_fade: Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>,
    pub layers: Vec<Option<Arc<Mutex<dyn MultitrackLayerDataTrait>>>>,
}

pub trait MultitrackDataTrait: super::core::DataContainerTrait {
    fn layer_control_parameter(&self) -> &Option<Arc<Mutex<dyn MusicParameterDataTrait>>>;
    fn layer_control_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicParameterDataTrait>>>;
    fn range_fade(&self) -> &Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>;
    fn range_fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SynchedFadeDataTrait>>>;
    fn layers(&self) -> &Vec<Option<Arc<Mutex<dyn MultitrackLayerDataTrait>>>>;
    fn layers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MultitrackLayerDataTrait>>>>;
}

impl MultitrackDataTrait for MultitrackData {
    fn layer_control_parameter(&self) -> &Option<Arc<Mutex<dyn MusicParameterDataTrait>>> {
        &self.layer_control_parameter
    }
    fn layer_control_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicParameterDataTrait>>> {
        &mut self.layer_control_parameter
    }
    fn range_fade(&self) -> &Option<Arc<Mutex<dyn SynchedFadeDataTrait>>> {
        &self.range_fade
    }
    fn range_fade_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SynchedFadeDataTrait>>> {
        &mut self.range_fade
    }
    fn layers(&self) -> &Vec<Option<Arc<Mutex<dyn MultitrackLayerDataTrait>>>> {
        &self.layers
    }
    fn layers_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MultitrackLayerDataTrait>>>> {
        &mut self.layers
    }
}

impl super::core::DataContainerTrait for MultitrackData {
}

pub static MULTITRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultitrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayerControlParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicParameterData",
                rust_offset: offset_of!(MultitrackData, layer_control_parameter),
            },
            FieldInfoData {
                name: "RangeFade",
                flags: MemberInfoFlags::new(0),
                field_type: "SynchedFadeData",
                rust_offset: offset_of!(MultitrackData, range_fade),
            },
            FieldInfoData {
                name: "Layers",
                flags: MemberInfoFlags::new(144),
                field_type: "MultitrackLayerData-Array",
                rust_offset: offset_of!(MultitrackData, layers),
            },
        ],
    }),
    array_type: Some(MULTITRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultitrackData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTITRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTITRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultitrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MultitrackLayerData {
    pub _glacier_base: super::core::DataContainer,
    pub min_value: f32,
    pub max_value: f32,
    pub amplitudes: Vec<f32>,
}

pub trait MultitrackLayerDataTrait: super::core::DataContainerTrait {
    fn min_value(&self) -> &f32;
    fn min_value_mut(&mut self) -> &mut f32;
    fn max_value(&self) -> &f32;
    fn max_value_mut(&mut self) -> &mut f32;
    fn amplitudes(&self) -> &Vec<f32>;
    fn amplitudes_mut(&mut self) -> &mut Vec<f32>;
}

impl MultitrackLayerDataTrait for MultitrackLayerData {
    fn min_value(&self) -> &f32 {
        &self.min_value
    }
    fn min_value_mut(&mut self) -> &mut f32 {
        &mut self.min_value
    }
    fn max_value(&self) -> &f32 {
        &self.max_value
    }
    fn max_value_mut(&mut self) -> &mut f32 {
        &mut self.max_value
    }
    fn amplitudes(&self) -> &Vec<f32> {
        &self.amplitudes
    }
    fn amplitudes_mut(&mut self) -> &mut Vec<f32> {
        &mut self.amplitudes
    }
}

impl super::core::DataContainerTrait for MultitrackLayerData {
}

pub static MULTITRACKLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MultitrackLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultitrackLayerData, min_value),
            },
            FieldInfoData {
                name: "MaxValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MultitrackLayerData, max_value),
            },
            FieldInfoData {
                name: "Amplitudes",
                flags: MemberInfoFlags::new(144),
                field_type: "Float32-Array",
                rust_offset: offset_of!(MultitrackLayerData, amplitudes),
            },
        ],
    }),
    array_type: Some(MULTITRACKLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MultitrackLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        MULTITRACKLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MULTITRACKLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MultitrackLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MultitrackLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SynchedFadeData {
    pub _glacier_base: MusicFadeData,
    pub sync_type: MusicSyncType,
}

pub trait SynchedFadeDataTrait: MusicFadeDataTrait {
    fn sync_type(&self) -> &MusicSyncType;
    fn sync_type_mut(&mut self) -> &mut MusicSyncType;
}

impl SynchedFadeDataTrait for SynchedFadeData {
    fn sync_type(&self) -> &MusicSyncType {
        &self.sync_type
    }
    fn sync_type_mut(&mut self) -> &mut MusicSyncType {
        &mut self.sync_type
    }
}

impl MusicFadeDataTrait for SynchedFadeData {
    fn fade_out_length(&self) -> &f32 {
        self._glacier_base.fade_out_length()
    }
    fn fade_out_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_out_length_mut()
    }
    fn fade_out_type(&self) -> &MusicFadeType {
        self._glacier_base.fade_out_type()
    }
    fn fade_out_type_mut(&mut self) -> &mut MusicFadeType {
        self._glacier_base.fade_out_type_mut()
    }
    fn fade_in_length(&self) -> &f32 {
        self._glacier_base.fade_in_length()
    }
    fn fade_in_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_in_length_mut()
    }
    fn fade_in_type(&self) -> &MusicFadeType {
        self._glacier_base.fade_in_type()
    }
    fn fade_in_type_mut(&mut self) -> &mut MusicFadeType {
        self._glacier_base.fade_in_type_mut()
    }
    fn equal_power(&self) -> &bool {
        self._glacier_base.equal_power()
    }
    fn equal_power_mut(&mut self) -> &mut bool {
        self._glacier_base.equal_power_mut()
    }
}

impl super::core::DataContainerTrait for SynchedFadeData {
}

pub static SYNCHEDFADEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SynchedFadeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICFADEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SynchedFadeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SyncType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicSyncType",
                rust_offset: offset_of!(SynchedFadeData, sync_type),
            },
        ],
    }),
    array_type: Some(SYNCHEDFADEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SynchedFadeData {
    fn type_info(&self) -> &'static TypeInfo {
        SYNCHEDFADEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SYNCHEDFADEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SynchedFadeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SynchedFadeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BasicFadeData {
    pub _glacier_base: MusicFadeData,
}

pub trait BasicFadeDataTrait: MusicFadeDataTrait {
}

impl BasicFadeDataTrait for BasicFadeData {
}

impl MusicFadeDataTrait for BasicFadeData {
    fn fade_out_length(&self) -> &f32 {
        self._glacier_base.fade_out_length()
    }
    fn fade_out_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_out_length_mut()
    }
    fn fade_out_type(&self) -> &MusicFadeType {
        self._glacier_base.fade_out_type()
    }
    fn fade_out_type_mut(&mut self) -> &mut MusicFadeType {
        self._glacier_base.fade_out_type_mut()
    }
    fn fade_in_length(&self) -> &f32 {
        self._glacier_base.fade_in_length()
    }
    fn fade_in_length_mut(&mut self) -> &mut f32 {
        self._glacier_base.fade_in_length_mut()
    }
    fn fade_in_type(&self) -> &MusicFadeType {
        self._glacier_base.fade_in_type()
    }
    fn fade_in_type_mut(&mut self) -> &mut MusicFadeType {
        self._glacier_base.fade_in_type_mut()
    }
    fn equal_power(&self) -> &bool {
        self._glacier_base.equal_power()
    }
    fn equal_power_mut(&mut self) -> &mut bool {
        self._glacier_base.equal_power_mut()
    }
}

impl super::core::DataContainerTrait for BasicFadeData {
}

pub static BASICFADEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicFadeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICFADEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BasicFadeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(BASICFADEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BasicFadeData {
    fn type_info(&self) -> &'static TypeInfo {
        BASICFADEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BASICFADEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BasicFadeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BasicFadeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicFadeData {
    pub _glacier_base: super::core::DataContainer,
    pub fade_out_length: f32,
    pub fade_out_type: MusicFadeType,
    pub fade_in_length: f32,
    pub fade_in_type: MusicFadeType,
    pub equal_power: bool,
}

pub trait MusicFadeDataTrait: super::core::DataContainerTrait {
    fn fade_out_length(&self) -> &f32;
    fn fade_out_length_mut(&mut self) -> &mut f32;
    fn fade_out_type(&self) -> &MusicFadeType;
    fn fade_out_type_mut(&mut self) -> &mut MusicFadeType;
    fn fade_in_length(&self) -> &f32;
    fn fade_in_length_mut(&mut self) -> &mut f32;
    fn fade_in_type(&self) -> &MusicFadeType;
    fn fade_in_type_mut(&mut self) -> &mut MusicFadeType;
    fn equal_power(&self) -> &bool;
    fn equal_power_mut(&mut self) -> &mut bool;
}

impl MusicFadeDataTrait for MusicFadeData {
    fn fade_out_length(&self) -> &f32 {
        &self.fade_out_length
    }
    fn fade_out_length_mut(&mut self) -> &mut f32 {
        &mut self.fade_out_length
    }
    fn fade_out_type(&self) -> &MusicFadeType {
        &self.fade_out_type
    }
    fn fade_out_type_mut(&mut self) -> &mut MusicFadeType {
        &mut self.fade_out_type
    }
    fn fade_in_length(&self) -> &f32 {
        &self.fade_in_length
    }
    fn fade_in_length_mut(&mut self) -> &mut f32 {
        &mut self.fade_in_length
    }
    fn fade_in_type(&self) -> &MusicFadeType {
        &self.fade_in_type
    }
    fn fade_in_type_mut(&mut self) -> &mut MusicFadeType {
        &mut self.fade_in_type
    }
    fn equal_power(&self) -> &bool {
        &self.equal_power
    }
    fn equal_power_mut(&mut self) -> &mut bool {
        &mut self.equal_power
    }
}

impl super::core::DataContainerTrait for MusicFadeData {
}

pub static MUSICFADEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicFadeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "FadeOutLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicFadeData, fade_out_length),
            },
            FieldInfoData {
                name: "FadeOutType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicFadeType",
                rust_offset: offset_of!(MusicFadeData, fade_out_type),
            },
            FieldInfoData {
                name: "FadeInLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicFadeData, fade_in_length),
            },
            FieldInfoData {
                name: "FadeInType",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicFadeType",
                rust_offset: offset_of!(MusicFadeData, fade_in_type),
            },
            FieldInfoData {
                name: "EqualPower",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MusicFadeData, equal_power),
            },
        ],
    }),
    array_type: Some(MUSICFADEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicFadeData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICFADEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICFADEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicFadeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicFadeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MusicSyncType {
    #[default]
    MusicSyncType_Beat = 0,
    MusicSyncType_Bar = 1,
    MusicSyncType_Immediate = 2,
    MusicSyncType_Timed = 3,
}

pub static MUSICSYNCTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSyncType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICSYNCTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicSyncType {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSYNCTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICSYNCTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicSyncType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicSyncType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicStreamableData {
    pub _glacier_base: MusicPlayableData,
    pub range_value: f32,
    pub allow_range_fade: bool,
    pub restart_if_already_playing: bool,
    pub weight: i32,
    pub next_playable: Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>,
    pub on_next_playable_overlay: Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>,
    pub next_playable_fade_in_time: f32,
    pub metadata: Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>>,
}

pub trait MusicStreamableDataTrait: MusicPlayableDataTrait {
    fn range_value(&self) -> &f32;
    fn range_value_mut(&mut self) -> &mut f32;
    fn allow_range_fade(&self) -> &bool;
    fn allow_range_fade_mut(&mut self) -> &mut bool;
    fn restart_if_already_playing(&self) -> &bool;
    fn restart_if_already_playing_mut(&mut self) -> &mut bool;
    fn weight(&self) -> &i32;
    fn weight_mut(&mut self) -> &mut i32;
    fn next_playable(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn next_playable_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>>;
    fn on_next_playable_overlay(&self) -> &Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>;
    fn on_next_playable_overlay_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicOverlayDataTrait>>>;
    fn next_playable_fade_in_time(&self) -> &f32;
    fn next_playable_fade_in_time_mut(&mut self) -> &mut f32;
    fn metadata(&self) -> &Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>>;
    fn metadata_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>>;
}

impl MusicStreamableDataTrait for MusicStreamableData {
    fn range_value(&self) -> &f32 {
        &self.range_value
    }
    fn range_value_mut(&mut self) -> &mut f32 {
        &mut self.range_value
    }
    fn allow_range_fade(&self) -> &bool {
        &self.allow_range_fade
    }
    fn allow_range_fade_mut(&mut self) -> &mut bool {
        &mut self.allow_range_fade
    }
    fn restart_if_already_playing(&self) -> &bool {
        &self.restart_if_already_playing
    }
    fn restart_if_already_playing_mut(&mut self) -> &mut bool {
        &mut self.restart_if_already_playing
    }
    fn weight(&self) -> &i32 {
        &self.weight
    }
    fn weight_mut(&mut self) -> &mut i32 {
        &mut self.weight
    }
    fn next_playable(&self) -> &Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &self.next_playable
    }
    fn next_playable_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicStreamableDataTrait>>> {
        &mut self.next_playable
    }
    fn on_next_playable_overlay(&self) -> &Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        &self.on_next_playable_overlay
    }
    fn on_next_playable_overlay_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicOverlayDataTrait>>> {
        &mut self.on_next_playable_overlay
    }
    fn next_playable_fade_in_time(&self) -> &f32 {
        &self.next_playable_fade_in_time
    }
    fn next_playable_fade_in_time_mut(&mut self) -> &mut f32 {
        &mut self.next_playable_fade_in_time
    }
    fn metadata(&self) -> &Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        &self.metadata
    }
    fn metadata_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MusicMetadataBaseTrait>>> {
        &mut self.metadata
    }
}

impl MusicPlayableDataTrait for MusicStreamableData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn play_count(&self) -> &u32 {
        self._glacier_base.play_count()
    }
    fn play_count_mut(&mut self) -> &mut u32 {
        self._glacier_base.play_count_mut()
    }
    fn min_delay(&self) -> &f32 {
        self._glacier_base.min_delay()
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_delay_mut()
    }
    fn max_delay(&self) -> &f32 {
        self._glacier_base.max_delay()
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.max_delay_mut()
    }
    fn transition_time(&self) -> &f32 {
        self._glacier_base.transition_time()
    }
    fn transition_time_mut(&mut self) -> &mut f32 {
        self._glacier_base.transition_time_mut()
    }
    fn beats_per_minute(&self) -> &u32 {
        self._glacier_base.beats_per_minute()
    }
    fn beats_per_minute_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_minute_mut()
    }
    fn beats_per_bar(&self) -> &u32 {
        self._glacier_base.beats_per_bar()
    }
    fn beats_per_bar_mut(&mut self) -> &mut u32 {
        self._glacier_base.beats_per_bar_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn pitch(&self) -> &f32 {
        self._glacier_base.pitch()
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        self._glacier_base.pitch_mut()
    }
}

impl super::core::DataContainerTrait for MusicStreamableData {
}

pub static MUSICSTREAMABLEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicStreamableData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICPLAYABLEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicStreamableData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "RangeValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicStreamableData, range_value),
            },
            FieldInfoData {
                name: "AllowRangeFade",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MusicStreamableData, allow_range_fade),
            },
            FieldInfoData {
                name: "RestartIfAlreadyPlaying",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MusicStreamableData, restart_if_already_playing),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(MusicStreamableData, weight),
            },
            FieldInfoData {
                name: "NextPlayable",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicStreamableData",
                rust_offset: offset_of!(MusicStreamableData, next_playable),
            },
            FieldInfoData {
                name: "OnNextPlayableOverlay",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicOverlayData",
                rust_offset: offset_of!(MusicStreamableData, on_next_playable_overlay),
            },
            FieldInfoData {
                name: "NextPlayableFadeInTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicStreamableData, next_playable_fade_in_time),
            },
            FieldInfoData {
                name: "Metadata",
                flags: MemberInfoFlags::new(0),
                field_type: "MusicMetadataBase",
                rust_offset: offset_of!(MusicStreamableData, metadata),
            },
        ],
    }),
    array_type: Some(MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicStreamableData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICSTREAMABLEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICSTREAMABLEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicStreamableData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicStreamableData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicPlayableData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub play_count: u32,
    pub min_delay: f32,
    pub max_delay: f32,
    pub transition_time: f32,
    pub beats_per_minute: u32,
    pub beats_per_bar: u32,
    pub gain: f32,
    pub pitch: f32,
}

pub trait MusicPlayableDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn play_count(&self) -> &u32;
    fn play_count_mut(&mut self) -> &mut u32;
    fn min_delay(&self) -> &f32;
    fn min_delay_mut(&mut self) -> &mut f32;
    fn max_delay(&self) -> &f32;
    fn max_delay_mut(&mut self) -> &mut f32;
    fn transition_time(&self) -> &f32;
    fn transition_time_mut(&mut self) -> &mut f32;
    fn beats_per_minute(&self) -> &u32;
    fn beats_per_minute_mut(&mut self) -> &mut u32;
    fn beats_per_bar(&self) -> &u32;
    fn beats_per_bar_mut(&mut self) -> &mut u32;
    fn gain(&self) -> &f32;
    fn gain_mut(&mut self) -> &mut f32;
    fn pitch(&self) -> &f32;
    fn pitch_mut(&mut self) -> &mut f32;
}

impl MusicPlayableDataTrait for MusicPlayableData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn play_count(&self) -> &u32 {
        &self.play_count
    }
    fn play_count_mut(&mut self) -> &mut u32 {
        &mut self.play_count
    }
    fn min_delay(&self) -> &f32 {
        &self.min_delay
    }
    fn min_delay_mut(&mut self) -> &mut f32 {
        &mut self.min_delay
    }
    fn max_delay(&self) -> &f32 {
        &self.max_delay
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        &mut self.max_delay
    }
    fn transition_time(&self) -> &f32 {
        &self.transition_time
    }
    fn transition_time_mut(&mut self) -> &mut f32 {
        &mut self.transition_time
    }
    fn beats_per_minute(&self) -> &u32 {
        &self.beats_per_minute
    }
    fn beats_per_minute_mut(&mut self) -> &mut u32 {
        &mut self.beats_per_minute
    }
    fn beats_per_bar(&self) -> &u32 {
        &self.beats_per_bar
    }
    fn beats_per_bar_mut(&mut self) -> &mut u32 {
        &mut self.beats_per_bar
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut f32 {
        &mut self.gain
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        &mut self.pitch
    }
}

impl super::core::DataContainerTrait for MusicPlayableData {
}

pub static MUSICPLAYABLEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayableData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicPlayableData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MusicPlayableData, name),
            },
            FieldInfoData {
                name: "PlayCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicPlayableData, play_count),
            },
            FieldInfoData {
                name: "MinDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlayableData, min_delay),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlayableData, max_delay),
            },
            FieldInfoData {
                name: "TransitionTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlayableData, transition_time),
            },
            FieldInfoData {
                name: "BeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicPlayableData, beats_per_minute),
            },
            FieldInfoData {
                name: "BeatsPerBar",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicPlayableData, beats_per_bar),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlayableData, gain),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicPlayableData, pitch),
            },
        ],
    }),
    array_type: Some(MUSICPLAYABLEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicPlayableData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPLAYABLEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPLAYABLEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPlayableData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPlayableData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicMetadataChangedMessage {
}

pub trait MusicMetadataChangedMessageTrait: TypeObject {
}

impl MusicMetadataChangedMessageTrait for MusicMetadataChangedMessage {
}

pub static MUSICMETADATACHANGEDMESSAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMetadataChangedMessage",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicMetadataChangedMessage as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: None,
    alignment: 8,
};

impl TypeObject for MusicMetadataChangedMessage {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICMETADATACHANGEDMESSAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}

#[derive(Clone, Debug, Default)]
pub struct MusicMetadataBase {
    pub _glacier_base: super::core::DataContainer,
}

pub trait MusicMetadataBaseTrait: super::core::DataContainerTrait {
}

impl MusicMetadataBaseTrait for MusicMetadataBase {
}

impl super::core::DataContainerTrait for MusicMetadataBase {
}

pub static MUSICMETADATABASE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMetadataBase",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicMetadataBase as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MUSICMETADATABASE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicMetadataBase {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICMETADATABASE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICMETADATABASE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicMetadataBase-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicMetadataBase"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicParameterData {
    pub _glacier_base: MusicInputData,
    pub default_value: f32,
}

pub trait MusicParameterDataTrait: MusicInputDataTrait {
    fn default_value(&self) -> &f32;
    fn default_value_mut(&mut self) -> &mut f32;
}

impl MusicParameterDataTrait for MusicParameterData {
    fn default_value(&self) -> &f32 {
        &self.default_value
    }
    fn default_value_mut(&mut self) -> &mut f32 {
        &mut self.default_value
    }
}

impl MusicInputDataTrait for MusicParameterData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
}

impl super::core::DataContainerTrait for MusicParameterData {
}

pub static MUSICPARAMETERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicParameterData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICINPUTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicParameterData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DefaultValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MusicParameterData, default_value),
            },
        ],
    }),
    array_type: Some(MUSICPARAMETERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicParameterData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPARAMETERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICPARAMETERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicParameterData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicParameterData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicEventData {
    pub _glacier_base: MusicInputData,
}

pub trait MusicEventDataTrait: MusicInputDataTrait {
}

impl MusicEventDataTrait for MusicEventData {
}

impl MusicInputDataTrait for MusicEventData {
    fn name(&self) -> &String {
        self._glacier_base.name()
    }
    fn name_mut(&mut self) -> &mut String {
        self._glacier_base.name_mut()
    }
    fn name_hash(&self) -> &u32 {
        self._glacier_base.name_hash()
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.name_hash_mut()
    }
}

impl super::core::DataContainerTrait for MusicEventData {
}

pub static MUSICEVENTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicEventData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(MUSICINPUTDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicEventData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(MUSICEVENTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicEventData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICEVENTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICEVENTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicEventData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicEventData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MusicInputData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub name_hash: u32,
}

pub trait MusicInputDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn name_hash(&self) -> &u32;
    fn name_hash_mut(&mut self) -> &mut u32;
}

impl MusicInputDataTrait for MusicInputData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn name_hash(&self) -> &u32 {
        &self.name_hash
    }
    fn name_hash_mut(&mut self) -> &mut u32 {
        &mut self.name_hash
    }
}

impl super::core::DataContainerTrait for MusicInputData {
}

pub static MUSICINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInputData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MusicInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MusicInputData, name),
            },
            FieldInfoData {
                name: "NameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MusicInputData, name_hash),
            },
        ],
    }),
    array_type: Some(MUSICINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MusicInputData {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MUSICINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MusicPhraseSelectionType {
    #[default]
    MusicPhraseSelectionType_PlayFirstAndShuffle = 0,
    MusicPhraseSelectionType_PlayAllAndShuffle = 1,
    MusicPhraseSelectionType_Random = 2,
    MusicPhraseSelectionType_Range = 3,
    MusicPhraseSelectionType_Sequential = 4,
    MusicPhraseSelectionType_Shuffle = 5,
    MusicPhraseSelectionType_Weighted = 6,
}

pub static MUSICPHRASESELECTIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseSelectionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MUSICPHRASESELECTIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MusicPhraseSelectionType {
    fn type_info(&self) -> &'static TypeInfo {
        MUSICPHRASESELECTIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MUSICPHRASESELECTIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MusicPhraseSelectionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MusicPhraseSelectionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextLinkEntityData {
    pub _glacier_base: super::entity::EntityData,
}

pub trait SoundContextLinkEntityDataTrait: super::entity::EntityDataTrait {
}

impl SoundContextLinkEntityDataTrait for SoundContextLinkEntityData {
}

impl super::entity::EntityDataTrait for SoundContextLinkEntityData {
}

impl super::entity::GameObjectDataTrait for SoundContextLinkEntityData {
}

impl super::core::DataBusPeerTrait for SoundContextLinkEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundContextLinkEntityData {
}

impl super::core::DataContainerTrait for SoundContextLinkEntityData {
}

pub static SOUNDCONTEXTLINKENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextLinkEntityData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDCONTEXTLINKENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextLinkEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTLINKENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTLINKENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextLinkEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextLinkEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundContextEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub context_group: Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>,
    pub activate_on_creation: bool,
}

pub trait SoundContextEntityDataTrait: super::entity::EntityDataTrait {
    fn context_group(&self) -> &Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>;
    fn context_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>>;
    fn activate_on_creation(&self) -> &bool;
    fn activate_on_creation_mut(&mut self) -> &mut bool;
}

impl SoundContextEntityDataTrait for SoundContextEntityData {
    fn context_group(&self) -> &Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>> {
        &self.context_group
    }
    fn context_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundContextGroupDataTrait>>> {
        &mut self.context_group
    }
    fn activate_on_creation(&self) -> &bool {
        &self.activate_on_creation
    }
    fn activate_on_creation_mut(&mut self) -> &mut bool {
        &mut self.activate_on_creation
    }
}

impl super::entity::EntityDataTrait for SoundContextEntityData {
}

impl super::entity::GameObjectDataTrait for SoundContextEntityData {
}

impl super::core::DataBusPeerTrait for SoundContextEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundContextEntityData {
}

impl super::core::DataContainerTrait for SoundContextEntityData {
}

pub static SOUNDCONTEXTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundContextEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ContextGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundContextGroupData",
                rust_offset: offset_of!(SoundContextEntityData, context_group),
            },
            FieldInfoData {
                name: "ActivateOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundContextEntityData, activate_on_creation),
            },
        ],
    }),
    array_type: Some(SOUNDCONTEXTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundContextEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDCONTEXTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDCONTEXTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundContextEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundContextEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub activate_on_creation: bool,
    pub accumulated_inputs: bool,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
}

pub trait MixerEntityDataTrait: super::entity::EntityDataTrait {
    fn activate_on_creation(&self) -> &bool;
    fn activate_on_creation_mut(&mut self) -> &mut bool;
    fn accumulated_inputs(&self) -> &bool;
    fn accumulated_inputs_mut(&mut self) -> &mut bool;
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
}

impl MixerEntityDataTrait for MixerEntityData {
    fn activate_on_creation(&self) -> &bool {
        &self.activate_on_creation
    }
    fn activate_on_creation_mut(&mut self) -> &mut bool {
        &mut self.activate_on_creation
    }
    fn accumulated_inputs(&self) -> &bool {
        &self.accumulated_inputs
    }
    fn accumulated_inputs_mut(&mut self) -> &mut bool {
        &mut self.accumulated_inputs
    }
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
}

impl super::entity::EntityDataTrait for MixerEntityData {
}

impl super::entity::GameObjectDataTrait for MixerEntityData {
}

impl super::core::DataBusPeerTrait for MixerEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for MixerEntityData {
}

impl super::core::DataContainerTrait for MixerEntityData {
}

pub static MIXERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ActivateOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerEntityData, activate_on_creation),
            },
            FieldInfoData {
                name: "AccumulatedInputs",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MixerEntityData, accumulated_inputs),
            },
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(MixerEntityData, mixer),
            },
        ],
    }),
    array_type: Some(MIXERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LoadingMusicEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub sound_guid: glacier_util::guid::Guid,
    pub bundle_unique_id: String,
    pub load_on_creation: bool,
}

pub trait LoadingMusicEntityDataTrait: super::entity::EntityDataTrait {
    fn sound_guid(&self) -> &glacier_util::guid::Guid;
    fn sound_guid_mut(&mut self) -> &mut glacier_util::guid::Guid;
    fn bundle_unique_id(&self) -> &String;
    fn bundle_unique_id_mut(&mut self) -> &mut String;
    fn load_on_creation(&self) -> &bool;
    fn load_on_creation_mut(&mut self) -> &mut bool;
}

impl LoadingMusicEntityDataTrait for LoadingMusicEntityData {
    fn sound_guid(&self) -> &glacier_util::guid::Guid {
        &self.sound_guid
    }
    fn sound_guid_mut(&mut self) -> &mut glacier_util::guid::Guid {
        &mut self.sound_guid
    }
    fn bundle_unique_id(&self) -> &String {
        &self.bundle_unique_id
    }
    fn bundle_unique_id_mut(&mut self) -> &mut String {
        &mut self.bundle_unique_id
    }
    fn load_on_creation(&self) -> &bool {
        &self.load_on_creation
    }
    fn load_on_creation_mut(&mut self) -> &mut bool {
        &mut self.load_on_creation
    }
}

impl super::entity::EntityDataTrait for LoadingMusicEntityData {
}

impl super::entity::GameObjectDataTrait for LoadingMusicEntityData {
}

impl super::core::DataBusPeerTrait for LoadingMusicEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for LoadingMusicEntityData {
}

impl super::core::DataContainerTrait for LoadingMusicEntityData {
}

pub static LOADINGMUSICENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LoadingMusicEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SoundGuid",
                flags: MemberInfoFlags::new(0),
                field_type: "Guid",
                rust_offset: offset_of!(LoadingMusicEntityData, sound_guid),
            },
            FieldInfoData {
                name: "BundleUniqueId",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(LoadingMusicEntityData, bundle_unique_id),
            },
            FieldInfoData {
                name: "LoadOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(LoadingMusicEntityData, load_on_creation),
            },
        ],
    }),
    array_type: Some(LOADINGMUSICENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LoadingMusicEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        LOADINGMUSICENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOADINGMUSICENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LoadingMusicEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LoadingMusicEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundPauseEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub exclusion_list: Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>>,
}

pub trait SoundPauseEntityDataTrait: super::entity::EntityDataTrait {
    fn exclusion_list(&self) -> &Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>>;
    fn exclusion_list_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>>;
}

impl SoundPauseEntityDataTrait for SoundPauseEntityData {
    fn exclusion_list(&self) -> &Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>> {
        &self.exclusion_list
    }
    fn exclusion_list_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixGroupTrait>>>> {
        &mut self.exclusion_list
    }
}

impl super::entity::EntityDataTrait for SoundPauseEntityData {
}

impl super::entity::GameObjectDataTrait for SoundPauseEntityData {
}

impl super::core::DataBusPeerTrait for SoundPauseEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundPauseEntityData {
}

impl super::core::DataContainerTrait for SoundPauseEntityData {
}

pub static SOUNDPAUSEENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundPauseEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ExclusionList",
                flags: MemberInfoFlags::new(144),
                field_type: "MixGroup-Array",
                rust_offset: offset_of!(SoundPauseEntityData, exclusion_list),
            },
        ],
    }),
    array_type: Some(SOUNDPAUSEENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundPauseEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDPAUSEENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDPAUSEENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundPauseEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundPauseEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundHdrEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub hdr_setting: Option<Arc<Mutex<dyn HdrSettingTrait>>>,
    pub apply_setting_on_creation: bool,
}

pub trait SoundHdrEntityDataTrait: super::entity::EntityDataTrait {
    fn hdr_setting(&self) -> &Option<Arc<Mutex<dyn HdrSettingTrait>>>;
    fn hdr_setting_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HdrSettingTrait>>>;
    fn apply_setting_on_creation(&self) -> &bool;
    fn apply_setting_on_creation_mut(&mut self) -> &mut bool;
}

impl SoundHdrEntityDataTrait for SoundHdrEntityData {
    fn hdr_setting(&self) -> &Option<Arc<Mutex<dyn HdrSettingTrait>>> {
        &self.hdr_setting
    }
    fn hdr_setting_mut(&mut self) -> &mut Option<Arc<Mutex<dyn HdrSettingTrait>>> {
        &mut self.hdr_setting
    }
    fn apply_setting_on_creation(&self) -> &bool {
        &self.apply_setting_on_creation
    }
    fn apply_setting_on_creation_mut(&mut self) -> &mut bool {
        &mut self.apply_setting_on_creation
    }
}

impl super::entity::EntityDataTrait for SoundHdrEntityData {
}

impl super::entity::GameObjectDataTrait for SoundHdrEntityData {
}

impl super::core::DataBusPeerTrait for SoundHdrEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundHdrEntityData {
}

impl super::core::DataContainerTrait for SoundHdrEntityData {
}

pub static SOUNDHDRENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundHdrEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "HdrSetting",
                flags: MemberInfoFlags::new(0),
                field_type: "HdrSetting",
                rust_offset: offset_of!(SoundHdrEntityData, hdr_setting),
            },
            FieldInfoData {
                name: "ApplySettingOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundHdrEntityData, apply_setting_on_creation),
            },
        ],
    }),
    array_type: Some(SOUNDHDRENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundHdrEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDHDRENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDHDRENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundHdrEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundHdrEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IrReverbEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub impulse_response: Option<Arc<Mutex<dyn ImpulseResponseAssetTrait>>>,
    pub gain: f32,
    pub volume: f32,
    pub fade_curve: FadeCurveType,
    pub is_dominant: bool,
}

pub trait IrReverbEntityDataTrait: super::entity::EntityDataTrait {
    fn impulse_response(&self) -> &Option<Arc<Mutex<dyn ImpulseResponseAssetTrait>>>;
    fn impulse_response_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ImpulseResponseAssetTrait>>>;
    fn gain(&self) -> &f32;
    fn gain_mut(&mut self) -> &mut f32;
    fn volume(&self) -> &f32;
    fn volume_mut(&mut self) -> &mut f32;
    fn fade_curve(&self) -> &FadeCurveType;
    fn fade_curve_mut(&mut self) -> &mut FadeCurveType;
    fn is_dominant(&self) -> &bool;
    fn is_dominant_mut(&mut self) -> &mut bool;
}

impl IrReverbEntityDataTrait for IrReverbEntityData {
    fn impulse_response(&self) -> &Option<Arc<Mutex<dyn ImpulseResponseAssetTrait>>> {
        &self.impulse_response
    }
    fn impulse_response_mut(&mut self) -> &mut Option<Arc<Mutex<dyn ImpulseResponseAssetTrait>>> {
        &mut self.impulse_response
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut f32 {
        &mut self.gain
    }
    fn volume(&self) -> &f32 {
        &self.volume
    }
    fn volume_mut(&mut self) -> &mut f32 {
        &mut self.volume
    }
    fn fade_curve(&self) -> &FadeCurveType {
        &self.fade_curve
    }
    fn fade_curve_mut(&mut self) -> &mut FadeCurveType {
        &mut self.fade_curve
    }
    fn is_dominant(&self) -> &bool {
        &self.is_dominant
    }
    fn is_dominant_mut(&mut self) -> &mut bool {
        &mut self.is_dominant
    }
}

impl super::entity::EntityDataTrait for IrReverbEntityData {
}

impl super::entity::GameObjectDataTrait for IrReverbEntityData {
}

impl super::core::DataBusPeerTrait for IrReverbEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for IrReverbEntityData {
}

impl super::core::DataContainerTrait for IrReverbEntityData {
}

pub static IRREVERBENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IrReverbEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ImpulseResponse",
                flags: MemberInfoFlags::new(0),
                field_type: "ImpulseResponseAsset",
                rust_offset: offset_of!(IrReverbEntityData, impulse_response),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IrReverbEntityData, gain),
            },
            FieldInfoData {
                name: "Volume",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IrReverbEntityData, volume),
            },
            FieldInfoData {
                name: "FadeCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FadeCurveType",
                rust_offset: offset_of!(IrReverbEntityData, fade_curve),
            },
            FieldInfoData {
                name: "IsDominant",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IrReverbEntityData, is_dominant),
            },
        ],
    }),
    array_type: Some(IRREVERBENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IrReverbEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        IRREVERBENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IRREVERBENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VoiceOverConversationGroupEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub queue_group: Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>,
}

pub trait VoiceOverConversationGroupEntityDataTrait: super::entity::EntityDataTrait {
    fn queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
    fn queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>>;
}

impl VoiceOverConversationGroupEntityDataTrait for VoiceOverConversationGroupEntityData {
    fn queue_group(&self) -> &Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &self.queue_group
    }
    fn queue_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn VoiceOverConversationQueueGroupTrait>>> {
        &mut self.queue_group
    }
}

impl super::entity::EntityDataTrait for VoiceOverConversationGroupEntityData {
}

impl super::entity::GameObjectDataTrait for VoiceOverConversationGroupEntityData {
}

impl super::core::DataBusPeerTrait for VoiceOverConversationGroupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for VoiceOverConversationGroupEntityData {
}

impl super::core::DataContainerTrait for VoiceOverConversationGroupEntityData {
}

pub static VOICEOVERCONVERSATIONGROUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VoiceOverConversationGroupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "QueueGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "VoiceOverConversationQueueGroup",
                rust_offset: offset_of!(VoiceOverConversationGroupEntityData, queue_group),
            },
        ],
    }),
    array_type: Some(VOICEOVERCONVERSATIONGROUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VoiceOverConversationGroupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        VOICEOVERCONVERSATIONGROUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VOICEOVERCONVERSATIONGROUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VoiceOverConversationGroupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VoiceOverConversationGroupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeSetupEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub setup: Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>,
}

pub trait SoundScopeSetupEntityDataTrait: super::entity::EntityDataTrait {
    fn setup(&self) -> &Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>;
    fn setup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>>;
}

impl SoundScopeSetupEntityDataTrait for SoundScopeSetupEntityData {
    fn setup(&self) -> &Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>> {
        &self.setup
    }
    fn setup_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeSetupDataTrait>>> {
        &mut self.setup
    }
}

impl super::entity::EntityDataTrait for SoundScopeSetupEntityData {
}

impl super::entity::GameObjectDataTrait for SoundScopeSetupEntityData {
}

impl super::core::DataBusPeerTrait for SoundScopeSetupEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundScopeSetupEntityData {
}

impl super::core::DataContainerTrait for SoundScopeSetupEntityData {
}

pub static SOUNDSCOPESETUPENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeSetupEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Setup",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeSetupData",
                rust_offset: offset_of!(SoundScopeSetupEntityData, setup),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESETUPENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeSetupEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPESETUPENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPESETUPENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeSetupEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundDataEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub data_assets: Vec<Option<Arc<Mutex<dyn SoundDataAssetTrait>>>>,
}

pub trait SoundDataEntityDataTrait: super::entity::EntityDataTrait {
    fn data_assets(&self) -> &Vec<Option<Arc<Mutex<dyn SoundDataAssetTrait>>>>;
    fn data_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundDataAssetTrait>>>>;
}

impl SoundDataEntityDataTrait for SoundDataEntityData {
    fn data_assets(&self) -> &Vec<Option<Arc<Mutex<dyn SoundDataAssetTrait>>>> {
        &self.data_assets
    }
    fn data_assets_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundDataAssetTrait>>>> {
        &mut self.data_assets
    }
}

impl super::entity::EntityDataTrait for SoundDataEntityData {
}

impl super::entity::GameObjectDataTrait for SoundDataEntityData {
}

impl super::core::DataBusPeerTrait for SoundDataEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundDataEntityData {
}

impl super::core::DataContainerTrait for SoundDataEntityData {
}

pub static SOUNDDATAENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundDataEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "DataAssets",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundDataAsset-Array",
                rust_offset: offset_of!(SoundDataEntityData, data_assets),
            },
        ],
    }),
    array_type: Some(SOUNDDATAENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundDataEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDDATAENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDDATAENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundDataEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundDataEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundMasterEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub master: Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>>,
    pub support_dynamic_propeties: bool,
}

pub trait SoundMasterEntityDataTrait: super::entity::EntityDataTrait {
    fn master(&self) -> &Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>>;
    fn master_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>>;
    fn support_dynamic_propeties(&self) -> &bool;
    fn support_dynamic_propeties_mut(&mut self) -> &mut bool;
}

impl SoundMasterEntityDataTrait for SoundMasterEntityData {
    fn master(&self) -> &Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>> {
        &self.master
    }
    fn master_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundMasterPatchAssetTrait>>> {
        &mut self.master
    }
    fn support_dynamic_propeties(&self) -> &bool {
        &self.support_dynamic_propeties
    }
    fn support_dynamic_propeties_mut(&mut self) -> &mut bool {
        &mut self.support_dynamic_propeties
    }
}

impl super::entity::EntityDataTrait for SoundMasterEntityData {
}

impl super::entity::GameObjectDataTrait for SoundMasterEntityData {
}

impl super::core::DataBusPeerTrait for SoundMasterEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundMasterEntityData {
}

impl super::core::DataContainerTrait for SoundMasterEntityData {
}

pub static SOUNDMASTERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundMasterEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Master",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundMasterPatchAsset",
                rust_offset: offset_of!(SoundMasterEntityData, master),
            },
            FieldInfoData {
                name: "SupportDynamicPropeties",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundMasterEntityData, support_dynamic_propeties),
            },
        ],
    }),
    array_type: Some(SOUNDMASTERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundMasterEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDMASTERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDMASTERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundMasterEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundMasterEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub transform: super::core::LinearTransform,
    pub sound: Option<Arc<Mutex<dyn SoundAssetTrait>>>,
    pub play_on_creation: bool,
    pub enable_on_creation: bool,
    pub use_parent_transform: bool,
    pub forget_on_destroy: bool,
    pub master_amplitude: f32,
}

pub trait SoundEntityDataTrait: super::entity::EntityDataTrait {
    fn transform(&self) -> &super::core::LinearTransform;
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform;
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn play_on_creation(&self) -> &bool;
    fn play_on_creation_mut(&mut self) -> &mut bool;
    fn enable_on_creation(&self) -> &bool;
    fn enable_on_creation_mut(&mut self) -> &mut bool;
    fn use_parent_transform(&self) -> &bool;
    fn use_parent_transform_mut(&mut self) -> &mut bool;
    fn forget_on_destroy(&self) -> &bool;
    fn forget_on_destroy_mut(&mut self) -> &mut bool;
    fn master_amplitude(&self) -> &f32;
    fn master_amplitude_mut(&mut self) -> &mut f32;
}

impl SoundEntityDataTrait for SoundEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        &self.transform
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        &mut self.transform
    }
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &mut self.sound
    }
    fn play_on_creation(&self) -> &bool {
        &self.play_on_creation
    }
    fn play_on_creation_mut(&mut self) -> &mut bool {
        &mut self.play_on_creation
    }
    fn enable_on_creation(&self) -> &bool {
        &self.enable_on_creation
    }
    fn enable_on_creation_mut(&mut self) -> &mut bool {
        &mut self.enable_on_creation
    }
    fn use_parent_transform(&self) -> &bool {
        &self.use_parent_transform
    }
    fn use_parent_transform_mut(&mut self) -> &mut bool {
        &mut self.use_parent_transform
    }
    fn forget_on_destroy(&self) -> &bool {
        &self.forget_on_destroy
    }
    fn forget_on_destroy_mut(&mut self) -> &mut bool {
        &mut self.forget_on_destroy
    }
    fn master_amplitude(&self) -> &f32 {
        &self.master_amplitude
    }
    fn master_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.master_amplitude
    }
}

impl super::entity::EntityDataTrait for SoundEntityData {
}

impl super::entity::GameObjectDataTrait for SoundEntityData {
}

impl super::core::DataBusPeerTrait for SoundEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityData {
}

impl super::core::DataContainerTrait for SoundEntityData {
}

pub static SOUNDENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Transform",
                flags: MemberInfoFlags::new(0),
                field_type: "LinearTransform",
                rust_offset: offset_of!(SoundEntityData, transform),
            },
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoundEntityData, sound),
            },
            FieldInfoData {
                name: "PlayOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityData, play_on_creation),
            },
            FieldInfoData {
                name: "EnableOnCreation",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityData, enable_on_creation),
            },
            FieldInfoData {
                name: "UseParentTransform",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityData, use_parent_transform),
            },
            FieldInfoData {
                name: "ForgetOnDestroy",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityData, forget_on_destroy),
            },
            FieldInfoData {
                name: "MasterAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundEntityData, master_amplitude),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoundEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEffectEntityData {
    pub _glacier_base: super::entity::ChildEffectEntityData,
    pub sound: Option<Arc<Mutex<dyn SoundAssetTrait>>>,
    pub use_default_stop_event: bool,
}

pub trait SoundEffectEntityDataTrait: super::entity::ChildEffectEntityDataTrait {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn use_default_stop_event(&self) -> &bool;
    fn use_default_stop_event_mut(&mut self) -> &mut bool;
}

impl SoundEffectEntityDataTrait for SoundEffectEntityData {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &mut self.sound
    }
    fn use_default_stop_event(&self) -> &bool {
        &self.use_default_stop_event
    }
    fn use_default_stop_event_mut(&mut self) -> &mut bool {
        &mut self.use_default_stop_event
    }
}

impl super::entity::ChildEffectEntityDataTrait for SoundEffectEntityData {
    fn components(&self) -> &Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components()
    }
    fn components_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::entity::GameObjectDataTrait>>>> {
        self._glacier_base.components_mut()
    }
    fn start_delay(&self) -> &f32 {
        self._glacier_base.start_delay()
    }
    fn start_delay_mut(&mut self) -> &mut f32 {
        self._glacier_base.start_delay_mut()
    }
    fn attach_to_spawn_surface(&self) -> &bool {
        self._glacier_base.attach_to_spawn_surface()
    }
    fn attach_to_spawn_surface_mut(&mut self) -> &mut bool {
        self._glacier_base.attach_to_spawn_surface_mut()
    }
    fn enable(&self) -> &super::core::QualityScalableBool {
        self._glacier_base.enable()
    }
    fn enable_mut(&mut self) -> &mut super::core::QualityScalableBool {
        self._glacier_base.enable_mut()
    }
    fn override_draw_order(&self) -> &bool {
        self._glacier_base.override_draw_order()
    }
    fn override_draw_order_mut(&mut self) -> &mut bool {
        self._glacier_base.override_draw_order_mut()
    }
    fn keep_alive(&self) -> &bool {
        self._glacier_base.keep_alive()
    }
    fn keep_alive_mut(&mut self) -> &mut bool {
        self._glacier_base.keep_alive_mut()
    }
}

impl super::entity::SpatialEntityDataTrait for SoundEffectEntityData {
    fn transform(&self) -> &super::core::LinearTransform {
        self._glacier_base.transform()
    }
    fn transform_mut(&mut self) -> &mut super::core::LinearTransform {
        self._glacier_base.transform_mut()
    }
}

impl super::entity::EntityDataTrait for SoundEffectEntityData {
}

impl super::entity::GameObjectDataTrait for SoundEffectEntityData {
}

impl super::core::DataBusPeerTrait for SoundEffectEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEffectEntityData {
}

impl super::core::DataContainerTrait for SoundEffectEntityData {
}

pub static SOUNDEFFECTENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEffectEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::CHILDEFFECTENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEffectEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoundEffectEntityData, sound),
            },
            FieldInfoData {
                name: "UseDefaultStopEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEffectEntityData, use_default_stop_event),
            },
        ],
    }),
    array_type: Some(SOUNDEFFECTENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SoundEffectEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDEFFECTENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDEFFECTENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEffectEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEffectEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub sound: Option<Arc<Mutex<dyn SoundAssetTrait>>>,
    pub force_stop_with_timeline: bool,
    pub fire_default_stop_event_on_complete: bool,
    pub layer_tracks: Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>,
    pub guide_track_source: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub skipped_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub buffer_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub buffered_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub seek_to_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub seek_to_parameter: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub sound_length_parameter: Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>,
    pub finished_event: Option<Arc<Mutex<dyn AudioGraphEventTrait>>>,
    pub guide_track_priority: i32,
}

pub trait SoundEntityTrackDataTrait: super::timeline::TimelineTrackDataTrait {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>>;
    fn force_stop_with_timeline(&self) -> &bool;
    fn force_stop_with_timeline_mut(&mut self) -> &mut bool;
    fn fire_default_stop_event_on_complete(&self) -> &bool;
    fn fire_default_stop_event_on_complete_mut(&mut self) -> &mut bool;
    fn layer_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>>;
    fn guide_track_source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn guide_track_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn skipped_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn skipped_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn buffer_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn buffer_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn buffered_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn buffered_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn seek_to_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn seek_to_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn seek_to_parameter(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn seek_to_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn sound_length_parameter(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn sound_length_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>;
    fn finished_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn finished_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>>;
    fn guide_track_priority(&self) -> &i32;
    fn guide_track_priority_mut(&mut self) -> &mut i32;
}

impl SoundEntityTrackDataTrait for SoundEntityTrackData {
    fn sound(&self) -> &Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &self.sound
    }
    fn sound_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundAssetTrait>>> {
        &mut self.sound
    }
    fn force_stop_with_timeline(&self) -> &bool {
        &self.force_stop_with_timeline
    }
    fn force_stop_with_timeline_mut(&mut self) -> &mut bool {
        &mut self.force_stop_with_timeline
    }
    fn fire_default_stop_event_on_complete(&self) -> &bool {
        &self.fire_default_stop_event_on_complete
    }
    fn fire_default_stop_event_on_complete_mut(&mut self) -> &mut bool {
        &mut self.fire_default_stop_event_on_complete
    }
    fn layer_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &self.layer_tracks
    }
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataTrait>>>> {
        &mut self.layer_tracks
    }
    fn guide_track_source(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.guide_track_source
    }
    fn guide_track_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.guide_track_source
    }
    fn skipped_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.skipped_event
    }
    fn skipped_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.skipped_event
    }
    fn buffer_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.buffer_event
    }
    fn buffer_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.buffer_event
    }
    fn buffered_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.buffered_event
    }
    fn buffered_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.buffered_event
    }
    fn seek_to_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.seek_to_event
    }
    fn seek_to_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.seek_to_event
    }
    fn seek_to_parameter(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.seek_to_parameter
    }
    fn seek_to_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.seek_to_parameter
    }
    fn sound_length_parameter(&self) -> &Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &self.sound_length_parameter
    }
    fn sound_length_parameter_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphParameterTrait>>> {
        &mut self.sound_length_parameter
    }
    fn finished_event(&self) -> &Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &self.finished_event
    }
    fn finished_event_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphEventTrait>>> {
        &mut self.finished_event
    }
    fn guide_track_priority(&self) -> &i32 {
        &self.guide_track_priority
    }
    fn guide_track_priority_mut(&mut self) -> &mut i32 {
        &mut self.guide_track_priority
    }
}

impl super::timeline::TimelineTrackDataTrait for SoundEntityTrackData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoundEntityTrackData {
}

impl super::core::DataBusPeerTrait for SoundEntityTrackData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityTrackData {
}

impl super::core::DataContainerTrait for SoundEntityTrackData {
}

pub static SOUNDENTITYTRACKDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Sound",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundAsset",
                rust_offset: offset_of!(SoundEntityTrackData, sound),
            },
            FieldInfoData {
                name: "ForceStopWithTimeline",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityTrackData, force_stop_with_timeline),
            },
            FieldInfoData {
                name: "FireDefaultStopEventOnComplete",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityTrackData, fire_default_stop_event_on_complete),
            },
            FieldInfoData {
                name: "LayerTracks",
                flags: MemberInfoFlags::new(144),
                field_type: "TimelineTrackData-Array",
                rust_offset: offset_of!(SoundEntityTrackData, layer_tracks),
            },
            FieldInfoData {
                name: "GuideTrackSource",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(SoundEntityTrackData, guide_track_source),
            },
            FieldInfoData {
                name: "SkippedEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundEntityTrackData, skipped_event),
            },
            FieldInfoData {
                name: "BufferEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundEntityTrackData, buffer_event),
            },
            FieldInfoData {
                name: "BufferedEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundEntityTrackData, buffered_event),
            },
            FieldInfoData {
                name: "SeekToEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundEntityTrackData, seek_to_event),
            },
            FieldInfoData {
                name: "SeekToParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(SoundEntityTrackData, seek_to_parameter),
            },
            FieldInfoData {
                name: "SoundLengthParameter",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphParameter",
                rust_offset: offset_of!(SoundEntityTrackData, sound_length_parameter),
            },
            FieldInfoData {
                name: "FinishedEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphEvent",
                rust_offset: offset_of!(SoundEntityTrackData, finished_event),
            },
            FieldInfoData {
                name: "GuideTrackPriority",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoundEntityTrackData, guide_track_priority),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackAssetLayerData {
    pub _glacier_base: SoundEntityTrackLayerData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn SoundEntityTrackAssetKeyframeDataTrait>>>>,
    pub fire_events_upon_skip: bool,
}

pub trait SoundEntityTrackAssetLayerDataTrait: SoundEntityTrackLayerDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn SoundEntityTrackAssetKeyframeDataTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundEntityTrackAssetKeyframeDataTrait>>>>;
    fn fire_events_upon_skip(&self) -> &bool;
    fn fire_events_upon_skip_mut(&mut self) -> &mut bool;
}

impl SoundEntityTrackAssetLayerDataTrait for SoundEntityTrackAssetLayerData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn SoundEntityTrackAssetKeyframeDataTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundEntityTrackAssetKeyframeDataTrait>>>> {
        &mut self.keyframes
    }
    fn fire_events_upon_skip(&self) -> &bool {
        &self.fire_events_upon_skip
    }
    fn fire_events_upon_skip_mut(&mut self) -> &mut bool {
        &mut self.fire_events_upon_skip
    }
}

impl SoundEntityTrackLayerDataTrait for SoundEntityTrackAssetLayerData {
    fn layer_hash(&self) -> &u32 {
        self._glacier_base.layer_hash()
    }
    fn layer_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.layer_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for SoundEntityTrackAssetLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoundEntityTrackAssetLayerData {
}

impl super::core::DataBusPeerTrait for SoundEntityTrackAssetLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityTrackAssetLayerData {
}

impl super::core::DataContainerTrait for SoundEntityTrackAssetLayerData {
}

pub static SOUNDENTITYTRACKASSETLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackAssetLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundEntityTrackAssetKeyframeData-Array",
                rust_offset: offset_of!(SoundEntityTrackAssetLayerData, keyframes),
            },
            FieldInfoData {
                name: "FireEventsUponSkip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityTrackAssetLayerData, fire_events_upon_skip),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKASSETLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackAssetLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKASSETLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKASSETLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackAssetLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackParameterLayerData {
    pub _glacier_base: SoundEntityTrackLayerData,
    pub curve_data: Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>>,
}

pub trait SoundEntityTrackParameterLayerDataTrait: SoundEntityTrackLayerDataTrait {
    fn curve_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>>;
    fn curve_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>>;
}

impl SoundEntityTrackParameterLayerDataTrait for SoundEntityTrackParameterLayerData {
    fn curve_data(&self) -> &Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>> {
        &self.curve_data
    }
    fn curve_data_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::timeline::CurveDataTrait>>> {
        &mut self.curve_data
    }
}

impl SoundEntityTrackLayerDataTrait for SoundEntityTrackParameterLayerData {
    fn layer_hash(&self) -> &u32 {
        self._glacier_base.layer_hash()
    }
    fn layer_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.layer_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for SoundEntityTrackParameterLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoundEntityTrackParameterLayerData {
}

impl super::core::DataBusPeerTrait for SoundEntityTrackParameterLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityTrackParameterLayerData {
}

impl super::core::DataContainerTrait for SoundEntityTrackParameterLayerData {
}

pub static SOUNDENTITYTRACKPARAMETERLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackParameterLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "CurveData",
                flags: MemberInfoFlags::new(0),
                field_type: "CurveData",
                rust_offset: offset_of!(SoundEntityTrackParameterLayerData, curve_data),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKPARAMETERLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackParameterLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKPARAMETERLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKPARAMETERLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackParameterLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackParameterLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackEventLayerData {
    pub _glacier_base: SoundEntityTrackLayerData,
    pub keyframes: Vec<Option<Arc<Mutex<dyn SoundEntityTrackEventKeyframeDataTrait>>>>,
    pub fire_events_upon_skip: bool,
}

pub trait SoundEntityTrackEventLayerDataTrait: SoundEntityTrackLayerDataTrait {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn SoundEntityTrackEventKeyframeDataTrait>>>>;
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundEntityTrackEventKeyframeDataTrait>>>>;
    fn fire_events_upon_skip(&self) -> &bool;
    fn fire_events_upon_skip_mut(&mut self) -> &mut bool;
}

impl SoundEntityTrackEventLayerDataTrait for SoundEntityTrackEventLayerData {
    fn keyframes(&self) -> &Vec<Option<Arc<Mutex<dyn SoundEntityTrackEventKeyframeDataTrait>>>> {
        &self.keyframes
    }
    fn keyframes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundEntityTrackEventKeyframeDataTrait>>>> {
        &mut self.keyframes
    }
    fn fire_events_upon_skip(&self) -> &bool {
        &self.fire_events_upon_skip
    }
    fn fire_events_upon_skip_mut(&mut self) -> &mut bool {
        &mut self.fire_events_upon_skip
    }
}

impl SoundEntityTrackLayerDataTrait for SoundEntityTrackEventLayerData {
    fn layer_hash(&self) -> &u32 {
        self._glacier_base.layer_hash()
    }
    fn layer_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.layer_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for SoundEntityTrackEventLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoundEntityTrackEventLayerData {
}

impl super::core::DataBusPeerTrait for SoundEntityTrackEventLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityTrackEventLayerData {
}

impl super::core::DataContainerTrait for SoundEntityTrackEventLayerData {
}

pub static SOUNDENTITYTRACKEVENTLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKLAYERDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackEventLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Keyframes",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundEntityTrackEventKeyframeData-Array",
                rust_offset: offset_of!(SoundEntityTrackEventLayerData, keyframes),
            },
            FieldInfoData {
                name: "FireEventsUponSkip",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityTrackEventLayerData, fire_events_upon_skip),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKEVENTLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackEventLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKEVENTLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKEVENTLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackEventLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackLayerData {
    pub _glacier_base: super::timeline::TimelineTrackData,
    pub layer_hash: u32,
}

pub trait SoundEntityTrackLayerDataTrait: super::timeline::TimelineTrackDataTrait {
    fn layer_hash(&self) -> &u32;
    fn layer_hash_mut(&mut self) -> &mut u32;
}

impl SoundEntityTrackLayerDataTrait for SoundEntityTrackLayerData {
    fn layer_hash(&self) -> &u32 {
        &self.layer_hash
    }
    fn layer_hash_mut(&mut self) -> &mut u32 {
        &mut self.layer_hash
    }
}

impl super::timeline::TimelineTrackDataTrait for SoundEntityTrackLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoundEntityTrackLayerData {
}

impl super::core::DataBusPeerTrait for SoundEntityTrackLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityTrackLayerData {
}

impl super::core::DataContainerTrait for SoundEntityTrackLayerData {
}

pub static SOUNDENTITYTRACKLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINETRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayerHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundEntityTrackLayerData, layer_hash),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackTransformLayerData {
    pub _glacier_base: super::timeline::LayeredTransformTrackData,
    pub layer_hash: u32,
}

pub trait SoundEntityTrackTransformLayerDataTrait: super::timeline::LayeredTransformTrackDataTrait {
    fn layer_hash(&self) -> &u32;
    fn layer_hash_mut(&mut self) -> &mut u32;
}

impl SoundEntityTrackTransformLayerDataTrait for SoundEntityTrackTransformLayerData {
    fn layer_hash(&self) -> &u32 {
        &self.layer_hash
    }
    fn layer_hash_mut(&mut self) -> &mut u32 {
        &mut self.layer_hash
    }
}

impl super::timeline::LayeredTransformTrackDataTrait for SoundEntityTrackTransformLayerData {
    fn layer_tracks(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TransformLayerDataTrait>>>> {
        self._glacier_base.layer_tracks()
    }
    fn layer_tracks_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TransformLayerDataTrait>>>> {
        self._glacier_base.layer_tracks_mut()
    }
    fn use_timeline_space(&self) -> &bool {
        self._glacier_base.use_timeline_space()
    }
    fn use_timeline_space_mut(&mut self) -> &mut bool {
        self._glacier_base.use_timeline_space_mut()
    }
    fn transform_space_enabled(&self) -> &bool {
        self._glacier_base.transform_space_enabled()
    }
    fn transform_space_enabled_mut(&mut self) -> &mut bool {
        self._glacier_base.transform_space_enabled_mut()
    }
}

impl super::timeline::PropertyTrackBaseDataTrait for SoundEntityTrackTransformLayerData {
}

impl super::timeline::SchematicPinTrackDataTrait for SoundEntityTrackTransformLayerData {
    fn source_pin_id(&self) -> &i32 {
        self._glacier_base.source_pin_id()
    }
    fn source_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.source_pin_id_mut()
    }
    fn target_pin_id(&self) -> &i32 {
        self._glacier_base.target_pin_id()
    }
    fn target_pin_id_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_id_mut()
    }
    fn target_pin_name_hash(&self) -> &i32 {
        self._glacier_base.target_pin_name_hash()
    }
    fn target_pin_name_hash_mut(&mut self) -> &mut i32 {
        self._glacier_base.target_pin_name_hash_mut()
    }
}

impl super::timeline::TimelineTrackDataTrait for SoundEntityTrackTransformLayerData {
    fn expose_pins(&self) -> &bool {
        self._glacier_base.expose_pins()
    }
    fn expose_pins_mut(&mut self) -> &mut bool {
        self._glacier_base.expose_pins_mut()
    }
    fn is_disabled(&self) -> &bool {
        self._glacier_base.is_disabled()
    }
    fn is_disabled_mut(&mut self) -> &mut bool {
        self._glacier_base.is_disabled_mut()
    }
    fn conditions(&self) -> &Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions()
    }
    fn conditions_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn super::timeline::TimelineTrackDataConditionsBaseTrait>>>> {
        self._glacier_base.conditions_mut()
    }
    fn update_pass_flags(&self) -> &u16 {
        self._glacier_base.update_pass_flags()
    }
    fn update_pass_flags_mut(&mut self) -> &mut u16 {
        self._glacier_base.update_pass_flags_mut()
    }
    fn bucket_pre_children_order(&self) -> &u16 {
        self._glacier_base.bucket_pre_children_order()
    }
    fn bucket_pre_children_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_pre_children_order_mut()
    }
    fn bucket_order(&self) -> &u16 {
        self._glacier_base.bucket_order()
    }
    fn bucket_order_mut(&mut self) -> &mut u16 {
        self._glacier_base.bucket_order_mut()
    }
}

impl super::entity::GameObjectDataTrait for SoundEntityTrackTransformLayerData {
}

impl super::core::DataBusPeerTrait for SoundEntityTrackTransformLayerData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for SoundEntityTrackTransformLayerData {
}

impl super::core::DataContainerTrait for SoundEntityTrackTransformLayerData {
}

pub static SOUNDENTITYTRACKTRANSFORMLAYERDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackTransformLayerData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::LAYEREDTRANSFORMTRACKDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackTransformLayerData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LayerHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundEntityTrackTransformLayerData, layer_hash),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKTRANSFORMLAYERDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackTransformLayerData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKTRANSFORMLAYERDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKTRANSFORMLAYERDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackTransformLayerData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackTransformLayerData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackAssetKeyframeData {
    pub _glacier_base: SoundEntityTrackKeyframeData,
    pub asset: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
    pub trigger_default_start_event: bool,
}

pub trait SoundEntityTrackAssetKeyframeDataTrait: SoundEntityTrackKeyframeDataTrait {
    fn asset(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn trigger_default_start_event(&self) -> &bool;
    fn trigger_default_start_event_mut(&mut self) -> &mut bool;
}

impl SoundEntityTrackAssetKeyframeDataTrait for SoundEntityTrackAssetKeyframeData {
    fn asset(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.asset
    }
    fn asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.asset
    }
    fn trigger_default_start_event(&self) -> &bool {
        &self.trigger_default_start_event
    }
    fn trigger_default_start_event_mut(&mut self) -> &mut bool {
        &mut self.trigger_default_start_event
    }
}

impl SoundEntityTrackKeyframeDataTrait for SoundEntityTrackAssetKeyframeData {
    fn time(&self) -> &f32 {
        self._glacier_base.time()
    }
    fn time_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_mut()
    }
}

impl super::timeline::TimelineKeyframeDataTrait for SoundEntityTrackAssetKeyframeData {
}

impl super::core::DataContainerTrait for SoundEntityTrackAssetKeyframeData {
}

pub static SOUNDENTITYTRACKASSETKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetKeyframeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackAssetKeyframeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Asset",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(SoundEntityTrackAssetKeyframeData, asset),
            },
            FieldInfoData {
                name: "TriggerDefaultStartEvent",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundEntityTrackAssetKeyframeData, trigger_default_start_event),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackAssetKeyframeData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKASSETKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKASSETKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackAssetKeyframeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackAssetKeyframeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackEventKeyframeData {
    pub _glacier_base: SoundEntityTrackKeyframeData,
}

pub trait SoundEntityTrackEventKeyframeDataTrait: SoundEntityTrackKeyframeDataTrait {
}

impl SoundEntityTrackEventKeyframeDataTrait for SoundEntityTrackEventKeyframeData {
}

impl SoundEntityTrackKeyframeDataTrait for SoundEntityTrackEventKeyframeData {
    fn time(&self) -> &f32 {
        self._glacier_base.time()
    }
    fn time_mut(&mut self) -> &mut f32 {
        self._glacier_base.time_mut()
    }
}

impl super::timeline::TimelineKeyframeDataTrait for SoundEntityTrackEventKeyframeData {
}

impl super::core::DataContainerTrait for SoundEntityTrackEventKeyframeData {
}

pub static SOUNDENTITYTRACKEVENTKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventKeyframeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackEventKeyframeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackEventKeyframeData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKEVENTKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKEVENTKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackEventKeyframeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackEventKeyframeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundEntityTrackKeyframeData {
    pub _glacier_base: super::timeline::TimelineKeyframeData,
    pub time: f32,
}

pub trait SoundEntityTrackKeyframeDataTrait: super::timeline::TimelineKeyframeDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
}

impl SoundEntityTrackKeyframeDataTrait for SoundEntityTrackKeyframeData {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
}

impl super::timeline::TimelineKeyframeDataTrait for SoundEntityTrackKeyframeData {
}

impl super::core::DataContainerTrait for SoundEntityTrackKeyframeData {
}

pub static SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackKeyframeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::timeline::TIMELINEKEYFRAMEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundEntityTrackKeyframeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundEntityTrackKeyframeData, time),
            },
        ],
    }),
    array_type: Some(SOUNDENTITYTRACKKEYFRAMEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundEntityTrackKeyframeData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDENTITYTRACKKEYFRAMEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDENTITYTRACKKEYFRAMEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundEntityTrackKeyframeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundEntityTrackKeyframeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct NewWaveAssetObserverEntityData {
    pub _glacier_base: super::entity::EntityData,
    pub new_wave_asset: Option<Arc<Mutex<dyn NewWaveAssetTrait>>>,
}

pub trait NewWaveAssetObserverEntityDataTrait: super::entity::EntityDataTrait {
    fn new_wave_asset(&self) -> &Option<Arc<Mutex<dyn NewWaveAssetTrait>>>;
    fn new_wave_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveAssetTrait>>>;
}

impl NewWaveAssetObserverEntityDataTrait for NewWaveAssetObserverEntityData {
    fn new_wave_asset(&self) -> &Option<Arc<Mutex<dyn NewWaveAssetTrait>>> {
        &self.new_wave_asset
    }
    fn new_wave_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveAssetTrait>>> {
        &mut self.new_wave_asset
    }
}

impl super::entity::EntityDataTrait for NewWaveAssetObserverEntityData {
}

impl super::entity::GameObjectDataTrait for NewWaveAssetObserverEntityData {
}

impl super::core::DataBusPeerTrait for NewWaveAssetObserverEntityData {
    fn flags(&self) -> &u32 {
        self._glacier_base.flags()
    }
    fn flags_mut(&mut self) -> &mut u32 {
        self._glacier_base.flags_mut()
    }
}

impl super::core::GameDataContainerTrait for NewWaveAssetObserverEntityData {
}

impl super::core::DataContainerTrait for NewWaveAssetObserverEntityData {
}

pub static NEWWAVEASSETOBSERVERENTITYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAssetObserverEntityData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::entity::ENTITYDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<NewWaveAssetObserverEntityData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "NewWaveAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveAsset",
                rust_offset: offset_of!(NewWaveAssetObserverEntityData, new_wave_asset),
            },
        ],
    }),
    array_type: Some(NEWWAVEASSETOBSERVERENTITYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for NewWaveAssetObserverEntityData {
    fn type_info(&self) -> &'static TypeInfo {
        NEWWAVEASSETOBSERVERENTITYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static NEWWAVEASSETOBSERVERENTITYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "NewWaveAssetObserverEntityData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("NewWaveAssetObserverEntityData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PropertySortScopeStageData {
    pub _glacier_base: SoundScopeStageData,
    pub count: u32,
    pub property: ScopeStageSortProperty,
    pub order: PropertySortScopeStageOrder,
}

pub trait PropertySortScopeStageDataTrait: SoundScopeStageDataTrait {
    fn count(&self) -> &u32;
    fn count_mut(&mut self) -> &mut u32;
    fn property(&self) -> &ScopeStageSortProperty;
    fn property_mut(&mut self) -> &mut ScopeStageSortProperty;
    fn order(&self) -> &PropertySortScopeStageOrder;
    fn order_mut(&mut self) -> &mut PropertySortScopeStageOrder;
}

impl PropertySortScopeStageDataTrait for PropertySortScopeStageData {
    fn count(&self) -> &u32 {
        &self.count
    }
    fn count_mut(&mut self) -> &mut u32 {
        &mut self.count
    }
    fn property(&self) -> &ScopeStageSortProperty {
        &self.property
    }
    fn property_mut(&mut self) -> &mut ScopeStageSortProperty {
        &mut self.property
    }
    fn order(&self) -> &PropertySortScopeStageOrder {
        &self.order
    }
    fn order_mut(&mut self) -> &mut PropertySortScopeStageOrder {
        &mut self.order
    }
}

impl SoundScopeStageDataTrait for PropertySortScopeStageData {
}

impl super::core::DataContainerTrait for PropertySortScopeStageData {
}

pub static PROPERTYSORTSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDSCOPESTAGEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PropertySortScopeStageData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(PropertySortScopeStageData, count),
            },
            FieldInfoData {
                name: "Property",
                flags: MemberInfoFlags::new(0),
                field_type: "ScopeStageSortProperty",
                rust_offset: offset_of!(PropertySortScopeStageData, property),
            },
            FieldInfoData {
                name: "Order",
                flags: MemberInfoFlags::new(0),
                field_type: "PropertySortScopeStageOrder",
                rust_offset: offset_of!(PropertySortScopeStageData, order),
            },
        ],
    }),
    array_type: Some(PROPERTYSORTSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PropertySortScopeStageData {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYSORTSCOPESTAGEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PROPERTYSORTSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PropertySortScopeStageData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PropertySortScopeStageOrder {
    #[default]
    PropertySortScopeStageOrder_Ascending = 0,
    PropertySortScopeStageOrder_Descending = 1,
}

pub static PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageOrder",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PROPERTYSORTSCOPESTAGEORDER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PropertySortScopeStageOrder {
    fn type_info(&self) -> &'static TypeInfo {
        PROPERTYSORTSCOPESTAGEORDER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PROPERTYSORTSCOPESTAGEORDER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PropertySortScopeStageOrder-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PropertySortScopeStageOrder"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ScopeStageSortProperty {
    #[default]
    ScopeStageSortProperty_DistanceToListener = 0,
    ScopeStageSortProperty_Loudness = 1,
    ScopeStageSortProperty_PotentialLoudness = 2,
    ScopeStageSortProperty_Age = 3,
    ScopeStageSortProperty_InterpolatedLoudness = 4,
}

pub static SCOPESTAGESORTPROPERTY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeStageSortProperty",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SCOPESTAGESORTPROPERTY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ScopeStageSortProperty {
    fn type_info(&self) -> &'static TypeInfo {
        SCOPESTAGESORTPROPERTY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SCOPESTAGESORTPROPERTY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ScopeStageSortProperty-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ScopeStageSortProperty"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DuplicateSpawnScopeStageData {
    pub _glacier_base: SoundScopeStageData,
    pub time: f32,
    pub distance: f32,
    pub group_types: bool,
    pub closest_count: u32,
}

pub trait DuplicateSpawnScopeStageDataTrait: SoundScopeStageDataTrait {
    fn time(&self) -> &f32;
    fn time_mut(&mut self) -> &mut f32;
    fn distance(&self) -> &f32;
    fn distance_mut(&mut self) -> &mut f32;
    fn group_types(&self) -> &bool;
    fn group_types_mut(&mut self) -> &mut bool;
    fn closest_count(&self) -> &u32;
    fn closest_count_mut(&mut self) -> &mut u32;
}

impl DuplicateSpawnScopeStageDataTrait for DuplicateSpawnScopeStageData {
    fn time(&self) -> &f32 {
        &self.time
    }
    fn time_mut(&mut self) -> &mut f32 {
        &mut self.time
    }
    fn distance(&self) -> &f32 {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut f32 {
        &mut self.distance
    }
    fn group_types(&self) -> &bool {
        &self.group_types
    }
    fn group_types_mut(&mut self) -> &mut bool {
        &mut self.group_types
    }
    fn closest_count(&self) -> &u32 {
        &self.closest_count
    }
    fn closest_count_mut(&mut self) -> &mut u32 {
        &mut self.closest_count
    }
}

impl SoundScopeStageDataTrait for DuplicateSpawnScopeStageData {
}

impl super::core::DataContainerTrait for DuplicateSpawnScopeStageData {
}

pub static DUPLICATESPAWNSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DuplicateSpawnScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDSCOPESTAGEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DuplicateSpawnScopeStageData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Time",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, time),
            },
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, distance),
            },
            FieldInfoData {
                name: "GroupTypes",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, group_types),
            },
            FieldInfoData {
                name: "ClosestCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(DuplicateSpawnScopeStageData, closest_count),
            },
        ],
    }),
    array_type: Some(DUPLICATESPAWNSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DuplicateSpawnScopeStageData {
    fn type_info(&self) -> &'static TypeInfo {
        DUPLICATESPAWNSCOPESTAGEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DUPLICATESPAWNSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DuplicateSpawnScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DuplicateSpawnScopeStageData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MaxInstancesScopeStageData {
    pub _glacier_base: SoundScopeStageData,
    pub count: u32,
    pub keep_oldest: bool,
}

pub trait MaxInstancesScopeStageDataTrait: SoundScopeStageDataTrait {
    fn count(&self) -> &u32;
    fn count_mut(&mut self) -> &mut u32;
    fn keep_oldest(&self) -> &bool;
    fn keep_oldest_mut(&mut self) -> &mut bool;
}

impl MaxInstancesScopeStageDataTrait for MaxInstancesScopeStageData {
    fn count(&self) -> &u32 {
        &self.count
    }
    fn count_mut(&mut self) -> &mut u32 {
        &mut self.count
    }
    fn keep_oldest(&self) -> &bool {
        &self.keep_oldest
    }
    fn keep_oldest_mut(&mut self) -> &mut bool {
        &mut self.keep_oldest
    }
}

impl SoundScopeStageDataTrait for MaxInstancesScopeStageData {
}

impl super::core::DataContainerTrait for MaxInstancesScopeStageData {
}

pub static MAXINSTANCESSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaxInstancesScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDSCOPESTAGEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MaxInstancesScopeStageData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Count",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(MaxInstancesScopeStageData, count),
            },
            FieldInfoData {
                name: "KeepOldest",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(MaxInstancesScopeStageData, keep_oldest),
            },
        ],
    }),
    array_type: Some(MAXINSTANCESSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MaxInstancesScopeStageData {
    fn type_info(&self) -> &'static TypeInfo {
        MAXINSTANCESSCOPESTAGEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MAXINSTANCESSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MaxInstancesScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MaxInstancesScopeStageData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeSetupData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub mappings: Vec<SoundScopeStrategyMapping>,
}

pub trait SoundScopeSetupDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn mappings(&self) -> &Vec<SoundScopeStrategyMapping>;
    fn mappings_mut(&mut self) -> &mut Vec<SoundScopeStrategyMapping>;
}

impl SoundScopeSetupDataTrait for SoundScopeSetupData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn mappings(&self) -> &Vec<SoundScopeStrategyMapping> {
        &self.mappings
    }
    fn mappings_mut(&mut self) -> &mut Vec<SoundScopeStrategyMapping> {
        &mut self.mappings
    }
}

impl super::core::DataContainerTrait for SoundScopeSetupData {
}

pub static SOUNDSCOPESETUPDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeSetupData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundScopeSetupData, name),
            },
            FieldInfoData {
                name: "Mappings",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeStrategyMapping-Array",
                rust_offset: offset_of!(SoundScopeSetupData, mappings),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeSetupData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPESETUPDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPESETUPDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeSetupData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeSetupData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeStrategyMapping {
    pub scope: Option<Arc<Mutex<dyn SoundScopeDataTrait>>>,
    pub strategy: Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>,
}

pub trait SoundScopeStrategyMappingTrait: TypeObject {
    fn scope(&self) -> &Option<Arc<Mutex<dyn SoundScopeDataTrait>>>;
    fn scope_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeDataTrait>>>;
    fn strategy(&self) -> &Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>;
    fn strategy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>;
}

impl SoundScopeStrategyMappingTrait for SoundScopeStrategyMapping {
    fn scope(&self) -> &Option<Arc<Mutex<dyn SoundScopeDataTrait>>> {
        &self.scope
    }
    fn scope_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeDataTrait>>> {
        &mut self.scope
    }
    fn strategy(&self) -> &Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>> {
        &self.strategy
    }
    fn strategy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>> {
        &mut self.strategy
    }
}

pub static SOUNDSCOPESTRATEGYMAPPING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyMapping",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeStrategyMapping as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Scope",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeData",
                rust_offset: offset_of!(SoundScopeStrategyMapping, scope),
            },
            FieldInfoData {
                name: "Strategy",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeStrategyData",
                rust_offset: offset_of!(SoundScopeStrategyMapping, strategy),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeStrategyMapping {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPESTRATEGYMAPPING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDSCOPESTRATEGYMAPPING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyMapping-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeStrategyMapping"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeStrategyData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub stages: Vec<Option<Arc<Mutex<dyn SoundScopeStageDataTrait>>>>,
}

pub trait SoundScopeStrategyDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn stages(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeStageDataTrait>>>>;
    fn stages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeStageDataTrait>>>>;
}

impl SoundScopeStrategyDataTrait for SoundScopeStrategyData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn stages(&self) -> &Vec<Option<Arc<Mutex<dyn SoundScopeStageDataTrait>>>> {
        &self.stages
    }
    fn stages_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundScopeStageDataTrait>>>> {
        &mut self.stages
    }
}

impl super::core::DataContainerTrait for SoundScopeStrategyData {
}

pub static SOUNDSCOPESTRATEGYDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeStrategyData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundScopeStrategyData, name),
            },
            FieldInfoData {
                name: "Stages",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeStageData-Array",
                rust_offset: offset_of!(SoundScopeStrategyData, stages),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeStrategyData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPESTRATEGYDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPESTRATEGYDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStrategyData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeStrategyData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeStageData {
    pub _glacier_base: super::core::DataContainer,
}

pub trait SoundScopeStageDataTrait: super::core::DataContainerTrait {
}

impl SoundScopeStageDataTrait for SoundScopeStageData {
}

impl super::core::DataContainerTrait for SoundScopeStageData {
}

pub static SOUNDSCOPESTAGEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStageData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeStageData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeStageData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPESTAGEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPESTAGEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeStageData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeStageData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeAggregateData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub strategy: Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>,
    pub max_input_count: u32,
    pub inputs: Vec<SoundScopeAggregateInputData>,
}

pub trait SoundScopeAggregateDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn strategy(&self) -> &Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>;
    fn strategy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>;
    fn max_input_count(&self) -> &u32;
    fn max_input_count_mut(&mut self) -> &mut u32;
    fn inputs(&self) -> &Vec<SoundScopeAggregateInputData>;
    fn inputs_mut(&mut self) -> &mut Vec<SoundScopeAggregateInputData>;
}

impl SoundScopeAggregateDataTrait for SoundScopeAggregateData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn strategy(&self) -> &Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>> {
        &self.strategy
    }
    fn strategy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>> {
        &mut self.strategy
    }
    fn max_input_count(&self) -> &u32 {
        &self.max_input_count
    }
    fn max_input_count_mut(&mut self) -> &mut u32 {
        &mut self.max_input_count
    }
    fn inputs(&self) -> &Vec<SoundScopeAggregateInputData> {
        &self.inputs
    }
    fn inputs_mut(&mut self) -> &mut Vec<SoundScopeAggregateInputData> {
        &mut self.inputs
    }
}

impl super::core::DataContainerTrait for SoundScopeAggregateData {
}

pub static SOUNDSCOPEAGGREGATEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeAggregateData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundScopeAggregateData, name),
            },
            FieldInfoData {
                name: "Strategy",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeStrategyData",
                rust_offset: offset_of!(SoundScopeAggregateData, strategy),
            },
            FieldInfoData {
                name: "MaxInputCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundScopeAggregateData, max_input_count),
            },
            FieldInfoData {
                name: "Inputs",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundScopeAggregateInputData-Array",
                rust_offset: offset_of!(SoundScopeAggregateData, inputs),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeAggregateData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPEAGGREGATEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPEAGGREGATEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeAggregateData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeAggregateInputData {
    pub source: Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>,
    pub weight: f32,
}

pub trait SoundScopeAggregateInputDataTrait: TypeObject {
    fn source(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DataContainerTrait>>>;
    fn weight(&self) -> &f32;
    fn weight_mut(&mut self) -> &mut f32;
}

impl SoundScopeAggregateInputDataTrait for SoundScopeAggregateInputData {
    fn source(&self) -> &Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &self.source
    }
    fn source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::DataContainerTrait>>> {
        &mut self.source
    }
    fn weight(&self) -> &f32 {
        &self.weight
    }
    fn weight_mut(&mut self) -> &mut f32 {
        &mut self.weight
    }
}

pub static SOUNDSCOPEAGGREGATEINPUTDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateInputData",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeAggregateInputData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Source",
                flags: MemberInfoFlags::new(0),
                field_type: "DataContainer",
                rust_offset: offset_of!(SoundScopeAggregateInputData, source),
            },
            FieldInfoData {
                name: "Weight",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundScopeAggregateInputData, weight),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeAggregateInputData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPEAGGREGATEINPUTDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDSCOPEAGGREGATEINPUTDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeAggregateInputData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeAggregateInputData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundScopeData {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub default_strategy: Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>,
}

pub trait SoundScopeDataTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn default_strategy(&self) -> &Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>;
    fn default_strategy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>>;
}

impl SoundScopeDataTrait for SoundScopeData {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn default_strategy(&self) -> &Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>> {
        &self.default_strategy
    }
    fn default_strategy_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundScopeStrategyDataTrait>>> {
        &mut self.default_strategy
    }
}

impl super::core::DataContainerTrait for SoundScopeData {
}

pub static SOUNDSCOPEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundScopeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundScopeData, name),
            },
            FieldInfoData {
                name: "DefaultStrategy",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundScopeStrategyData",
                rust_offset: offset_of!(SoundScopeData, default_strategy),
            },
        ],
    }),
    array_type: Some(SOUNDSCOPEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundScopeData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDSCOPEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDSCOPEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundScopeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundScopeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EqualizerSettings {
    pub _glacier_base: super::core::DataContainer,
    pub low_shelf_frequency: f32,
    pub low_shelf_gain: f32,
    pub high_shelf_frequency: f32,
    pub high_shelf_gain: f32,
    pub hp_cutoff_frequency: f32,
}

pub trait EqualizerSettingsTrait: super::core::DataContainerTrait {
    fn low_shelf_frequency(&self) -> &f32;
    fn low_shelf_frequency_mut(&mut self) -> &mut f32;
    fn low_shelf_gain(&self) -> &f32;
    fn low_shelf_gain_mut(&mut self) -> &mut f32;
    fn high_shelf_frequency(&self) -> &f32;
    fn high_shelf_frequency_mut(&mut self) -> &mut f32;
    fn high_shelf_gain(&self) -> &f32;
    fn high_shelf_gain_mut(&mut self) -> &mut f32;
    fn hp_cutoff_frequency(&self) -> &f32;
    fn hp_cutoff_frequency_mut(&mut self) -> &mut f32;
}

impl EqualizerSettingsTrait for EqualizerSettings {
    fn low_shelf_frequency(&self) -> &f32 {
        &self.low_shelf_frequency
    }
    fn low_shelf_frequency_mut(&mut self) -> &mut f32 {
        &mut self.low_shelf_frequency
    }
    fn low_shelf_gain(&self) -> &f32 {
        &self.low_shelf_gain
    }
    fn low_shelf_gain_mut(&mut self) -> &mut f32 {
        &mut self.low_shelf_gain
    }
    fn high_shelf_frequency(&self) -> &f32 {
        &self.high_shelf_frequency
    }
    fn high_shelf_frequency_mut(&mut self) -> &mut f32 {
        &mut self.high_shelf_frequency
    }
    fn high_shelf_gain(&self) -> &f32 {
        &self.high_shelf_gain
    }
    fn high_shelf_gain_mut(&mut self) -> &mut f32 {
        &mut self.high_shelf_gain
    }
    fn hp_cutoff_frequency(&self) -> &f32 {
        &self.hp_cutoff_frequency
    }
    fn hp_cutoff_frequency_mut(&mut self) -> &mut f32 {
        &mut self.hp_cutoff_frequency
    }
}

impl super::core::DataContainerTrait for EqualizerSettings {
}

pub static EQUALIZERSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EqualizerSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EqualizerSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "LowShelfFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EqualizerSettings, low_shelf_frequency),
            },
            FieldInfoData {
                name: "LowShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EqualizerSettings, low_shelf_gain),
            },
            FieldInfoData {
                name: "HighShelfFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EqualizerSettings, high_shelf_frequency),
            },
            FieldInfoData {
                name: "HighShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EqualizerSettings, high_shelf_gain),
            },
            FieldInfoData {
                name: "HpCutoffFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(EqualizerSettings, hp_cutoff_frequency),
            },
        ],
    }),
    array_type: Some(EQUALIZERSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EqualizerSettings {
    fn type_info(&self) -> &'static TypeInfo {
        EQUALIZERSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EQUALIZERSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EqualizerSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EqualizerSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompressorSettings {
    pub _glacier_base: super::core::DataContainer,
    pub ratio: f32,
    pub threshold: f32,
    pub attack: f32,
    pub release: f32,
}

pub trait CompressorSettingsTrait: super::core::DataContainerTrait {
    fn ratio(&self) -> &f32;
    fn ratio_mut(&mut self) -> &mut f32;
    fn threshold(&self) -> &f32;
    fn threshold_mut(&mut self) -> &mut f32;
    fn attack(&self) -> &f32;
    fn attack_mut(&mut self) -> &mut f32;
    fn release(&self) -> &f32;
    fn release_mut(&mut self) -> &mut f32;
}

impl CompressorSettingsTrait for CompressorSettings {
    fn ratio(&self) -> &f32 {
        &self.ratio
    }
    fn ratio_mut(&mut self) -> &mut f32 {
        &mut self.ratio
    }
    fn threshold(&self) -> &f32 {
        &self.threshold
    }
    fn threshold_mut(&mut self) -> &mut f32 {
        &mut self.threshold
    }
    fn attack(&self) -> &f32 {
        &self.attack
    }
    fn attack_mut(&mut self) -> &mut f32 {
        &mut self.attack
    }
    fn release(&self) -> &f32 {
        &self.release
    }
    fn release_mut(&mut self) -> &mut f32 {
        &mut self.release
    }
}

impl super::core::DataContainerTrait for CompressorSettings {
}

pub static COMPRESSORSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompressorSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Ratio",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompressorSettings, ratio),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompressorSettings, threshold),
            },
            FieldInfoData {
                name: "Attack",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompressorSettings, attack),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(CompressorSettings, release),
            },
        ],
    }),
    array_type: Some(COMPRESSORSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompressorSettings {
    fn type_info(&self) -> &'static TypeInfo {
        COMPRESSORSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPRESSORSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CompressorSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MasterUnitSettings {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub equalizer: Option<Arc<Mutex<dyn EqualizerSettingsTrait>>>,
    pub compressor: Option<Arc<Mutex<dyn CompressorSettingsTrait>>>,
    pub master_volume: f32,
    pub master_lfe_gain: f32,
    pub master_dialog_gain: f32,
    pub reverb_volume: f32,
    pub main_mix_volume: f32,
    pub distortion_clip_level: f32,
    pub parallel_distortion_gain: f32,
    pub post_effects_gain: f32,
    pub fade_time: f32,
}

pub trait MasterUnitSettingsTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn equalizer(&self) -> &Option<Arc<Mutex<dyn EqualizerSettingsTrait>>>;
    fn equalizer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EqualizerSettingsTrait>>>;
    fn compressor(&self) -> &Option<Arc<Mutex<dyn CompressorSettingsTrait>>>;
    fn compressor_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CompressorSettingsTrait>>>;
    fn master_volume(&self) -> &f32;
    fn master_volume_mut(&mut self) -> &mut f32;
    fn master_lfe_gain(&self) -> &f32;
    fn master_lfe_gain_mut(&mut self) -> &mut f32;
    fn master_dialog_gain(&self) -> &f32;
    fn master_dialog_gain_mut(&mut self) -> &mut f32;
    fn reverb_volume(&self) -> &f32;
    fn reverb_volume_mut(&mut self) -> &mut f32;
    fn main_mix_volume(&self) -> &f32;
    fn main_mix_volume_mut(&mut self) -> &mut f32;
    fn distortion_clip_level(&self) -> &f32;
    fn distortion_clip_level_mut(&mut self) -> &mut f32;
    fn parallel_distortion_gain(&self) -> &f32;
    fn parallel_distortion_gain_mut(&mut self) -> &mut f32;
    fn post_effects_gain(&self) -> &f32;
    fn post_effects_gain_mut(&mut self) -> &mut f32;
    fn fade_time(&self) -> &f32;
    fn fade_time_mut(&mut self) -> &mut f32;
}

impl MasterUnitSettingsTrait for MasterUnitSettings {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn equalizer(&self) -> &Option<Arc<Mutex<dyn EqualizerSettingsTrait>>> {
        &self.equalizer
    }
    fn equalizer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn EqualizerSettingsTrait>>> {
        &mut self.equalizer
    }
    fn compressor(&self) -> &Option<Arc<Mutex<dyn CompressorSettingsTrait>>> {
        &self.compressor
    }
    fn compressor_mut(&mut self) -> &mut Option<Arc<Mutex<dyn CompressorSettingsTrait>>> {
        &mut self.compressor
    }
    fn master_volume(&self) -> &f32 {
        &self.master_volume
    }
    fn master_volume_mut(&mut self) -> &mut f32 {
        &mut self.master_volume
    }
    fn master_lfe_gain(&self) -> &f32 {
        &self.master_lfe_gain
    }
    fn master_lfe_gain_mut(&mut self) -> &mut f32 {
        &mut self.master_lfe_gain
    }
    fn master_dialog_gain(&self) -> &f32 {
        &self.master_dialog_gain
    }
    fn master_dialog_gain_mut(&mut self) -> &mut f32 {
        &mut self.master_dialog_gain
    }
    fn reverb_volume(&self) -> &f32 {
        &self.reverb_volume
    }
    fn reverb_volume_mut(&mut self) -> &mut f32 {
        &mut self.reverb_volume
    }
    fn main_mix_volume(&self) -> &f32 {
        &self.main_mix_volume
    }
    fn main_mix_volume_mut(&mut self) -> &mut f32 {
        &mut self.main_mix_volume
    }
    fn distortion_clip_level(&self) -> &f32 {
        &self.distortion_clip_level
    }
    fn distortion_clip_level_mut(&mut self) -> &mut f32 {
        &mut self.distortion_clip_level
    }
    fn parallel_distortion_gain(&self) -> &f32 {
        &self.parallel_distortion_gain
    }
    fn parallel_distortion_gain_mut(&mut self) -> &mut f32 {
        &mut self.parallel_distortion_gain
    }
    fn post_effects_gain(&self) -> &f32 {
        &self.post_effects_gain
    }
    fn post_effects_gain_mut(&mut self) -> &mut f32 {
        &mut self.post_effects_gain
    }
    fn fade_time(&self) -> &f32 {
        &self.fade_time
    }
    fn fade_time_mut(&mut self) -> &mut f32 {
        &mut self.fade_time
    }
}

impl super::core::DataContainerTrait for MasterUnitSettings {
}

pub static MASTERUNITSETTINGS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitSettings",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MasterUnitSettings as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(MasterUnitSettings, name),
            },
            FieldInfoData {
                name: "Equalizer",
                flags: MemberInfoFlags::new(0),
                field_type: "EqualizerSettings",
                rust_offset: offset_of!(MasterUnitSettings, equalizer),
            },
            FieldInfoData {
                name: "Compressor",
                flags: MemberInfoFlags::new(0),
                field_type: "CompressorSettings",
                rust_offset: offset_of!(MasterUnitSettings, compressor),
            },
            FieldInfoData {
                name: "MasterVolume",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, master_volume),
            },
            FieldInfoData {
                name: "MasterLfeGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, master_lfe_gain),
            },
            FieldInfoData {
                name: "MasterDialogGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, master_dialog_gain),
            },
            FieldInfoData {
                name: "ReverbVolume",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, reverb_volume),
            },
            FieldInfoData {
                name: "MainMixVolume",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, main_mix_volume),
            },
            FieldInfoData {
                name: "DistortionClipLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, distortion_clip_level),
            },
            FieldInfoData {
                name: "ParallelDistortionGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, parallel_distortion_gain),
            },
            FieldInfoData {
                name: "PostEffectsGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, post_effects_gain),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(MasterUnitSettings, fade_time),
            },
        ],
    }),
    array_type: Some(MASTERUNITSETTINGS_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MasterUnitSettings {
    fn type_info(&self) -> &'static TypeInfo {
        MASTERUNITSETTINGS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MASTERUNITSETTINGS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitSettings-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MasterUnitSettings"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HdrSetting {
    pub _glacier_base: super::core::DataContainer,
    pub window_min_top: f32,
    pub window_min_bottom: f32,
    pub window_top_min_release_time: f32,
    pub window_top_max_release_time: f32,
    pub window_top_attack_time: f32,
    pub window_bottom_release_time: f32,
    pub window_top_release_time_curve: super::core::AudioCurve,
    pub discharge_factor: f32,
    pub max_allowed_energy: f32,
    pub window_bottom_attack_time: f32,
    pub window_size: f32,
    pub compress_factor: f32,
    pub headroom: f32,
    pub allowed_overshoot: f32,
}

pub trait HdrSettingTrait: super::core::DataContainerTrait {
    fn window_min_top(&self) -> &f32;
    fn window_min_top_mut(&mut self) -> &mut f32;
    fn window_min_bottom(&self) -> &f32;
    fn window_min_bottom_mut(&mut self) -> &mut f32;
    fn window_top_min_release_time(&self) -> &f32;
    fn window_top_min_release_time_mut(&mut self) -> &mut f32;
    fn window_top_max_release_time(&self) -> &f32;
    fn window_top_max_release_time_mut(&mut self) -> &mut f32;
    fn window_top_attack_time(&self) -> &f32;
    fn window_top_attack_time_mut(&mut self) -> &mut f32;
    fn window_bottom_release_time(&self) -> &f32;
    fn window_bottom_release_time_mut(&mut self) -> &mut f32;
    fn window_top_release_time_curve(&self) -> &super::core::AudioCurve;
    fn window_top_release_time_curve_mut(&mut self) -> &mut super::core::AudioCurve;
    fn discharge_factor(&self) -> &f32;
    fn discharge_factor_mut(&mut self) -> &mut f32;
    fn max_allowed_energy(&self) -> &f32;
    fn max_allowed_energy_mut(&mut self) -> &mut f32;
    fn window_bottom_attack_time(&self) -> &f32;
    fn window_bottom_attack_time_mut(&mut self) -> &mut f32;
    fn window_size(&self) -> &f32;
    fn window_size_mut(&mut self) -> &mut f32;
    fn compress_factor(&self) -> &f32;
    fn compress_factor_mut(&mut self) -> &mut f32;
    fn headroom(&self) -> &f32;
    fn headroom_mut(&mut self) -> &mut f32;
    fn allowed_overshoot(&self) -> &f32;
    fn allowed_overshoot_mut(&mut self) -> &mut f32;
}

impl HdrSettingTrait for HdrSetting {
    fn window_min_top(&self) -> &f32 {
        &self.window_min_top
    }
    fn window_min_top_mut(&mut self) -> &mut f32 {
        &mut self.window_min_top
    }
    fn window_min_bottom(&self) -> &f32 {
        &self.window_min_bottom
    }
    fn window_min_bottom_mut(&mut self) -> &mut f32 {
        &mut self.window_min_bottom
    }
    fn window_top_min_release_time(&self) -> &f32 {
        &self.window_top_min_release_time
    }
    fn window_top_min_release_time_mut(&mut self) -> &mut f32 {
        &mut self.window_top_min_release_time
    }
    fn window_top_max_release_time(&self) -> &f32 {
        &self.window_top_max_release_time
    }
    fn window_top_max_release_time_mut(&mut self) -> &mut f32 {
        &mut self.window_top_max_release_time
    }
    fn window_top_attack_time(&self) -> &f32 {
        &self.window_top_attack_time
    }
    fn window_top_attack_time_mut(&mut self) -> &mut f32 {
        &mut self.window_top_attack_time
    }
    fn window_bottom_release_time(&self) -> &f32 {
        &self.window_bottom_release_time
    }
    fn window_bottom_release_time_mut(&mut self) -> &mut f32 {
        &mut self.window_bottom_release_time
    }
    fn window_top_release_time_curve(&self) -> &super::core::AudioCurve {
        &self.window_top_release_time_curve
    }
    fn window_top_release_time_curve_mut(&mut self) -> &mut super::core::AudioCurve {
        &mut self.window_top_release_time_curve
    }
    fn discharge_factor(&self) -> &f32 {
        &self.discharge_factor
    }
    fn discharge_factor_mut(&mut self) -> &mut f32 {
        &mut self.discharge_factor
    }
    fn max_allowed_energy(&self) -> &f32 {
        &self.max_allowed_energy
    }
    fn max_allowed_energy_mut(&mut self) -> &mut f32 {
        &mut self.max_allowed_energy
    }
    fn window_bottom_attack_time(&self) -> &f32 {
        &self.window_bottom_attack_time
    }
    fn window_bottom_attack_time_mut(&mut self) -> &mut f32 {
        &mut self.window_bottom_attack_time
    }
    fn window_size(&self) -> &f32 {
        &self.window_size
    }
    fn window_size_mut(&mut self) -> &mut f32 {
        &mut self.window_size
    }
    fn compress_factor(&self) -> &f32 {
        &self.compress_factor
    }
    fn compress_factor_mut(&mut self) -> &mut f32 {
        &mut self.compress_factor
    }
    fn headroom(&self) -> &f32 {
        &self.headroom
    }
    fn headroom_mut(&mut self) -> &mut f32 {
        &mut self.headroom
    }
    fn allowed_overshoot(&self) -> &f32 {
        &self.allowed_overshoot
    }
    fn allowed_overshoot_mut(&mut self) -> &mut f32 {
        &mut self.allowed_overshoot
    }
}

impl super::core::DataContainerTrait for HdrSetting {
}

pub static HDRSETTING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HdrSetting",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HdrSetting as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WindowMinTop",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_min_top),
            },
            FieldInfoData {
                name: "WindowMinBottom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_min_bottom),
            },
            FieldInfoData {
                name: "WindowTopMinReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_top_min_release_time),
            },
            FieldInfoData {
                name: "WindowTopMaxReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_top_max_release_time),
            },
            FieldInfoData {
                name: "WindowTopAttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_top_attack_time),
            },
            FieldInfoData {
                name: "WindowBottomReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_bottom_release_time),
            },
            FieldInfoData {
                name: "WindowTopReleaseTimeCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioCurve",
                rust_offset: offset_of!(HdrSetting, window_top_release_time_curve),
            },
            FieldInfoData {
                name: "DischargeFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, discharge_factor),
            },
            FieldInfoData {
                name: "MaxAllowedEnergy",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, max_allowed_energy),
            },
            FieldInfoData {
                name: "WindowBottomAttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_bottom_attack_time),
            },
            FieldInfoData {
                name: "WindowSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, window_size),
            },
            FieldInfoData {
                name: "CompressFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, compress_factor),
            },
            FieldInfoData {
                name: "Headroom",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, headroom),
            },
            FieldInfoData {
                name: "AllowedOvershoot",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(HdrSetting, allowed_overshoot),
            },
        ],
    }),
    array_type: Some(HDRSETTING_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HdrSetting {
    fn type_info(&self) -> &'static TypeInfo {
        HDRSETTING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HDRSETTING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HdrSetting-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HdrSetting"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphData {
    pub _glacier_base: AudioGraphData,
    pub info: SoundGraphInfo,
    pub input_parameters: Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>,
    pub output_parameters: Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>,
    pub input_events: Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>,
    pub output_events: Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>,
}

pub trait SoundGraphDataTrait: AudioGraphDataTrait {
    fn info(&self) -> &SoundGraphInfo;
    fn info_mut(&mut self) -> &mut SoundGraphInfo;
    fn input_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn input_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn output_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn output_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>>;
    fn input_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>;
    fn input_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>;
    fn output_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>;
    fn output_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>>;
}

impl SoundGraphDataTrait for SoundGraphData {
    fn info(&self) -> &SoundGraphInfo {
        &self.info
    }
    fn info_mut(&mut self) -> &mut SoundGraphInfo {
        &mut self.info
    }
    fn input_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &self.input_parameters
    }
    fn input_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &mut self.input_parameters
    }
    fn output_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &self.output_parameters
    }
    fn output_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        &mut self.output_parameters
    }
    fn input_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        &self.input_events
    }
    fn input_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        &mut self.input_events
    }
    fn output_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        &self.output_events
    }
    fn output_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        &mut self.output_events
    }
}

impl AudioGraphDataTrait for SoundGraphData {
    fn nodes(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        self._glacier_base.nodes()
    }
    fn nodes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>> {
        self._glacier_base.nodes_mut()
    }
    fn public_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        self._glacier_base.public_parameters()
    }
    fn public_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphParameterTrait>>>> {
        self._glacier_base.public_parameters_mut()
    }
    fn public_events(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        self._glacier_base.public_events()
    }
    fn public_events_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphEventTrait>>>> {
        self._glacier_base.public_events_mut()
    }
    fn public_asset_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>> {
        self._glacier_base.public_asset_parameters()
    }
    fn public_asset_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn AudioGraphAssetParameterTrait>>>> {
        self._glacier_base.public_asset_parameters_mut()
    }
    fn public_value_count(&self) -> &u16 {
        self._glacier_base.public_value_count()
    }
    fn public_value_count_mut(&mut self) -> &mut u16 {
        self._glacier_base.public_value_count_mut()
    }
    fn value_count(&self) -> &u16 {
        self._glacier_base.value_count()
    }
    fn value_count_mut(&mut self) -> &mut u16 {
        self._glacier_base.value_count_mut()
    }
}

impl super::core::DataContainerTrait for SoundGraphData {
}

pub static SOUNDGRAPHDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Info",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphInfo",
                rust_offset: offset_of!(SoundGraphData, info),
            },
            FieldInfoData {
                name: "InputParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphParameter-Array",
                rust_offset: offset_of!(SoundGraphData, input_parameters),
            },
            FieldInfoData {
                name: "OutputParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphParameter-Array",
                rust_offset: offset_of!(SoundGraphData, output_parameters),
            },
            FieldInfoData {
                name: "InputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphEvent-Array",
                rust_offset: offset_of!(SoundGraphData, input_events),
            },
            FieldInfoData {
                name: "OutputEvents",
                flags: MemberInfoFlags::new(144),
                field_type: "AudioGraphEvent-Array",
                rust_offset: offset_of!(SoundGraphData, output_events),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDGRAPHDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundBusData {
    pub _glacier_base: AudioGraphNodeData,
    pub channel_count: u8,
    pub bus_name: String,
    pub submix_plugin: SoundGraphPluginRef,
}

pub trait SoundBusDataTrait: AudioGraphNodeDataTrait {
    fn channel_count(&self) -> &u8;
    fn channel_count_mut(&mut self) -> &mut u8;
    fn bus_name(&self) -> &String;
    fn bus_name_mut(&mut self) -> &mut String;
    fn submix_plugin(&self) -> &SoundGraphPluginRef;
    fn submix_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl SoundBusDataTrait for SoundBusData {
    fn channel_count(&self) -> &u8 {
        &self.channel_count
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        &mut self.channel_count
    }
    fn bus_name(&self) -> &String {
        &self.bus_name
    }
    fn bus_name_mut(&mut self) -> &mut String {
        &mut self.bus_name
    }
    fn submix_plugin(&self) -> &SoundGraphPluginRef {
        &self.submix_plugin
    }
    fn submix_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.submix_plugin
    }
}

impl AudioGraphNodeDataTrait for SoundBusData {
}

impl super::core::DataContainerTrait for SoundBusData {
}

pub static SOUNDBUSDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundBusData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundBusData, channel_count),
            },
            FieldInfoData {
                name: "BusName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(SoundBusData, bus_name),
            },
            FieldInfoData {
                name: "SubmixPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(SoundBusData, submix_plugin),
            },
        ],
    }),
    array_type: Some(SOUNDBUSDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundBusData {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDBUSDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SOUNDBUSDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundBusData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundBusData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphInfo {
    pub voices: Vec<SoundGraphVoiceInfo>,
    pub linked_plugin_attributes: Vec<SoundGraphLinkedPluginAttribute>,
    pub connections: Vec<SoundGraphPluginConnection>,
    pub connection_params: Vec<SoundGraphPluginConnectionParam>,
    pub construct_params: Vec<SoundGraphPluginConstructParam>,
    pub plugins_param_count: u32,
    pub plugin_count: u32,
    pub dynamic_send_count: u32,
}

pub trait SoundGraphInfoTrait: TypeObject {
    fn voices(&self) -> &Vec<SoundGraphVoiceInfo>;
    fn voices_mut(&mut self) -> &mut Vec<SoundGraphVoiceInfo>;
    fn linked_plugin_attributes(&self) -> &Vec<SoundGraphLinkedPluginAttribute>;
    fn linked_plugin_attributes_mut(&mut self) -> &mut Vec<SoundGraphLinkedPluginAttribute>;
    fn connections(&self) -> &Vec<SoundGraphPluginConnection>;
    fn connections_mut(&mut self) -> &mut Vec<SoundGraphPluginConnection>;
    fn connection_params(&self) -> &Vec<SoundGraphPluginConnectionParam>;
    fn connection_params_mut(&mut self) -> &mut Vec<SoundGraphPluginConnectionParam>;
    fn construct_params(&self) -> &Vec<SoundGraphPluginConstructParam>;
    fn construct_params_mut(&mut self) -> &mut Vec<SoundGraphPluginConstructParam>;
    fn plugins_param_count(&self) -> &u32;
    fn plugins_param_count_mut(&mut self) -> &mut u32;
    fn plugin_count(&self) -> &u32;
    fn plugin_count_mut(&mut self) -> &mut u32;
    fn dynamic_send_count(&self) -> &u32;
    fn dynamic_send_count_mut(&mut self) -> &mut u32;
}

impl SoundGraphInfoTrait for SoundGraphInfo {
    fn voices(&self) -> &Vec<SoundGraphVoiceInfo> {
        &self.voices
    }
    fn voices_mut(&mut self) -> &mut Vec<SoundGraphVoiceInfo> {
        &mut self.voices
    }
    fn linked_plugin_attributes(&self) -> &Vec<SoundGraphLinkedPluginAttribute> {
        &self.linked_plugin_attributes
    }
    fn linked_plugin_attributes_mut(&mut self) -> &mut Vec<SoundGraphLinkedPluginAttribute> {
        &mut self.linked_plugin_attributes
    }
    fn connections(&self) -> &Vec<SoundGraphPluginConnection> {
        &self.connections
    }
    fn connections_mut(&mut self) -> &mut Vec<SoundGraphPluginConnection> {
        &mut self.connections
    }
    fn connection_params(&self) -> &Vec<SoundGraphPluginConnectionParam> {
        &self.connection_params
    }
    fn connection_params_mut(&mut self) -> &mut Vec<SoundGraphPluginConnectionParam> {
        &mut self.connection_params
    }
    fn construct_params(&self) -> &Vec<SoundGraphPluginConstructParam> {
        &self.construct_params
    }
    fn construct_params_mut(&mut self) -> &mut Vec<SoundGraphPluginConstructParam> {
        &mut self.construct_params
    }
    fn plugins_param_count(&self) -> &u32 {
        &self.plugins_param_count
    }
    fn plugins_param_count_mut(&mut self) -> &mut u32 {
        &mut self.plugins_param_count
    }
    fn plugin_count(&self) -> &u32 {
        &self.plugin_count
    }
    fn plugin_count_mut(&mut self) -> &mut u32 {
        &mut self.plugin_count
    }
    fn dynamic_send_count(&self) -> &u32 {
        &self.dynamic_send_count
    }
    fn dynamic_send_count_mut(&mut self) -> &mut u32 {
        &mut self.dynamic_send_count
    }
}

pub static SOUNDGRAPHINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Voices",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphVoiceInfo-Array",
                rust_offset: offset_of!(SoundGraphInfo, voices),
            },
            FieldInfoData {
                name: "LinkedPluginAttributes",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphLinkedPluginAttribute-Array",
                rust_offset: offset_of!(SoundGraphInfo, linked_plugin_attributes),
            },
            FieldInfoData {
                name: "Connections",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphPluginConnection-Array",
                rust_offset: offset_of!(SoundGraphInfo, connections),
            },
            FieldInfoData {
                name: "ConnectionParams",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphPluginConnectionParam-Array",
                rust_offset: offset_of!(SoundGraphInfo, connection_params),
            },
            FieldInfoData {
                name: "ConstructParams",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphPluginConstructParam-Array",
                rust_offset: offset_of!(SoundGraphInfo, construct_params),
            },
            FieldInfoData {
                name: "PluginsParamCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundGraphInfo, plugins_param_count),
            },
            FieldInfoData {
                name: "PluginCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundGraphInfo, plugin_count),
            },
            FieldInfoData {
                name: "DynamicSendCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundGraphInfo, dynamic_send_count),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphInfo {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphVoiceInfo {
    pub plugins: Vec<SoundGraphPluginInfo>,
}

pub trait SoundGraphVoiceInfoTrait: TypeObject {
    fn plugins(&self) -> &Vec<SoundGraphPluginInfo>;
    fn plugins_mut(&mut self) -> &mut Vec<SoundGraphPluginInfo>;
}

impl SoundGraphVoiceInfoTrait for SoundGraphVoiceInfo {
    fn plugins(&self) -> &Vec<SoundGraphPluginInfo> {
        &self.plugins
    }
    fn plugins_mut(&mut self) -> &mut Vec<SoundGraphPluginInfo> {
        &mut self.plugins
    }
}

pub static SOUNDGRAPHVOICEINFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphVoiceInfo",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphVoiceInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundGraphPluginInfo-Array",
                rust_offset: offset_of!(SoundGraphVoiceInfo, plugins),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphVoiceInfo {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHVOICEINFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHVOICEINFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphVoiceInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphVoiceInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphLinkedPluginAttribute {
    pub unconnected_value: f32,
    pub value_index: u16,
    pub node_index_and_flags: u16,
    pub voice_index: u8,
    pub plugin_index: u8,
    pub attribute_index: u8,
}

pub trait SoundGraphLinkedPluginAttributeTrait: TypeObject {
    fn unconnected_value(&self) -> &f32;
    fn unconnected_value_mut(&mut self) -> &mut f32;
    fn value_index(&self) -> &u16;
    fn value_index_mut(&mut self) -> &mut u16;
    fn node_index_and_flags(&self) -> &u16;
    fn node_index_and_flags_mut(&mut self) -> &mut u16;
    fn voice_index(&self) -> &u8;
    fn voice_index_mut(&mut self) -> &mut u8;
    fn plugin_index(&self) -> &u8;
    fn plugin_index_mut(&mut self) -> &mut u8;
    fn attribute_index(&self) -> &u8;
    fn attribute_index_mut(&mut self) -> &mut u8;
}

impl SoundGraphLinkedPluginAttributeTrait for SoundGraphLinkedPluginAttribute {
    fn unconnected_value(&self) -> &f32 {
        &self.unconnected_value
    }
    fn unconnected_value_mut(&mut self) -> &mut f32 {
        &mut self.unconnected_value
    }
    fn value_index(&self) -> &u16 {
        &self.value_index
    }
    fn value_index_mut(&mut self) -> &mut u16 {
        &mut self.value_index
    }
    fn node_index_and_flags(&self) -> &u16 {
        &self.node_index_and_flags
    }
    fn node_index_and_flags_mut(&mut self) -> &mut u16 {
        &mut self.node_index_and_flags
    }
    fn voice_index(&self) -> &u8 {
        &self.voice_index
    }
    fn voice_index_mut(&mut self) -> &mut u8 {
        &mut self.voice_index
    }
    fn plugin_index(&self) -> &u8 {
        &self.plugin_index
    }
    fn plugin_index_mut(&mut self) -> &mut u8 {
        &mut self.plugin_index
    }
    fn attribute_index(&self) -> &u8 {
        &self.attribute_index
    }
    fn attribute_index_mut(&mut self) -> &mut u8 {
        &mut self.attribute_index
    }
}

pub static SOUNDGRAPHLINKEDPLUGINATTRIBUTE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphLinkedPluginAttribute",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphLinkedPluginAttribute as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "UnconnectedValue",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, unconnected_value),
            },
            FieldInfoData {
                name: "ValueIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, value_index),
            },
            FieldInfoData {
                name: "NodeIndexAndFlags",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint16",
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, node_index_and_flags),
            },
            FieldInfoData {
                name: "VoiceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, voice_index),
            },
            FieldInfoData {
                name: "PluginIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, plugin_index),
            },
            FieldInfoData {
                name: "AttributeIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphLinkedPluginAttribute, attribute_index),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphLinkedPluginAttribute {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHLINKEDPLUGINATTRIBUTE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHLINKEDPLUGINATTRIBUTE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphLinkedPluginAttribute-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphLinkedPluginAttribute"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphPluginInfo {
    pub id: u32,
    pub enable_attribute_read_mask: u32,
    pub connection_index: u8,
    pub output_channel_count: u8,
    pub construct_params_index: u8,
    pub construct_param_count: u8,
}

pub trait SoundGraphPluginInfoTrait: TypeObject {
    fn id(&self) -> &u32;
    fn id_mut(&mut self) -> &mut u32;
    fn enable_attribute_read_mask(&self) -> &u32;
    fn enable_attribute_read_mask_mut(&mut self) -> &mut u32;
    fn connection_index(&self) -> &u8;
    fn connection_index_mut(&mut self) -> &mut u8;
    fn output_channel_count(&self) -> &u8;
    fn output_channel_count_mut(&mut self) -> &mut u8;
    fn construct_params_index(&self) -> &u8;
    fn construct_params_index_mut(&mut self) -> &mut u8;
    fn construct_param_count(&self) -> &u8;
    fn construct_param_count_mut(&mut self) -> &mut u8;
}

impl SoundGraphPluginInfoTrait for SoundGraphPluginInfo {
    fn id(&self) -> &u32 {
        &self.id
    }
    fn id_mut(&mut self) -> &mut u32 {
        &mut self.id
    }
    fn enable_attribute_read_mask(&self) -> &u32 {
        &self.enable_attribute_read_mask
    }
    fn enable_attribute_read_mask_mut(&mut self) -> &mut u32 {
        &mut self.enable_attribute_read_mask
    }
    fn connection_index(&self) -> &u8 {
        &self.connection_index
    }
    fn connection_index_mut(&mut self) -> &mut u8 {
        &mut self.connection_index
    }
    fn output_channel_count(&self) -> &u8 {
        &self.output_channel_count
    }
    fn output_channel_count_mut(&mut self) -> &mut u8 {
        &mut self.output_channel_count
    }
    fn construct_params_index(&self) -> &u8 {
        &self.construct_params_index
    }
    fn construct_params_index_mut(&mut self) -> &mut u8 {
        &mut self.construct_params_index
    }
    fn construct_param_count(&self) -> &u8 {
        &self.construct_param_count
    }
    fn construct_param_count_mut(&mut self) -> &mut u8 {
        &mut self.construct_param_count
    }
}

pub static SOUNDGRAPHPLUGININFO_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginInfo",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphPluginInfo as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Id",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundGraphPluginInfo, id),
            },
            FieldInfoData {
                name: "EnableAttributeReadMask",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SoundGraphPluginInfo, enable_attribute_read_mask),
            },
            FieldInfoData {
                name: "ConnectionIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginInfo, connection_index),
            },
            FieldInfoData {
                name: "OutputChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginInfo, output_channel_count),
            },
            FieldInfoData {
                name: "ConstructParamsIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginInfo, construct_params_index),
            },
            FieldInfoData {
                name: "ConstructParamCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginInfo, construct_param_count),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphPluginInfo {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHPLUGININFO_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHPLUGININFO_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginInfo-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginInfo"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphPluginRef {
    pub is_valid: bool,
    pub voice_index: u8,
    pub plugin_index: u8,
}

pub trait SoundGraphPluginRefTrait: TypeObject {
    fn is_valid(&self) -> &bool;
    fn is_valid_mut(&mut self) -> &mut bool;
    fn voice_index(&self) -> &u8;
    fn voice_index_mut(&mut self) -> &mut u8;
    fn plugin_index(&self) -> &u8;
    fn plugin_index_mut(&mut self) -> &mut u8;
}

impl SoundGraphPluginRefTrait for SoundGraphPluginRef {
    fn is_valid(&self) -> &bool {
        &self.is_valid
    }
    fn is_valid_mut(&mut self) -> &mut bool {
        &mut self.is_valid
    }
    fn voice_index(&self) -> &u8 {
        &self.voice_index
    }
    fn voice_index_mut(&mut self) -> &mut u8 {
        &mut self.voice_index
    }
    fn plugin_index(&self) -> &u8 {
        &self.plugin_index
    }
    fn plugin_index_mut(&mut self) -> &mut u8 {
        &mut self.plugin_index
    }
}

pub static SOUNDGRAPHPLUGINREF_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginRef",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphPluginRef as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsValid",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SoundGraphPluginRef, is_valid),
            },
            FieldInfoData {
                name: "VoiceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginRef, voice_index),
            },
            FieldInfoData {
                name: "PluginIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginRef, plugin_index),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundGraphPluginRef {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHPLUGINREF_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHPLUGINREF_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginRef-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginRef"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphPluginConstructParam {
    pub index: u8,
    pub value: f32,
}

pub trait SoundGraphPluginConstructParamTrait: TypeObject {
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
    fn value(&self) -> &f32;
    fn value_mut(&mut self) -> &mut f32;
}

impl SoundGraphPluginConstructParamTrait for SoundGraphPluginConstructParam {
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
    fn value(&self) -> &f32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut f32 {
        &mut self.value
    }
}

pub static SOUNDGRAPHPLUGINCONSTRUCTPARAM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConstructParam",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphPluginConstructParam as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginConstructParam, index),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SoundGraphPluginConstructParam, value),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphPluginConstructParam {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONSTRUCTPARAM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHPLUGINCONSTRUCTPARAM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConstructParam-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConstructParam"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphPluginConnection {
    pub context: Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>,
    pub voice_index: u8,
    pub plugin_index: u8,
    pub signal_index_and_connection_info: u8,
    pub connection_param_base_index: u8,
}

pub trait SoundGraphPluginConnectionTrait: TypeObject {
    fn context(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>>;
    fn voice_index(&self) -> &u8;
    fn voice_index_mut(&mut self) -> &mut u8;
    fn plugin_index(&self) -> &u8;
    fn plugin_index_mut(&mut self) -> &mut u8;
    fn signal_index_and_connection_info(&self) -> &u8;
    fn signal_index_and_connection_info_mut(&mut self) -> &mut u8;
    fn connection_param_base_index(&self) -> &u8;
    fn connection_param_base_index_mut(&mut self) -> &mut u8;
}

impl SoundGraphPluginConnectionTrait for SoundGraphPluginConnection {
    fn context(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &self.context
    }
    fn context_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        &mut self.context
    }
    fn voice_index(&self) -> &u8 {
        &self.voice_index
    }
    fn voice_index_mut(&mut self) -> &mut u8 {
        &mut self.voice_index
    }
    fn plugin_index(&self) -> &u8 {
        &self.plugin_index
    }
    fn plugin_index_mut(&mut self) -> &mut u8 {
        &mut self.plugin_index
    }
    fn signal_index_and_connection_info(&self) -> &u8 {
        &self.signal_index_and_connection_info
    }
    fn signal_index_and_connection_info_mut(&mut self) -> &mut u8 {
        &mut self.signal_index_and_connection_info
    }
    fn connection_param_base_index(&self) -> &u8 {
        &self.connection_param_base_index
    }
    fn connection_param_base_index_mut(&mut self) -> &mut u8 {
        &mut self.connection_param_base_index
    }
}

pub static SOUNDGRAPHPLUGINCONNECTION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnection",
    flags: MemberInfoFlags::new(73),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphPluginConnection as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Context",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodeData",
                rust_offset: offset_of!(SoundGraphPluginConnection, context),
            },
            FieldInfoData {
                name: "VoiceIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginConnection, voice_index),
            },
            FieldInfoData {
                name: "PluginIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginConnection, plugin_index),
            },
            FieldInfoData {
                name: "SignalIndexAndConnectionInfo",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginConnection, signal_index_and_connection_info),
            },
            FieldInfoData {
                name: "ConnectionParamBaseIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginConnection, connection_param_base_index),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SoundGraphPluginConnection {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONNECTION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHPLUGINCONNECTION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnection-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConnection"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SoundGraphPluginConnectionType {
    #[default]
    SoundGraphPluginConnectionType_Unconnected = 0,
    SoundGraphPluginConnectionType_Signal = 1,
    SoundGraphPluginConnectionType_Bus = 2,
    SoundGraphPluginConnectionType_Dynamic = 3,
}

pub static SOUNDGRAPHPLUGINCONNECTIONTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SOUNDGRAPHPLUGINCONNECTIONTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SoundGraphPluginConnectionType {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONNECTIONTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHPLUGINCONNECTIONTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConnectionType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SoundGraphPluginConnectionParam {
    pub index: u8,
    pub value: i32,
}

pub trait SoundGraphPluginConnectionParamTrait: TypeObject {
    fn index(&self) -> &u8;
    fn index_mut(&mut self) -> &mut u8;
    fn value(&self) -> &i32;
    fn value_mut(&mut self) -> &mut i32;
}

impl SoundGraphPluginConnectionParamTrait for SoundGraphPluginConnectionParam {
    fn index(&self) -> &u8 {
        &self.index
    }
    fn index_mut(&mut self) -> &mut u8 {
        &mut self.index
    }
    fn value(&self) -> &i32 {
        &self.value
    }
    fn value_mut(&mut self) -> &mut i32 {
        &mut self.value
    }
}

pub static SOUNDGRAPHPLUGINCONNECTIONPARAM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionParam",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SoundGraphPluginConnectionParam as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SoundGraphPluginConnectionParam, index),
            },
            FieldInfoData {
                name: "Value",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SoundGraphPluginConnectionParam, value),
            },
        ],
    }),
    array_type: Some(SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for SoundGraphPluginConnectionParam {
    fn type_info(&self) -> &'static TypeInfo {
        SOUNDGRAPHPLUGINCONNECTIONPARAM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SOUNDGRAPHPLUGINCONNECTIONPARAM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SoundGraphPluginConnectionParam-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SoundGraphPluginConnectionParam"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FadeCurveType {
    #[default]
    FadeCurveType_LinearAmplitude = 0,
    FadeCurveType_SineAmplitude = 1,
    FadeCurveType_LinearDecibel = 2,
    FadeCurveType_EqualPower = 3,
}

pub static FADECURVETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeCurveType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FADECURVETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FadeCurveType {
    fn type_info(&self) -> &'static TypeInfo {
        FADECURVETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FADECURVETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FadeCurveType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FadeCurveType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PointEnvelope {
    pub _glacier_base: super::core::DataContainer,
    pub points: Vec<PointEnvelopePoint>,
}

pub trait PointEnvelopeTrait: super::core::DataContainerTrait {
    fn points(&self) -> &Vec<PointEnvelopePoint>;
    fn points_mut(&mut self) -> &mut Vec<PointEnvelopePoint>;
}

impl PointEnvelopeTrait for PointEnvelope {
    fn points(&self) -> &Vec<PointEnvelopePoint> {
        &self.points
    }
    fn points_mut(&mut self) -> &mut Vec<PointEnvelopePoint> {
        &mut self.points
    }
}

impl super::core::DataContainerTrait for PointEnvelope {
}

pub static POINTENVELOPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelope",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PointEnvelope as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Points",
                flags: MemberInfoFlags::new(144),
                field_type: "PointEnvelopePoint-Array",
                rust_offset: offset_of!(PointEnvelope, points),
            },
        ],
    }),
    array_type: Some(POINTENVELOPE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PointEnvelope {
    fn type_info(&self) -> &'static TypeInfo {
        POINTENVELOPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static POINTENVELOPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelope-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PointEnvelope"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PointEnvelopePoint {
    pub x: f32,
    pub y: f32,
}

pub trait PointEnvelopePointTrait: TypeObject {
    fn x(&self) -> &f32;
    fn x_mut(&mut self) -> &mut f32;
    fn y(&self) -> &f32;
    fn y_mut(&mut self) -> &mut f32;
}

impl PointEnvelopePointTrait for PointEnvelopePoint {
    fn x(&self) -> &f32 {
        &self.x
    }
    fn x_mut(&mut self) -> &mut f32 {
        &mut self.x
    }
    fn y(&self) -> &f32 {
        &self.y
    }
    fn y_mut(&mut self) -> &mut f32 {
        &mut self.y
    }
}

pub static POINTENVELOPEPOINT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelopePoint",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PointEnvelopePoint as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "X",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointEnvelopePoint, x),
            },
            FieldInfoData {
                name: "Y",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(PointEnvelopePoint, y),
            },
        ],
    }),
    array_type: Some(POINTENVELOPEPOINT_ARRAY_TYPE_INFO),
    alignment: 4,
};

impl TypeObject for PointEnvelopePoint {
    fn type_info(&self) -> &'static TypeInfo {
        POINTENVELOPEPOINT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static POINTENVELOPEPOINT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PointEnvelopePoint-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PointEnvelopePoint"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AudioLanguage {
    pub _glacier_base: super::core::DataContainer,
    pub name: String,
    pub language_mapping: super::core::LanguageFormat,
}

pub trait AudioLanguageTrait: super::core::DataContainerTrait {
    fn name(&self) -> &String;
    fn name_mut(&mut self) -> &mut String;
    fn language_mapping(&self) -> &super::core::LanguageFormat;
    fn language_mapping_mut(&mut self) -> &mut super::core::LanguageFormat;
}

impl AudioLanguageTrait for AudioLanguage {
    fn name(&self) -> &String {
        &self.name
    }
    fn name_mut(&mut self) -> &mut String {
        &mut self.name
    }
    fn language_mapping(&self) -> &super::core::LanguageFormat {
        &self.language_mapping
    }
    fn language_mapping_mut(&mut self) -> &mut super::core::LanguageFormat {
        &mut self.language_mapping
    }
}

impl super::core::DataContainerTrait for AudioLanguage {
}

pub static AUDIOLANGUAGE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguage",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AudioLanguage as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Name",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AudioLanguage, name),
            },
            FieldInfoData {
                name: "LanguageMapping",
                flags: MemberInfoFlags::new(0),
                field_type: "LanguageFormat",
                rust_offset: offset_of!(AudioLanguage, language_mapping),
            },
        ],
    }),
    array_type: Some(AUDIOLANGUAGE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AudioLanguage {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOLANGUAGE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AUDIOLANGUAGE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioLanguage-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioLanguage"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum AudioSystemSpeakerSetup {
    #[default]
    FiveDotOne = 6,
    SevenDotOne = 8,
}

pub static AUDIOSYSTEMSPEAKERSETUP_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemSpeakerSetup",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(AUDIOSYSTEMSPEAKERSETUP_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for AudioSystemSpeakerSetup {
    fn type_info(&self) -> &'static TypeInfo {
        AUDIOSYSTEMSPEAKERSETUP_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static AUDIOSYSTEMSPEAKERSETUP_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AudioSystemSpeakerSetup-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AudioSystemSpeakerSetup"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BeatDetectNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub filter_response_time: f32,
    pub zero_run_detect_time: f32,
    pub beat_detect_frame_size: BeatDetectFrameSize,
    pub causality: BeatDetectCausality,
    pub maximum_beats_per_minute: f32,
    pub update_lookahead: f32,
    pub clicks_per_beat: i32,
    pub click: AudioGraphNodePort,
    pub beats_per_minute: AudioGraphNodePort,
    pub beat_time: AudioGraphNodePort,
    pub beat_confidence: AudioGraphNodePort,
    pub meter: AudioGraphNodePort,
    pub meter_confidence: AudioGraphNodePort,
    pub beat_detect_plugin: SoundGraphPluginRef,
}

pub trait BeatDetectNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn filter_response_time(&self) -> &f32;
    fn filter_response_time_mut(&mut self) -> &mut f32;
    fn zero_run_detect_time(&self) -> &f32;
    fn zero_run_detect_time_mut(&mut self) -> &mut f32;
    fn beat_detect_frame_size(&self) -> &BeatDetectFrameSize;
    fn beat_detect_frame_size_mut(&mut self) -> &mut BeatDetectFrameSize;
    fn causality(&self) -> &BeatDetectCausality;
    fn causality_mut(&mut self) -> &mut BeatDetectCausality;
    fn maximum_beats_per_minute(&self) -> &f32;
    fn maximum_beats_per_minute_mut(&mut self) -> &mut f32;
    fn update_lookahead(&self) -> &f32;
    fn update_lookahead_mut(&mut self) -> &mut f32;
    fn clicks_per_beat(&self) -> &i32;
    fn clicks_per_beat_mut(&mut self) -> &mut i32;
    fn click(&self) -> &AudioGraphNodePort;
    fn click_mut(&mut self) -> &mut AudioGraphNodePort;
    fn beats_per_minute(&self) -> &AudioGraphNodePort;
    fn beats_per_minute_mut(&mut self) -> &mut AudioGraphNodePort;
    fn beat_time(&self) -> &AudioGraphNodePort;
    fn beat_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn beat_confidence(&self) -> &AudioGraphNodePort;
    fn beat_confidence_mut(&mut self) -> &mut AudioGraphNodePort;
    fn meter(&self) -> &AudioGraphNodePort;
    fn meter_mut(&mut self) -> &mut AudioGraphNodePort;
    fn meter_confidence(&self) -> &AudioGraphNodePort;
    fn meter_confidence_mut(&mut self) -> &mut AudioGraphNodePort;
    fn beat_detect_plugin(&self) -> &SoundGraphPluginRef;
    fn beat_detect_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl BeatDetectNodeDataTrait for BeatDetectNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn filter_response_time(&self) -> &f32 {
        &self.filter_response_time
    }
    fn filter_response_time_mut(&mut self) -> &mut f32 {
        &mut self.filter_response_time
    }
    fn zero_run_detect_time(&self) -> &f32 {
        &self.zero_run_detect_time
    }
    fn zero_run_detect_time_mut(&mut self) -> &mut f32 {
        &mut self.zero_run_detect_time
    }
    fn beat_detect_frame_size(&self) -> &BeatDetectFrameSize {
        &self.beat_detect_frame_size
    }
    fn beat_detect_frame_size_mut(&mut self) -> &mut BeatDetectFrameSize {
        &mut self.beat_detect_frame_size
    }
    fn causality(&self) -> &BeatDetectCausality {
        &self.causality
    }
    fn causality_mut(&mut self) -> &mut BeatDetectCausality {
        &mut self.causality
    }
    fn maximum_beats_per_minute(&self) -> &f32 {
        &self.maximum_beats_per_minute
    }
    fn maximum_beats_per_minute_mut(&mut self) -> &mut f32 {
        &mut self.maximum_beats_per_minute
    }
    fn update_lookahead(&self) -> &f32 {
        &self.update_lookahead
    }
    fn update_lookahead_mut(&mut self) -> &mut f32 {
        &mut self.update_lookahead
    }
    fn clicks_per_beat(&self) -> &i32 {
        &self.clicks_per_beat
    }
    fn clicks_per_beat_mut(&mut self) -> &mut i32 {
        &mut self.clicks_per_beat
    }
    fn click(&self) -> &AudioGraphNodePort {
        &self.click
    }
    fn click_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.click
    }
    fn beats_per_minute(&self) -> &AudioGraphNodePort {
        &self.beats_per_minute
    }
    fn beats_per_minute_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.beats_per_minute
    }
    fn beat_time(&self) -> &AudioGraphNodePort {
        &self.beat_time
    }
    fn beat_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.beat_time
    }
    fn beat_confidence(&self) -> &AudioGraphNodePort {
        &self.beat_confidence
    }
    fn beat_confidence_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.beat_confidence
    }
    fn meter(&self) -> &AudioGraphNodePort {
        &self.meter
    }
    fn meter_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.meter
    }
    fn meter_confidence(&self) -> &AudioGraphNodePort {
        &self.meter_confidence
    }
    fn meter_confidence_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.meter_confidence
    }
    fn beat_detect_plugin(&self) -> &SoundGraphPluginRef {
        &self.beat_detect_plugin
    }
    fn beat_detect_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.beat_detect_plugin
    }
}

impl AudioGraphNodeDataTrait for BeatDetectNodeData {
}

impl super::core::DataContainerTrait for BeatDetectNodeData {
}

pub static BEATDETECTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BeatDetectNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, out),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, stop),
            },
            FieldInfoData {
                name: "FilterResponseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BeatDetectNodeData, filter_response_time),
            },
            FieldInfoData {
                name: "ZeroRunDetectTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BeatDetectNodeData, zero_run_detect_time),
            },
            FieldInfoData {
                name: "BeatDetectFrameSize",
                flags: MemberInfoFlags::new(0),
                field_type: "BeatDetectFrameSize",
                rust_offset: offset_of!(BeatDetectNodeData, beat_detect_frame_size),
            },
            FieldInfoData {
                name: "Causality",
                flags: MemberInfoFlags::new(0),
                field_type: "BeatDetectCausality",
                rust_offset: offset_of!(BeatDetectNodeData, causality),
            },
            FieldInfoData {
                name: "MaximumBeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BeatDetectNodeData, maximum_beats_per_minute),
            },
            FieldInfoData {
                name: "UpdateLookahead",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(BeatDetectNodeData, update_lookahead),
            },
            FieldInfoData {
                name: "ClicksPerBeat",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(BeatDetectNodeData, clicks_per_beat),
            },
            FieldInfoData {
                name: "Click",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, click),
            },
            FieldInfoData {
                name: "BeatsPerMinute",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, beats_per_minute),
            },
            FieldInfoData {
                name: "BeatTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, beat_time),
            },
            FieldInfoData {
                name: "BeatConfidence",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, beat_confidence),
            },
            FieldInfoData {
                name: "Meter",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, meter),
            },
            FieldInfoData {
                name: "MeterConfidence",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BeatDetectNodeData, meter_confidence),
            },
            FieldInfoData {
                name: "BeatDetectPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(BeatDetectNodeData, beat_detect_plugin),
            },
        ],
    }),
    array_type: Some(BEATDETECTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BeatDetectNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        BEATDETECTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BEATDETECTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BeatDetectNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BeatDetectCausality {
    #[default]
    BeatDetectCausality_NonCausal = 0,
    BeatDetectCausality_Causal = 1,
}

pub static BEATDETECTCAUSALITY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectCausality",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(BEATDETECTCAUSALITY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BeatDetectCausality {
    fn type_info(&self) -> &'static TypeInfo {
        BEATDETECTCAUSALITY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BEATDETECTCAUSALITY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectCausality-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BeatDetectCausality"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum BeatDetectFrameSize {
    #[default]
    BeatDetectFrameSize_256 = 0,
    BeatDetectFrameSize_512 = 1,
}

pub static BEATDETECTFRAMESIZE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectFrameSize",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(BEATDETECTFRAMESIZE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for BeatDetectFrameSize {
    fn type_info(&self) -> &'static TypeInfo {
        BEATDETECTFRAMESIZE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static BEATDETECTFRAMESIZE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BeatDetectFrameSize-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BeatDetectFrameSize"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ModelReverbNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub max_space_size: f32,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub reverb_time: AudioGraphNodePort,
    pub space_size: AudioGraphNodePort,
    pub brightness: AudioGraphNodePort,
    pub reverb_plugin: SoundGraphPluginRef,
}

pub trait ModelReverbNodeDataTrait: AudioGraphNodeDataTrait {
    fn max_space_size(&self) -> &f32;
    fn max_space_size_mut(&mut self) -> &mut f32;
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_time(&self) -> &AudioGraphNodePort;
    fn reverb_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn space_size(&self) -> &AudioGraphNodePort;
    fn space_size_mut(&mut self) -> &mut AudioGraphNodePort;
    fn brightness(&self) -> &AudioGraphNodePort;
    fn brightness_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_plugin(&self) -> &SoundGraphPluginRef;
    fn reverb_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl ModelReverbNodeDataTrait for ModelReverbNodeData {
    fn max_space_size(&self) -> &f32 {
        &self.max_space_size
    }
    fn max_space_size_mut(&mut self) -> &mut f32 {
        &mut self.max_space_size
    }
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn reverb_time(&self) -> &AudioGraphNodePort {
        &self.reverb_time
    }
    fn reverb_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb_time
    }
    fn space_size(&self) -> &AudioGraphNodePort {
        &self.space_size
    }
    fn space_size_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.space_size
    }
    fn brightness(&self) -> &AudioGraphNodePort {
        &self.brightness
    }
    fn brightness_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.brightness
    }
    fn reverb_plugin(&self) -> &SoundGraphPluginRef {
        &self.reverb_plugin
    }
    fn reverb_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.reverb_plugin
    }
}

impl AudioGraphNodeDataTrait for ModelReverbNodeData {
}

impl super::core::DataContainerTrait for ModelReverbNodeData {
}

pub static MODELREVERBNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelReverbNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ModelReverbNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MaxSpaceSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ModelReverbNodeData, max_space_size),
            },
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ModelReverbNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ModelReverbNodeData, out),
            },
            FieldInfoData {
                name: "ReverbTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ModelReverbNodeData, reverb_time),
            },
            FieldInfoData {
                name: "SpaceSize",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ModelReverbNodeData, space_size),
            },
            FieldInfoData {
                name: "Brightness",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ModelReverbNodeData, brightness),
            },
            FieldInfoData {
                name: "ReverbPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ModelReverbNodeData, reverb_plugin),
            },
        ],
    }),
    array_type: Some(MODELREVERBNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ModelReverbNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MODELREVERBNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MODELREVERBNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ModelReverbNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ModelReverbNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ActivateMixerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub mixer: Option<Arc<Mutex<dyn MixerAssetTrait>>>,
    pub activate: AudioGraphNodePort,
    pub deactivate: AudioGraphNodePort,
}

pub trait ActivateMixerNodeDataTrait: AudioGraphNodeDataTrait {
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>>;
    fn activate(&self) -> &AudioGraphNodePort;
    fn activate_mut(&mut self) -> &mut AudioGraphNodePort;
    fn deactivate(&self) -> &AudioGraphNodePort;
    fn deactivate_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl ActivateMixerNodeDataTrait for ActivateMixerNodeData {
    fn mixer(&self) -> &Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &self.mixer
    }
    fn mixer_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixerAssetTrait>>> {
        &mut self.mixer
    }
    fn activate(&self) -> &AudioGraphNodePort {
        &self.activate
    }
    fn activate_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.activate
    }
    fn deactivate(&self) -> &AudioGraphNodePort {
        &self.deactivate
    }
    fn deactivate_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.deactivate
    }
}

impl AudioGraphNodeDataTrait for ActivateMixerNodeData {
}

impl super::core::DataContainerTrait for ActivateMixerNodeData {
}

pub static ACTIVATEMIXERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActivateMixerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ActivateMixerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Mixer",
                flags: MemberInfoFlags::new(0),
                field_type: "MixerAsset",
                rust_offset: offset_of!(ActivateMixerNodeData, mixer),
            },
            FieldInfoData {
                name: "Activate",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ActivateMixerNodeData, activate),
            },
            FieldInfoData {
                name: "Deactivate",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ActivateMixerNodeData, deactivate),
            },
        ],
    }),
    array_type: Some(ACTIVATEMIXERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ActivateMixerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        ACTIVATEMIXERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ACTIVATEMIXERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ActivateMixerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ActivateMixerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VuMeterNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub front_left: AudioGraphNodePort,
    pub center: AudioGraphNodePort,
    pub front_right: AudioGraphNodePort,
    pub rear_left: AudioGraphNodePort,
    pub rear_right: AudioGraphNodePort,
    pub lfe: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub mode: VuMeterMode,
    pub efficiency: i32,
    pub render_v_u_meter_bars: bool,
    pub v_u_meter_x_pos: i32,
    pub v_u_meter_y_pos: i32,
}

pub trait VuMeterNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn front_left(&self) -> &AudioGraphNodePort;
    fn front_left_mut(&mut self) -> &mut AudioGraphNodePort;
    fn center(&self) -> &AudioGraphNodePort;
    fn center_mut(&mut self) -> &mut AudioGraphNodePort;
    fn front_right(&self) -> &AudioGraphNodePort;
    fn front_right_mut(&mut self) -> &mut AudioGraphNodePort;
    fn rear_left(&self) -> &AudioGraphNodePort;
    fn rear_left_mut(&mut self) -> &mut AudioGraphNodePort;
    fn rear_right(&self) -> &AudioGraphNodePort;
    fn rear_right_mut(&mut self) -> &mut AudioGraphNodePort;
    fn lfe(&self) -> &AudioGraphNodePort;
    fn lfe_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn mode(&self) -> &VuMeterMode;
    fn mode_mut(&mut self) -> &mut VuMeterMode;
    fn efficiency(&self) -> &i32;
    fn efficiency_mut(&mut self) -> &mut i32;
    fn render_v_u_meter_bars(&self) -> &bool;
    fn render_v_u_meter_bars_mut(&mut self) -> &mut bool;
    fn v_u_meter_x_pos(&self) -> &i32;
    fn v_u_meter_x_pos_mut(&mut self) -> &mut i32;
    fn v_u_meter_y_pos(&self) -> &i32;
    fn v_u_meter_y_pos_mut(&mut self) -> &mut i32;
}

impl VuMeterNodeDataTrait for VuMeterNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn front_left(&self) -> &AudioGraphNodePort {
        &self.front_left
    }
    fn front_left_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.front_left
    }
    fn center(&self) -> &AudioGraphNodePort {
        &self.center
    }
    fn center_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.center
    }
    fn front_right(&self) -> &AudioGraphNodePort {
        &self.front_right
    }
    fn front_right_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.front_right
    }
    fn rear_left(&self) -> &AudioGraphNodePort {
        &self.rear_left
    }
    fn rear_left_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.rear_left
    }
    fn rear_right(&self) -> &AudioGraphNodePort {
        &self.rear_right
    }
    fn rear_right_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.rear_right
    }
    fn lfe(&self) -> &AudioGraphNodePort {
        &self.lfe
    }
    fn lfe_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.lfe
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn mode(&self) -> &VuMeterMode {
        &self.mode
    }
    fn mode_mut(&mut self) -> &mut VuMeterMode {
        &mut self.mode
    }
    fn efficiency(&self) -> &i32 {
        &self.efficiency
    }
    fn efficiency_mut(&mut self) -> &mut i32 {
        &mut self.efficiency
    }
    fn render_v_u_meter_bars(&self) -> &bool {
        &self.render_v_u_meter_bars
    }
    fn render_v_u_meter_bars_mut(&mut self) -> &mut bool {
        &mut self.render_v_u_meter_bars
    }
    fn v_u_meter_x_pos(&self) -> &i32 {
        &self.v_u_meter_x_pos
    }
    fn v_u_meter_x_pos_mut(&mut self) -> &mut i32 {
        &mut self.v_u_meter_x_pos
    }
    fn v_u_meter_y_pos(&self) -> &i32 {
        &self.v_u_meter_y_pos
    }
    fn v_u_meter_y_pos_mut(&mut self) -> &mut i32 {
        &mut self.v_u_meter_y_pos
    }
}

impl AudioGraphNodeDataTrait for VuMeterNodeData {
}

impl super::core::DataContainerTrait for VuMeterNodeData {
}

pub static VUMETERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VuMeterNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, out),
            },
            FieldInfoData {
                name: "FrontLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, front_left),
            },
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, center),
            },
            FieldInfoData {
                name: "FrontRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, front_right),
            },
            FieldInfoData {
                name: "RearLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, rear_left),
            },
            FieldInfoData {
                name: "RearRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, rear_right),
            },
            FieldInfoData {
                name: "Lfe",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VuMeterNodeData, lfe),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(VuMeterNodeData, plugin),
            },
            FieldInfoData {
                name: "Mode",
                flags: MemberInfoFlags::new(0),
                field_type: "VuMeterMode",
                rust_offset: offset_of!(VuMeterNodeData, mode),
            },
            FieldInfoData {
                name: "Efficiency",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VuMeterNodeData, efficiency),
            },
            FieldInfoData {
                name: "RenderVUMeterBars",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(VuMeterNodeData, render_v_u_meter_bars),
            },
            FieldInfoData {
                name: "VUMeterXPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VuMeterNodeData, v_u_meter_x_pos),
            },
            FieldInfoData {
                name: "VUMeterYPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(VuMeterNodeData, v_u_meter_y_pos),
            },
        ],
    }),
    array_type: Some(VUMETERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VuMeterNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        VUMETERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VUMETERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VuMeterNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum VuMeterMode {
    #[default]
    VuMeterMode_Rms = 0,
    VuMeterMode_Peak = 1,
    VuMeterMode_LargestPeak = 2,
}

pub static VUMETERMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(VUMETERMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for VuMeterMode {
    fn type_info(&self) -> &'static TypeInfo {
        VUMETERMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static VUMETERMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VuMeterMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VuMeterMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VibratoNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub max_modulation_depth: f32,
    pub modulation_depth: AudioGraphNodePort,
    pub modulation_frequency: AudioGraphNodePort,
}

pub trait VibratoNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn max_modulation_depth(&self) -> &f32;
    fn max_modulation_depth_mut(&mut self) -> &mut f32;
    fn modulation_depth(&self) -> &AudioGraphNodePort;
    fn modulation_depth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn modulation_frequency(&self) -> &AudioGraphNodePort;
    fn modulation_frequency_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl VibratoNodeDataTrait for VibratoNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn max_modulation_depth(&self) -> &f32 {
        &self.max_modulation_depth
    }
    fn max_modulation_depth_mut(&mut self) -> &mut f32 {
        &mut self.max_modulation_depth
    }
    fn modulation_depth(&self) -> &AudioGraphNodePort {
        &self.modulation_depth
    }
    fn modulation_depth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.modulation_depth
    }
    fn modulation_frequency(&self) -> &AudioGraphNodePort {
        &self.modulation_frequency
    }
    fn modulation_frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.modulation_frequency
    }
}

impl AudioGraphNodeDataTrait for VibratoNodeData {
}

impl super::core::DataContainerTrait for VibratoNodeData {
}

pub static VIBRATONODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VibratoNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VibratoNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VibratoNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VibratoNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(VibratoNodeData, plugin),
            },
            FieldInfoData {
                name: "MaxModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(VibratoNodeData, max_modulation_depth),
            },
            FieldInfoData {
                name: "ModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VibratoNodeData, modulation_depth),
            },
            FieldInfoData {
                name: "ModulationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VibratoNodeData, modulation_frequency),
            },
        ],
    }),
    array_type: Some(VIBRATONODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VibratoNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        VIBRATONODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VIBRATONODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VibratoNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VibratoNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaveSwitcherNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub waves: Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>>,
    pub default_index: f32,
}

pub trait WaveSwitcherNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn waves(&self) -> &Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>>;
    fn waves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>>;
    fn default_index(&self) -> &f32;
    fn default_index_mut(&mut self) -> &mut f32;
}

impl WaveSwitcherNodeConfigDataTrait for WaveSwitcherNodeConfigData {
    fn waves(&self) -> &Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>> {
        &self.waves
    }
    fn waves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>> {
        &mut self.waves
    }
    fn default_index(&self) -> &f32 {
        &self.default_index
    }
    fn default_index_mut(&mut self) -> &mut f32 {
        &mut self.default_index
    }
}

impl AudioGraphNodeConfigDataTrait for WaveSwitcherNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for WaveSwitcherNodeConfigData {
}

pub static WAVESWITCHERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaveSwitcherNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Waves",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveAssetBase-Array",
                rust_offset: offset_of!(WaveSwitcherNodeConfigData, waves),
            },
            FieldInfoData {
                name: "DefaultIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WaveSwitcherNodeConfigData, default_index),
            },
        ],
    }),
    array_type: Some(WAVESWITCHERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveSwitcherNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        WAVESWITCHERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAVESWITCHERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveSwitcherNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaveSwitcherNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub index: AudioGraphNodePort,
    pub advance: AudioGraphNodePort,
    pub wave: AudioGraphNodePort,
    pub index_changed: AudioGraphNodePort,
    pub waves: Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>>,
    pub default_index: f32,
    pub wrap_index: bool,
    pub is_random: bool,
    pub random_start_index: bool,
}

pub trait WaveSwitcherNodeDataTrait: AudioGraphNodeDataTrait {
    fn index(&self) -> &AudioGraphNodePort;
    fn index_mut(&mut self) -> &mut AudioGraphNodePort;
    fn advance(&self) -> &AudioGraphNodePort;
    fn advance_mut(&mut self) -> &mut AudioGraphNodePort;
    fn wave(&self) -> &AudioGraphNodePort;
    fn wave_mut(&mut self) -> &mut AudioGraphNodePort;
    fn index_changed(&self) -> &AudioGraphNodePort;
    fn index_changed_mut(&mut self) -> &mut AudioGraphNodePort;
    fn waves(&self) -> &Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>>;
    fn waves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>>;
    fn default_index(&self) -> &f32;
    fn default_index_mut(&mut self) -> &mut f32;
    fn wrap_index(&self) -> &bool;
    fn wrap_index_mut(&mut self) -> &mut bool;
    fn is_random(&self) -> &bool;
    fn is_random_mut(&mut self) -> &mut bool;
    fn random_start_index(&self) -> &bool;
    fn random_start_index_mut(&mut self) -> &mut bool;
}

impl WaveSwitcherNodeDataTrait for WaveSwitcherNodeData {
    fn index(&self) -> &AudioGraphNodePort {
        &self.index
    }
    fn index_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.index
    }
    fn advance(&self) -> &AudioGraphNodePort {
        &self.advance
    }
    fn advance_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.advance
    }
    fn wave(&self) -> &AudioGraphNodePort {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.wave
    }
    fn index_changed(&self) -> &AudioGraphNodePort {
        &self.index_changed
    }
    fn index_changed_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.index_changed
    }
    fn waves(&self) -> &Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>> {
        &self.waves
    }
    fn waves_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>> {
        &mut self.waves
    }
    fn default_index(&self) -> &f32 {
        &self.default_index
    }
    fn default_index_mut(&mut self) -> &mut f32 {
        &mut self.default_index
    }
    fn wrap_index(&self) -> &bool {
        &self.wrap_index
    }
    fn wrap_index_mut(&mut self) -> &mut bool {
        &mut self.wrap_index
    }
    fn is_random(&self) -> &bool {
        &self.is_random
    }
    fn is_random_mut(&mut self) -> &mut bool {
        &mut self.is_random
    }
    fn random_start_index(&self) -> &bool {
        &self.random_start_index
    }
    fn random_start_index_mut(&mut self) -> &mut bool {
        &mut self.random_start_index
    }
}

impl AudioGraphNodeDataTrait for WaveSwitcherNodeData {
}

impl super::core::DataContainerTrait for WaveSwitcherNodeData {
}

pub static WAVESWITCHERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaveSwitcherNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Index",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveSwitcherNodeData, index),
            },
            FieldInfoData {
                name: "Advance",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveSwitcherNodeData, advance),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveSwitcherNodeData, wave),
            },
            FieldInfoData {
                name: "IndexChanged",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveSwitcherNodeData, index_changed),
            },
            FieldInfoData {
                name: "Waves",
                flags: MemberInfoFlags::new(144),
                field_type: "SoundWaveAssetBase-Array",
                rust_offset: offset_of!(WaveSwitcherNodeData, waves),
            },
            FieldInfoData {
                name: "DefaultIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(WaveSwitcherNodeData, default_index),
            },
            FieldInfoData {
                name: "WrapIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaveSwitcherNodeData, wrap_index),
            },
            FieldInfoData {
                name: "IsRandom",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaveSwitcherNodeData, is_random),
            },
            FieldInfoData {
                name: "RandomStartIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(WaveSwitcherNodeData, random_start_index),
            },
        ],
    }),
    array_type: Some(WAVESWITCHERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveSwitcherNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        WAVESWITCHERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAVESWITCHERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveSwitcherNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveSwitcherNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaveQueryNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub select: AudioGraphNodePort,
    pub selection_parameters: Vec<Option<Arc<Mutex<dyn WaveQueryNodeParameterEntryTrait>>>>,
    pub selection: AudioGraphNodePort,
    pub selected: AudioGraphNodePort,
    pub selection_failed: AudioGraphNodePort,
    pub wave_references: Vec<Option<Arc<Mutex<dyn WaveQueryWaveAssetReferenceTrait>>>>,
}

pub trait WaveQueryNodeDataTrait: AudioGraphNodeDataTrait {
    fn select(&self) -> &AudioGraphNodePort;
    fn select_mut(&mut self) -> &mut AudioGraphNodePort;
    fn selection_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn WaveQueryNodeParameterEntryTrait>>>>;
    fn selection_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WaveQueryNodeParameterEntryTrait>>>>;
    fn selection(&self) -> &AudioGraphNodePort;
    fn selection_mut(&mut self) -> &mut AudioGraphNodePort;
    fn selected(&self) -> &AudioGraphNodePort;
    fn selected_mut(&mut self) -> &mut AudioGraphNodePort;
    fn selection_failed(&self) -> &AudioGraphNodePort;
    fn selection_failed_mut(&mut self) -> &mut AudioGraphNodePort;
    fn wave_references(&self) -> &Vec<Option<Arc<Mutex<dyn WaveQueryWaveAssetReferenceTrait>>>>;
    fn wave_references_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WaveQueryWaveAssetReferenceTrait>>>>;
}

impl WaveQueryNodeDataTrait for WaveQueryNodeData {
    fn select(&self) -> &AudioGraphNodePort {
        &self.select
    }
    fn select_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.select
    }
    fn selection_parameters(&self) -> &Vec<Option<Arc<Mutex<dyn WaveQueryNodeParameterEntryTrait>>>> {
        &self.selection_parameters
    }
    fn selection_parameters_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WaveQueryNodeParameterEntryTrait>>>> {
        &mut self.selection_parameters
    }
    fn selection(&self) -> &AudioGraphNodePort {
        &self.selection
    }
    fn selection_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.selection
    }
    fn selected(&self) -> &AudioGraphNodePort {
        &self.selected
    }
    fn selected_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.selected
    }
    fn selection_failed(&self) -> &AudioGraphNodePort {
        &self.selection_failed
    }
    fn selection_failed_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.selection_failed
    }
    fn wave_references(&self) -> &Vec<Option<Arc<Mutex<dyn WaveQueryWaveAssetReferenceTrait>>>> {
        &self.wave_references
    }
    fn wave_references_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn WaveQueryWaveAssetReferenceTrait>>>> {
        &mut self.wave_references
    }
}

impl AudioGraphNodeDataTrait for WaveQueryNodeData {
}

impl super::core::DataContainerTrait for WaveQueryNodeData {
}

pub static WAVEQUERYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaveQueryNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Select",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveQueryNodeData, select),
            },
            FieldInfoData {
                name: "SelectionParameters",
                flags: MemberInfoFlags::new(144),
                field_type: "WaveQueryNodeParameterEntry-Array",
                rust_offset: offset_of!(WaveQueryNodeData, selection_parameters),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveQueryNodeData, selection),
            },
            FieldInfoData {
                name: "Selected",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveQueryNodeData, selected),
            },
            FieldInfoData {
                name: "SelectionFailed",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveQueryNodeData, selection_failed),
            },
            FieldInfoData {
                name: "WaveReferences",
                flags: MemberInfoFlags::new(144),
                field_type: "WaveQueryWaveAssetReference-Array",
                rust_offset: offset_of!(WaveQueryNodeData, wave_references),
            },
        ],
    }),
    array_type: Some(WAVEQUERYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveQueryNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        WAVEQUERYNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAVEQUERYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaveQueryNodeParameterEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub selection_param: AudioGraphNodePort,
    pub parameter_name_hash: u32,
}

pub trait WaveQueryNodeParameterEntryTrait: AudioGraphNodePortGroupTrait {
    fn selection_param(&self) -> &AudioGraphNodePort;
    fn selection_param_mut(&mut self) -> &mut AudioGraphNodePort;
    fn parameter_name_hash(&self) -> &u32;
    fn parameter_name_hash_mut(&mut self) -> &mut u32;
}

impl WaveQueryNodeParameterEntryTrait for WaveQueryNodeParameterEntry {
    fn selection_param(&self) -> &AudioGraphNodePort {
        &self.selection_param
    }
    fn selection_param_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.selection_param
    }
    fn parameter_name_hash(&self) -> &u32 {
        &self.parameter_name_hash
    }
    fn parameter_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.parameter_name_hash
    }
}

impl AudioGraphNodePortGroupTrait for WaveQueryNodeParameterEntry {
}

impl super::core::DataContainerTrait for WaveQueryNodeParameterEntry {
}

pub static WAVEQUERYNODEPARAMETERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaveQueryNodeParameterEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SelectionParam",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(WaveQueryNodeParameterEntry, selection_param),
            },
            FieldInfoData {
                name: "ParameterNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(WaveQueryNodeParameterEntry, parameter_name_hash),
            },
        ],
    }),
    array_type: Some(WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveQueryNodeParameterEntry {
    fn type_info(&self) -> &'static TypeInfo {
        WAVEQUERYNODEPARAMETERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAVEQUERYNODEPARAMETERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryNodeParameterEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct WaveQueryWaveAssetReference {
    pub _glacier_base: super::core::DataContainer,
    pub wave_asset: Option<Arc<Mutex<dyn NewWaveAssetTrait>>>,
    pub selection_group: Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>,
}

pub trait WaveQueryWaveAssetReferenceTrait: super::core::DataContainerTrait {
    fn wave_asset(&self) -> &Option<Arc<Mutex<dyn NewWaveAssetTrait>>>;
    fn wave_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveAssetTrait>>>;
    fn selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>;
    fn selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>;
}

impl WaveQueryWaveAssetReferenceTrait for WaveQueryWaveAssetReference {
    fn wave_asset(&self) -> &Option<Arc<Mutex<dyn NewWaveAssetTrait>>> {
        &self.wave_asset
    }
    fn wave_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveAssetTrait>>> {
        &mut self.wave_asset
    }
    fn selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        &self.selection_group
    }
    fn selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        &mut self.selection_group
    }
}

impl super::core::DataContainerTrait for WaveQueryWaveAssetReference {
}

pub static WAVEQUERYWAVEASSETREFERENCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryWaveAssetReference",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<WaveQueryWaveAssetReference as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "WaveAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveAsset",
                rust_offset: offset_of!(WaveQueryWaveAssetReference, wave_asset),
            },
            FieldInfoData {
                name: "SelectionGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveSelectionGroup",
                rust_offset: offset_of!(WaveQueryWaveAssetReference, selection_group),
            },
        ],
    }),
    array_type: Some(WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for WaveQueryWaveAssetReference {
    fn type_info(&self) -> &'static TypeInfo {
        WAVEQUERYWAVEASSETREFERENCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static WAVEQUERYWAVEASSETREFERENCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryWaveAssetReference-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryWaveAssetReference"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WaveQueryNodeParameterEntryType {
    #[default]
    WaveQueryNodeParameterEntryType_Int = 0,
    WaveQueryNodeParameterEntryType_Float = 1,
    WaveQueryNodeParameterEntryType_Bool = 2,
}

pub static WAVEQUERYNODEPARAMETERENTRYTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntryType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(WAVEQUERYNODEPARAMETERENTRYTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WaveQueryNodeParameterEntryType {
    fn type_info(&self) -> &'static TypeInfo {
        WAVEQUERYNODEPARAMETERENTRYTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WAVEQUERYNODEPARAMETERENTRYTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryNodeParameterEntryType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryNodeParameterEntryType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum WaveQueryConstEnum {
    #[default]
    WaveQueryMaxNumSelectionParams = 20,
}

pub static WAVEQUERYCONSTENUM_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryConstEnum",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(WAVEQUERYCONSTENUM_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for WaveQueryConstEnum {
    fn type_info(&self) -> &'static TypeInfo {
        WAVEQUERYCONSTENUM_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static WAVEQUERYCONSTENUM_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "WaveQueryConstEnum-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("WaveQueryConstEnum"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct VariationSelectionObserverNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub selection: AudioGraphNodePort,
    pub select: AudioGraphNodePort,
    pub num_variations_in_selection: AudioGraphNodePort,
    pub num_variations_validated: AudioGraphNodePort,
    pub num_variations_loaded: AudioGraphNodePort,
    pub new_wave_asset: Option<Arc<Mutex<dyn NewWaveAssetTrait>>>,
    pub variation_ids: Vec<u32>,
}

pub trait VariationSelectionObserverNodeDataTrait: AudioGraphNodeDataTrait {
    fn selection(&self) -> &AudioGraphNodePort;
    fn selection_mut(&mut self) -> &mut AudioGraphNodePort;
    fn select(&self) -> &AudioGraphNodePort;
    fn select_mut(&mut self) -> &mut AudioGraphNodePort;
    fn num_variations_in_selection(&self) -> &AudioGraphNodePort;
    fn num_variations_in_selection_mut(&mut self) -> &mut AudioGraphNodePort;
    fn num_variations_validated(&self) -> &AudioGraphNodePort;
    fn num_variations_validated_mut(&mut self) -> &mut AudioGraphNodePort;
    fn num_variations_loaded(&self) -> &AudioGraphNodePort;
    fn num_variations_loaded_mut(&mut self) -> &mut AudioGraphNodePort;
    fn new_wave_asset(&self) -> &Option<Arc<Mutex<dyn NewWaveAssetTrait>>>;
    fn new_wave_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveAssetTrait>>>;
    fn variation_ids(&self) -> &Vec<u32>;
    fn variation_ids_mut(&mut self) -> &mut Vec<u32>;
}

impl VariationSelectionObserverNodeDataTrait for VariationSelectionObserverNodeData {
    fn selection(&self) -> &AudioGraphNodePort {
        &self.selection
    }
    fn selection_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.selection
    }
    fn select(&self) -> &AudioGraphNodePort {
        &self.select
    }
    fn select_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.select
    }
    fn num_variations_in_selection(&self) -> &AudioGraphNodePort {
        &self.num_variations_in_selection
    }
    fn num_variations_in_selection_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.num_variations_in_selection
    }
    fn num_variations_validated(&self) -> &AudioGraphNodePort {
        &self.num_variations_validated
    }
    fn num_variations_validated_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.num_variations_validated
    }
    fn num_variations_loaded(&self) -> &AudioGraphNodePort {
        &self.num_variations_loaded
    }
    fn num_variations_loaded_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.num_variations_loaded
    }
    fn new_wave_asset(&self) -> &Option<Arc<Mutex<dyn NewWaveAssetTrait>>> {
        &self.new_wave_asset
    }
    fn new_wave_asset_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveAssetTrait>>> {
        &mut self.new_wave_asset
    }
    fn variation_ids(&self) -> &Vec<u32> {
        &self.variation_ids
    }
    fn variation_ids_mut(&mut self) -> &mut Vec<u32> {
        &mut self.variation_ids
    }
}

impl AudioGraphNodeDataTrait for VariationSelectionObserverNodeData {
}

impl super::core::DataContainerTrait for VariationSelectionObserverNodeData {
}

pub static VARIATIONSELECTIONOBSERVERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariationSelectionObserverNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<VariationSelectionObserverNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, selection),
            },
            FieldInfoData {
                name: "Select",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, select),
            },
            FieldInfoData {
                name: "NumVariationsInSelection",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, num_variations_in_selection),
            },
            FieldInfoData {
                name: "NumVariationsValidated",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, num_variations_validated),
            },
            FieldInfoData {
                name: "NumVariationsLoaded",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, num_variations_loaded),
            },
            FieldInfoData {
                name: "NewWaveAsset",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveAsset",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, new_wave_asset),
            },
            FieldInfoData {
                name: "VariationIds",
                flags: MemberInfoFlags::new(144),
                field_type: "Uint32-Array",
                rust_offset: offset_of!(VariationSelectionObserverNodeData, variation_ids),
            },
        ],
    }),
    array_type: Some(VARIATIONSELECTIONOBSERVERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for VariationSelectionObserverNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        VARIATIONSELECTIONOBSERVERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static VARIATIONSELECTIONOBSERVERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "VariationSelectionObserverNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("VariationSelectionObserverNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UserMusicControllerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#override: AudioGraphNodePort,
    pub restore: AudioGraphNodePort,
    pub restore_on_deactivated: bool,
}

pub trait UserMusicControllerNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#override(&self) -> &AudioGraphNodePort;
    fn r#override_mut(&mut self) -> &mut AudioGraphNodePort;
    fn restore(&self) -> &AudioGraphNodePort;
    fn restore_mut(&mut self) -> &mut AudioGraphNodePort;
    fn restore_on_deactivated(&self) -> &bool;
    fn restore_on_deactivated_mut(&mut self) -> &mut bool;
}

impl UserMusicControllerNodeDataTrait for UserMusicControllerNodeData {
    fn r#override(&self) -> &AudioGraphNodePort {
        &self.r#override
    }
    fn r#override_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#override
    }
    fn restore(&self) -> &AudioGraphNodePort {
        &self.restore
    }
    fn restore_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.restore
    }
    fn restore_on_deactivated(&self) -> &bool {
        &self.restore_on_deactivated
    }
    fn restore_on_deactivated_mut(&mut self) -> &mut bool {
        &mut self.restore_on_deactivated
    }
}

impl AudioGraphNodeDataTrait for UserMusicControllerNodeData {
}

impl super::core::DataContainerTrait for UserMusicControllerNodeData {
}

pub static USERMUSICCONTROLLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicControllerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UserMusicControllerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Override",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(UserMusicControllerNodeData, r#override),
            },
            FieldInfoData {
                name: "Restore",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(UserMusicControllerNodeData, restore),
            },
            FieldInfoData {
                name: "RestoreOnDeactivated",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(UserMusicControllerNodeData, restore_on_deactivated),
            },
        ],
    }),
    array_type: Some(USERMUSICCONTROLLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UserMusicControllerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        USERMUSICCONTROLLERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static USERMUSICCONTROLLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicControllerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("UserMusicControllerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct UserMusicArbiterNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait UserMusicArbiterNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl UserMusicArbiterNodeDataTrait for UserMusicArbiterNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for UserMusicArbiterNodeData {
}

impl super::core::DataContainerTrait for UserMusicArbiterNodeData {
}

pub static USERMUSICARBITERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicArbiterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<UserMusicArbiterNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(UserMusicArbiterNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(UserMusicArbiterNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(UserMusicArbiterNodeData, plugin),
            },
        ],
    }),
    array_type: Some(USERMUSICARBITERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for UserMusicArbiterNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        USERMUSICARBITERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static USERMUSICARBITERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "UserMusicArbiterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("UserMusicArbiterNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct TimeStretchNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub window_size: f32,
    pub multi_channel_mode: TimeStretchMultiChannelMode,
    pub efficiency: TimeStretchEfficiency,
    pub stretch_ratio: AudioGraphNodePort,
}

pub trait TimeStretchNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn window_size(&self) -> &f32;
    fn window_size_mut(&mut self) -> &mut f32;
    fn multi_channel_mode(&self) -> &TimeStretchMultiChannelMode;
    fn multi_channel_mode_mut(&mut self) -> &mut TimeStretchMultiChannelMode;
    fn efficiency(&self) -> &TimeStretchEfficiency;
    fn efficiency_mut(&mut self) -> &mut TimeStretchEfficiency;
    fn stretch_ratio(&self) -> &AudioGraphNodePort;
    fn stretch_ratio_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl TimeStretchNodeDataTrait for TimeStretchNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn window_size(&self) -> &f32 {
        &self.window_size
    }
    fn window_size_mut(&mut self) -> &mut f32 {
        &mut self.window_size
    }
    fn multi_channel_mode(&self) -> &TimeStretchMultiChannelMode {
        &self.multi_channel_mode
    }
    fn multi_channel_mode_mut(&mut self) -> &mut TimeStretchMultiChannelMode {
        &mut self.multi_channel_mode
    }
    fn efficiency(&self) -> &TimeStretchEfficiency {
        &self.efficiency
    }
    fn efficiency_mut(&mut self) -> &mut TimeStretchEfficiency {
        &mut self.efficiency
    }
    fn stretch_ratio(&self) -> &AudioGraphNodePort {
        &self.stretch_ratio
    }
    fn stretch_ratio_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stretch_ratio
    }
}

impl AudioGraphNodeDataTrait for TimeStretchNodeData {
}

impl super::core::DataContainerTrait for TimeStretchNodeData {
}

pub static TIMESTRETCHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<TimeStretchNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimeStretchNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimeStretchNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(TimeStretchNodeData, plugin),
            },
            FieldInfoData {
                name: "WindowSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(TimeStretchNodeData, window_size),
            },
            FieldInfoData {
                name: "MultiChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeStretchMultiChannelMode",
                rust_offset: offset_of!(TimeStretchNodeData, multi_channel_mode),
            },
            FieldInfoData {
                name: "Efficiency",
                flags: MemberInfoFlags::new(0),
                field_type: "TimeStretchEfficiency",
                rust_offset: offset_of!(TimeStretchNodeData, efficiency),
            },
            FieldInfoData {
                name: "StretchRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(TimeStretchNodeData, stretch_ratio),
            },
        ],
    }),
    array_type: Some(TIMESTRETCHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for TimeStretchNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        TIMESTRETCHNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static TIMESTRETCHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimeStretchNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimeStretchEfficiency {
    #[default]
    TimeStretchEfficiency_1 = 1,
    TimeStretchEfficiency_2 = 2,
    TimeStretchEfficiency_3 = 4,
    TimeStretchEfficiency_4 = 8,
    TimeStretchEfficiency_5 = 12,
    TimeStretchEfficiency_6 = 16,
    TimeStretchEfficiency_7 = 20,
    TimeStretchEfficiency_8 = 24,
    TimeStretchEfficiency_9 = 28,
    TimeStretchEfficiency_10 = 32,
}

pub static TIMESTRETCHEFFICIENCY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchEfficiency",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMESTRETCHEFFICIENCY_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeStretchEfficiency {
    fn type_info(&self) -> &'static TypeInfo {
        TIMESTRETCHEFFICIENCY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TIMESTRETCHEFFICIENCY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchEfficiency-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimeStretchEfficiency"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum TimeStretchMultiChannelMode {
    #[default]
    TimeStretchMultiChannelMode_IndependentChannels = 0,
    TimeStretchMultiChannelMode_CombinedChannels = 1,
}

pub static TIMESTRETCHMULTICHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchMultiChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(TIMESTRETCHMULTICHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for TimeStretchMultiChannelMode {
    fn type_info(&self) -> &'static TypeInfo {
        TIMESTRETCHMULTICHANNELMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static TIMESTRETCHMULTICHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "TimeStretchMultiChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("TimeStretchMultiChannelMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SamplerNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub amplitude: f32,
    pub delay: f32,
    pub offset: f32,
    pub pitch: f32,
    pub wave: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
}

pub trait SamplerNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn amplitude(&self) -> &f32;
    fn amplitude_mut(&mut self) -> &mut f32;
    fn delay(&self) -> &f32;
    fn delay_mut(&mut self) -> &mut f32;
    fn offset(&self) -> &f32;
    fn offset_mut(&mut self) -> &mut f32;
    fn pitch(&self) -> &f32;
    fn pitch_mut(&mut self) -> &mut f32;
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
}

impl SamplerNodeConfigDataTrait for SamplerNodeConfigData {
    fn amplitude(&self) -> &f32 {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut f32 {
        &mut self.amplitude
    }
    fn delay(&self) -> &f32 {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut f32 {
        &mut self.delay
    }
    fn offset(&self) -> &f32 {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut f32 {
        &mut self.offset
    }
    fn pitch(&self) -> &f32 {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut f32 {
        &mut self.pitch
    }
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.wave
    }
}

impl AudioGraphNodeConfigDataTrait for SamplerNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for SamplerNodeConfigData {
}

pub static SAMPLERNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SamplerNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SamplerNodeConfigData, amplitude),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SamplerNodeConfigData, delay),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SamplerNodeConfigData, offset),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SamplerNodeConfigData, pitch),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(SamplerNodeConfigData, wave),
            },
        ],
    }),
    array_type: Some(SAMPLERNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SamplerNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAMPLERNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SamplerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub external_wave: AudioGraphNodePort,
    pub variation: AudioGraphNodePort,
    pub selection: AudioGraphNodePort,
    pub offset: AudioGraphNodePort,
    pub delay: AudioGraphNodePort,
    pub pitch: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub enable_step: AudioGraphNodePort,
    pub shuffle_segments: AudioGraphNodePort,
    pub enable_subtitles: AudioGraphNodePort,
    pub buffer: AudioGraphNodePort,
    pub trigger: AudioGraphNodePort,
    pub release: AudioGraphNodePort,
    pub step: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub finished: AudioGraphNodePort,
    pub buffered: AudioGraphNodePort,
    pub position: AudioGraphNodePort,
    pub wave: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
    pub looping: bool,
    pub instant_release: bool,
    pub offset_mode: SamplerOffsetMode,
    pub lead_out: u8,
    pub plugins: Vec<SamplerPlugins>,
    pub pitch_source: Option<Arc<Mutex<dyn OutputNodeDataTrait>>>,
    pub version: SamplerNodeVersion,
    pub sampler_node_debug: Option<Arc<Mutex<dyn SamplerNodeDebugDataTrait>>>,
    pub position_mode: SamplerPositionMode,
}

pub trait SamplerNodeDataTrait: AudioGraphNodeDataTrait {
    fn external_wave(&self) -> &AudioGraphNodePort;
    fn external_wave_mut(&mut self) -> &mut AudioGraphNodePort;
    fn variation(&self) -> &AudioGraphNodePort;
    fn variation_mut(&mut self) -> &mut AudioGraphNodePort;
    fn selection(&self) -> &AudioGraphNodePort;
    fn selection_mut(&mut self) -> &mut AudioGraphNodePort;
    fn offset(&self) -> &AudioGraphNodePort;
    fn offset_mut(&mut self) -> &mut AudioGraphNodePort;
    fn delay(&self) -> &AudioGraphNodePort;
    fn delay_mut(&mut self) -> &mut AudioGraphNodePort;
    fn pitch(&self) -> &AudioGraphNodePort;
    fn pitch_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn enable_step(&self) -> &AudioGraphNodePort;
    fn enable_step_mut(&mut self) -> &mut AudioGraphNodePort;
    fn shuffle_segments(&self) -> &AudioGraphNodePort;
    fn shuffle_segments_mut(&mut self) -> &mut AudioGraphNodePort;
    fn enable_subtitles(&self) -> &AudioGraphNodePort;
    fn enable_subtitles_mut(&mut self) -> &mut AudioGraphNodePort;
    fn buffer(&self) -> &AudioGraphNodePort;
    fn buffer_mut(&mut self) -> &mut AudioGraphNodePort;
    fn trigger(&self) -> &AudioGraphNodePort;
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release(&self) -> &AudioGraphNodePort;
    fn release_mut(&mut self) -> &mut AudioGraphNodePort;
    fn step(&self) -> &AudioGraphNodePort;
    fn step_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn finished(&self) -> &AudioGraphNodePort;
    fn finished_mut(&mut self) -> &mut AudioGraphNodePort;
    fn buffered(&self) -> &AudioGraphNodePort;
    fn buffered_mut(&mut self) -> &mut AudioGraphNodePort;
    fn position(&self) -> &AudioGraphNodePort;
    fn position_mut(&mut self) -> &mut AudioGraphNodePort;
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn looping(&self) -> &bool;
    fn looping_mut(&mut self) -> &mut bool;
    fn instant_release(&self) -> &bool;
    fn instant_release_mut(&mut self) -> &mut bool;
    fn offset_mode(&self) -> &SamplerOffsetMode;
    fn offset_mode_mut(&mut self) -> &mut SamplerOffsetMode;
    fn lead_out(&self) -> &u8;
    fn lead_out_mut(&mut self) -> &mut u8;
    fn plugins(&self) -> &Vec<SamplerPlugins>;
    fn plugins_mut(&mut self) -> &mut Vec<SamplerPlugins>;
    fn pitch_source(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn pitch_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn version(&self) -> &SamplerNodeVersion;
    fn version_mut(&mut self) -> &mut SamplerNodeVersion;
    fn sampler_node_debug(&self) -> &Option<Arc<Mutex<dyn SamplerNodeDebugDataTrait>>>;
    fn sampler_node_debug_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SamplerNodeDebugDataTrait>>>;
    fn position_mode(&self) -> &SamplerPositionMode;
    fn position_mode_mut(&mut self) -> &mut SamplerPositionMode;
}

impl SamplerNodeDataTrait for SamplerNodeData {
    fn external_wave(&self) -> &AudioGraphNodePort {
        &self.external_wave
    }
    fn external_wave_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.external_wave
    }
    fn variation(&self) -> &AudioGraphNodePort {
        &self.variation
    }
    fn variation_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.variation
    }
    fn selection(&self) -> &AudioGraphNodePort {
        &self.selection
    }
    fn selection_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.selection
    }
    fn offset(&self) -> &AudioGraphNodePort {
        &self.offset
    }
    fn offset_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.offset
    }
    fn delay(&self) -> &AudioGraphNodePort {
        &self.delay
    }
    fn delay_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay
    }
    fn pitch(&self) -> &AudioGraphNodePort {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pitch
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn enable_step(&self) -> &AudioGraphNodePort {
        &self.enable_step
    }
    fn enable_step_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.enable_step
    }
    fn shuffle_segments(&self) -> &AudioGraphNodePort {
        &self.shuffle_segments
    }
    fn shuffle_segments_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.shuffle_segments
    }
    fn enable_subtitles(&self) -> &AudioGraphNodePort {
        &self.enable_subtitles
    }
    fn enable_subtitles_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.enable_subtitles
    }
    fn buffer(&self) -> &AudioGraphNodePort {
        &self.buffer
    }
    fn buffer_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.buffer
    }
    fn trigger(&self) -> &AudioGraphNodePort {
        &self.trigger
    }
    fn trigger_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.trigger
    }
    fn release(&self) -> &AudioGraphNodePort {
        &self.release
    }
    fn release_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release
    }
    fn step(&self) -> &AudioGraphNodePort {
        &self.step
    }
    fn step_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.step
    }
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn finished(&self) -> &AudioGraphNodePort {
        &self.finished
    }
    fn finished_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.finished
    }
    fn buffered(&self) -> &AudioGraphNodePort {
        &self.buffered
    }
    fn buffered_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.buffered
    }
    fn position(&self) -> &AudioGraphNodePort {
        &self.position
    }
    fn position_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position
    }
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.wave
    }
    fn looping(&self) -> &bool {
        &self.looping
    }
    fn looping_mut(&mut self) -> &mut bool {
        &mut self.looping
    }
    fn instant_release(&self) -> &bool {
        &self.instant_release
    }
    fn instant_release_mut(&mut self) -> &mut bool {
        &mut self.instant_release
    }
    fn offset_mode(&self) -> &SamplerOffsetMode {
        &self.offset_mode
    }
    fn offset_mode_mut(&mut self) -> &mut SamplerOffsetMode {
        &mut self.offset_mode
    }
    fn lead_out(&self) -> &u8 {
        &self.lead_out
    }
    fn lead_out_mut(&mut self) -> &mut u8 {
        &mut self.lead_out
    }
    fn plugins(&self) -> &Vec<SamplerPlugins> {
        &self.plugins
    }
    fn plugins_mut(&mut self) -> &mut Vec<SamplerPlugins> {
        &mut self.plugins
    }
    fn pitch_source(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &self.pitch_source
    }
    fn pitch_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &mut self.pitch_source
    }
    fn version(&self) -> &SamplerNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut SamplerNodeVersion {
        &mut self.version
    }
    fn sampler_node_debug(&self) -> &Option<Arc<Mutex<dyn SamplerNodeDebugDataTrait>>> {
        &self.sampler_node_debug
    }
    fn sampler_node_debug_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SamplerNodeDebugDataTrait>>> {
        &mut self.sampler_node_debug
    }
    fn position_mode(&self) -> &SamplerPositionMode {
        &self.position_mode
    }
    fn position_mode_mut(&mut self) -> &mut SamplerPositionMode {
        &mut self.position_mode
    }
}

impl AudioGraphNodeDataTrait for SamplerNodeData {
}

impl super::core::DataContainerTrait for SamplerNodeData {
}

pub static SAMPLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SamplerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ExternalWave",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, external_wave),
            },
            FieldInfoData {
                name: "Variation",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, variation),
            },
            FieldInfoData {
                name: "Selection",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, selection),
            },
            FieldInfoData {
                name: "Offset",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, offset),
            },
            FieldInfoData {
                name: "Delay",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, delay),
            },
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, pitch),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, amplitude),
            },
            FieldInfoData {
                name: "EnableStep",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, enable_step),
            },
            FieldInfoData {
                name: "ShuffleSegments",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, shuffle_segments),
            },
            FieldInfoData {
                name: "EnableSubtitles",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, enable_subtitles),
            },
            FieldInfoData {
                name: "Buffer",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, buffer),
            },
            FieldInfoData {
                name: "Trigger",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, trigger),
            },
            FieldInfoData {
                name: "Release",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, release),
            },
            FieldInfoData {
                name: "Step",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, step),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, output),
            },
            FieldInfoData {
                name: "Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, finished),
            },
            FieldInfoData {
                name: "Buffered",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, buffered),
            },
            FieldInfoData {
                name: "Position",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SamplerNodeData, position),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(SamplerNodeData, wave),
            },
            FieldInfoData {
                name: "Looping",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeData, looping),
            },
            FieldInfoData {
                name: "InstantRelease",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeData, instant_release),
            },
            FieldInfoData {
                name: "OffsetMode",
                flags: MemberInfoFlags::new(0),
                field_type: "SamplerOffsetMode",
                rust_offset: offset_of!(SamplerNodeData, offset_mode),
            },
            FieldInfoData {
                name: "LeadOut",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint8",
                rust_offset: offset_of!(SamplerNodeData, lead_out),
            },
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: "SamplerPlugins-Array",
                rust_offset: offset_of!(SamplerNodeData, plugins),
            },
            FieldInfoData {
                name: "PitchSource",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputNodeData",
                rust_offset: offset_of!(SamplerNodeData, pitch_source),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "SamplerNodeVersion",
                rust_offset: offset_of!(SamplerNodeData, version),
            },
            FieldInfoData {
                name: "SamplerNodeDebug",
                flags: MemberInfoFlags::new(0),
                field_type: "SamplerNodeDebugData",
                rust_offset: offset_of!(SamplerNodeData, sampler_node_debug),
            },
            FieldInfoData {
                name: "PositionMode",
                flags: MemberInfoFlags::new(0),
                field_type: "SamplerPositionMode",
                rust_offset: offset_of!(SamplerNodeData, position_mode),
            },
        ],
    }),
    array_type: Some(SAMPLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SamplerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAMPLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SamplerNodeDebugData {
    pub _glacier_base: super::core::DataContainer,
    pub only_debug_if_playing: bool,
    pub enable_debug: bool,
    pub debug_input_connections: bool,
    pub debug_output_connections: bool,
    pub debug_text_x_pos: i32,
    pub debug_text_y_pos: i32,
    pub event_display_time: f32,
    pub sampler_debug_info_color: super::core::Vec3,
    pub properties_debug_info_color: super::core::Vec3,
    pub events_debug_info_color: super::core::Vec3,
    pub external_wave_debug_info_color: super::core::Vec3,
    pub selection_debug_info_color: super::core::Vec3,
    pub mute_sampler: bool,
}

pub trait SamplerNodeDebugDataTrait: super::core::DataContainerTrait {
    fn only_debug_if_playing(&self) -> &bool;
    fn only_debug_if_playing_mut(&mut self) -> &mut bool;
    fn enable_debug(&self) -> &bool;
    fn enable_debug_mut(&mut self) -> &mut bool;
    fn debug_input_connections(&self) -> &bool;
    fn debug_input_connections_mut(&mut self) -> &mut bool;
    fn debug_output_connections(&self) -> &bool;
    fn debug_output_connections_mut(&mut self) -> &mut bool;
    fn debug_text_x_pos(&self) -> &i32;
    fn debug_text_x_pos_mut(&mut self) -> &mut i32;
    fn debug_text_y_pos(&self) -> &i32;
    fn debug_text_y_pos_mut(&mut self) -> &mut i32;
    fn event_display_time(&self) -> &f32;
    fn event_display_time_mut(&mut self) -> &mut f32;
    fn sampler_debug_info_color(&self) -> &super::core::Vec3;
    fn sampler_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn properties_debug_info_color(&self) -> &super::core::Vec3;
    fn properties_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn events_debug_info_color(&self) -> &super::core::Vec3;
    fn events_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn external_wave_debug_info_color(&self) -> &super::core::Vec3;
    fn external_wave_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn selection_debug_info_color(&self) -> &super::core::Vec3;
    fn selection_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn mute_sampler(&self) -> &bool;
    fn mute_sampler_mut(&mut self) -> &mut bool;
}

impl SamplerNodeDebugDataTrait for SamplerNodeDebugData {
    fn only_debug_if_playing(&self) -> &bool {
        &self.only_debug_if_playing
    }
    fn only_debug_if_playing_mut(&mut self) -> &mut bool {
        &mut self.only_debug_if_playing
    }
    fn enable_debug(&self) -> &bool {
        &self.enable_debug
    }
    fn enable_debug_mut(&mut self) -> &mut bool {
        &mut self.enable_debug
    }
    fn debug_input_connections(&self) -> &bool {
        &self.debug_input_connections
    }
    fn debug_input_connections_mut(&mut self) -> &mut bool {
        &mut self.debug_input_connections
    }
    fn debug_output_connections(&self) -> &bool {
        &self.debug_output_connections
    }
    fn debug_output_connections_mut(&mut self) -> &mut bool {
        &mut self.debug_output_connections
    }
    fn debug_text_x_pos(&self) -> &i32 {
        &self.debug_text_x_pos
    }
    fn debug_text_x_pos_mut(&mut self) -> &mut i32 {
        &mut self.debug_text_x_pos
    }
    fn debug_text_y_pos(&self) -> &i32 {
        &self.debug_text_y_pos
    }
    fn debug_text_y_pos_mut(&mut self) -> &mut i32 {
        &mut self.debug_text_y_pos
    }
    fn event_display_time(&self) -> &f32 {
        &self.event_display_time
    }
    fn event_display_time_mut(&mut self) -> &mut f32 {
        &mut self.event_display_time
    }
    fn sampler_debug_info_color(&self) -> &super::core::Vec3 {
        &self.sampler_debug_info_color
    }
    fn sampler_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.sampler_debug_info_color
    }
    fn properties_debug_info_color(&self) -> &super::core::Vec3 {
        &self.properties_debug_info_color
    }
    fn properties_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.properties_debug_info_color
    }
    fn events_debug_info_color(&self) -> &super::core::Vec3 {
        &self.events_debug_info_color
    }
    fn events_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.events_debug_info_color
    }
    fn external_wave_debug_info_color(&self) -> &super::core::Vec3 {
        &self.external_wave_debug_info_color
    }
    fn external_wave_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.external_wave_debug_info_color
    }
    fn selection_debug_info_color(&self) -> &super::core::Vec3 {
        &self.selection_debug_info_color
    }
    fn selection_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.selection_debug_info_color
    }
    fn mute_sampler(&self) -> &bool {
        &self.mute_sampler
    }
    fn mute_sampler_mut(&mut self) -> &mut bool {
        &mut self.mute_sampler
    }
}

impl super::core::DataContainerTrait for SamplerNodeDebugData {
}

pub static SAMPLERNODEDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeDebugData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SamplerNodeDebugData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "OnlyDebugIfPlaying",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeDebugData, only_debug_if_playing),
            },
            FieldInfoData {
                name: "EnableDebug",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeDebugData, enable_debug),
            },
            FieldInfoData {
                name: "DebugInputConnections",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeDebugData, debug_input_connections),
            },
            FieldInfoData {
                name: "DebugOutputConnections",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeDebugData, debug_output_connections),
            },
            FieldInfoData {
                name: "DebugTextXPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SamplerNodeDebugData, debug_text_x_pos),
            },
            FieldInfoData {
                name: "DebugTextYPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(SamplerNodeDebugData, debug_text_y_pos),
            },
            FieldInfoData {
                name: "EventDisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(SamplerNodeDebugData, event_display_time),
            },
            FieldInfoData {
                name: "SamplerDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SamplerNodeDebugData, sampler_debug_info_color),
            },
            FieldInfoData {
                name: "PropertiesDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SamplerNodeDebugData, properties_debug_info_color),
            },
            FieldInfoData {
                name: "EventsDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SamplerNodeDebugData, events_debug_info_color),
            },
            FieldInfoData {
                name: "ExternalWaveDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SamplerNodeDebugData, external_wave_debug_info_color),
            },
            FieldInfoData {
                name: "SelectionDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(SamplerNodeDebugData, selection_debug_info_color),
            },
            FieldInfoData {
                name: "MuteSampler",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(SamplerNodeDebugData, mute_sampler),
            },
        ],
    }),
    array_type: Some(SAMPLERNODEDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for SamplerNodeDebugData {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERNODEDEBUGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SAMPLERNODEDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeDebugData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SamplerPositionMode {
    #[default]
    SamplerPositionMode_Normal = 0,
    SamplerPositionMode_Wrap = 1,
    SamplerPositionMode_Countdown = 2,
    SamplerPositionMode_Relative = 3,
}

pub static SAMPLERPOSITIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPositionMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLERPOSITIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerPositionMode {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERPOSITIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SAMPLERPOSITIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPositionMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerPositionMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SamplerOffsetMode {
    #[default]
    SamplerOffsetMode_Absolute = 0,
    SamplerOffsetMode_Relative = 1,
    SamplerOffsetMode_RelativeMod = 2,
}

pub static SAMPLEROFFSETMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerOffsetMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLEROFFSETMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerOffsetMode {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLEROFFSETMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SAMPLEROFFSETMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerOffsetMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerOffsetMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SamplerLeadOut {
    #[default]
    SamplerLeadOut_None = 0,
    SamplerLeadOut_Normal = 1,
    SamplerLeadOut_Relative = 2,
}

pub static SAMPLERLEADOUT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerLeadOut",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLERLEADOUT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerLeadOut {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERLEADOUT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SAMPLERLEADOUT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerLeadOut-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerLeadOut"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SamplerPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub resample: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
}

pub trait SamplerPluginsTrait: TypeObject {
    fn snd_player(&self) -> &SoundGraphPluginRef;
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn resample(&self) -> &SoundGraphPluginRef;
    fn resample_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn pause(&self) -> &SoundGraphPluginRef;
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain(&self) -> &SoundGraphPluginRef;
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl SamplerPluginsTrait for SamplerPlugins {
    fn snd_player(&self) -> &SoundGraphPluginRef {
        &self.snd_player
    }
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.snd_player
    }
    fn resample(&self) -> &SoundGraphPluginRef {
        &self.resample
    }
    fn resample_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.resample
    }
    fn pause(&self) -> &SoundGraphPluginRef {
        &self.pause
    }
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pause
    }
    fn gain(&self) -> &SoundGraphPluginRef {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain
    }
}

pub static SAMPLERPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SamplerPlugins as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(SamplerPlugins, snd_player),
            },
            FieldInfoData {
                name: "Resample",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(SamplerPlugins, resample),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(SamplerPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(SamplerPlugins, gain),
            },
        ],
    }),
    array_type: Some(SAMPLERPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerPlugins {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERPLUGINS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SAMPLERPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerPlugins"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum SamplerNodeVersion {
    #[default]
    SamplerNodeVersion_2010_2 = 0,
    SamplerNodeVersion_2013_2 = 1,
    SamplerNodeVersion_2016_1 = 2,
}

pub static SAMPLERNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(SAMPLERNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for SamplerNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        SAMPLERNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static SAMPLERNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SamplerNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SamplerNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RouteNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub routes: Vec<Option<Arc<Mutex<dyn RouteEntryTrait>>>>,
}

pub trait RouteNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn routes(&self) -> &Vec<Option<Arc<Mutex<dyn RouteEntryTrait>>>>;
    fn routes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RouteEntryTrait>>>>;
}

impl RouteNodeDataTrait for RouteNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn routes(&self) -> &Vec<Option<Arc<Mutex<dyn RouteEntryTrait>>>> {
        &self.routes
    }
    fn routes_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn RouteEntryTrait>>>> {
        &mut self.routes
    }
}

impl AudioGraphNodeDataTrait for RouteNodeData {
}

impl super::core::DataContainerTrait for RouteNodeData {
}

pub static ROUTENODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RouteNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RouteNodeData, r#in),
            },
            FieldInfoData {
                name: "Routes",
                flags: MemberInfoFlags::new(144),
                field_type: "RouteEntry-Array",
                rust_offset: offset_of!(RouteNodeData, routes),
            },
        ],
    }),
    array_type: Some(ROUTENODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RouteNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        ROUTENODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ROUTENODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RouteNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct RouteEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub output: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait RouteEntryTrait: AudioGraphNodePortGroupTrait {
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl RouteEntryTrait for RouteEntry {
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodePortGroupTrait for RouteEntry {
}

impl super::core::DataContainerTrait for RouteEntry {
}

pub static ROUTEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<RouteEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RouteEntry, output),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(RouteEntry, amplitude),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(RouteEntry, plugin),
            },
        ],
    }),
    array_type: Some(ROUTEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for RouteEntry {
    fn type_info(&self) -> &'static TypeInfo {
        ROUTEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ROUTEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RouteEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum RouteChannel {
    #[default]
    RouteChannel_0 = 0,
    RouteChannel_1 = 1,
    RouteChannel_2 = 2,
    RouteChannel_3 = 3,
    RouteChannel_4 = 4,
    RouteChannel_5 = 5,
    RouteChannel_6 = 6,
    RouteChannel_7 = 7,
    RouteChannel_8 = 8,
    RouteChannel_9 = 9,
    RouteChannel_10 = 10,
    RouteChannel_11 = 11,
    RouteChannel_12 = 12,
    RouteChannel_13 = 13,
    RouteChannel_14 = 14,
    RouteChannel_15 = 15,
    RouteChannel_16 = 16,
    RouteChannel_17 = 17,
    RouteChannel_18 = 18,
    RouteChannel_19 = 19,
    RouteChannel_21 = 20,
    RouteChannel_22 = 21,
    RouteChannel_23 = 22,
    RouteChannel_24 = 23,
    RouteChannel_25 = 24,
    RouteChannel_26 = 25,
    RouteChannel_27 = 26,
    RouteChannel_28 = 27,
    RouteChannel_29 = 28,
    RouteChannel_30 = 29,
    RouteChannel_31 = 30,
    RouteChannel_32 = 31,
    RouteChannel_33 = 32,
    RouteChannel_34 = 33,
    RouteChannel_35 = 34,
    RouteChannel_36 = 35,
    RouteChannel_37 = 36,
    RouteChannel_38 = 37,
    RouteChannel_39 = 38,
    RouteChannel_40 = 39,
    RouteChannel_41 = 40,
    RouteChannel_42 = 41,
    RouteChannel_43 = 42,
    RouteChannel_44 = 43,
    RouteChannel_45 = 44,
    RouteChannel_46 = 45,
    RouteChannel_47 = 46,
    RouteChannel_48 = 47,
    RouteChannel_49 = 48,
    RouteChannel_50 = 49,
    RouteChannel_51 = 50,
    RouteChannel_52 = 51,
    RouteChannel_53 = 52,
    RouteChannel_54 = 53,
    RouteChannel_55 = 54,
    RouteChannel_56 = 55,
    RouteChannel_57 = 56,
    RouteChannel_58 = 57,
    RouteChannel_59 = 58,
    RouteChannel_60 = 59,
    RouteChannel_61 = 60,
    RouteChannel_62 = 61,
    RouteChannel_63 = 62,
}

pub static ROUTECHANNEL_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteChannel",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(ROUTECHANNEL_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for RouteChannel {
    fn type_info(&self) -> &'static TypeInfo {
        ROUTECHANNEL_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static ROUTECHANNEL_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "RouteChannel-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("RouteChannel"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IrReverbControllerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub reverb0: AudioGraphNodePort,
    pub amplitude0: AudioGraphNodePort,
    pub reverb1: AudioGraphNodePort,
    pub amplitude1: AudioGraphNodePort,
    pub normalize_gain: bool,
}

pub trait IrReverbControllerNodeDataTrait: AudioGraphNodeDataTrait {
    fn reverb0(&self) -> &AudioGraphNodePort;
    fn reverb0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude0(&self) -> &AudioGraphNodePort;
    fn amplitude0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb1(&self) -> &AudioGraphNodePort;
    fn reverb1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude1(&self) -> &AudioGraphNodePort;
    fn amplitude1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn normalize_gain(&self) -> &bool;
    fn normalize_gain_mut(&mut self) -> &mut bool;
}

impl IrReverbControllerNodeDataTrait for IrReverbControllerNodeData {
    fn reverb0(&self) -> &AudioGraphNodePort {
        &self.reverb0
    }
    fn reverb0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb0
    }
    fn amplitude0(&self) -> &AudioGraphNodePort {
        &self.amplitude0
    }
    fn amplitude0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude0
    }
    fn reverb1(&self) -> &AudioGraphNodePort {
        &self.reverb1
    }
    fn reverb1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb1
    }
    fn amplitude1(&self) -> &AudioGraphNodePort {
        &self.amplitude1
    }
    fn amplitude1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude1
    }
    fn normalize_gain(&self) -> &bool {
        &self.normalize_gain
    }
    fn normalize_gain_mut(&mut self) -> &mut bool {
        &mut self.normalize_gain
    }
}

impl AudioGraphNodeDataTrait for IrReverbControllerNodeData {
}

impl super::core::DataContainerTrait for IrReverbControllerNodeData {
}

pub static IRREVERBCONTROLLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbControllerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IrReverbControllerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Reverb0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbControllerNodeData, reverb0),
            },
            FieldInfoData {
                name: "Amplitude0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbControllerNodeData, amplitude0),
            },
            FieldInfoData {
                name: "Reverb1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbControllerNodeData, reverb1),
            },
            FieldInfoData {
                name: "Amplitude1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbControllerNodeData, amplitude1),
            },
            FieldInfoData {
                name: "NormalizeGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(IrReverbControllerNodeData, normalize_gain),
            },
        ],
    }),
    array_type: Some(IRREVERBCONTROLLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IrReverbControllerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        IRREVERBCONTROLLERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IRREVERBCONTROLLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbControllerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbControllerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct IrReverbNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub reverb0: AudioGraphNodePort,
    pub amplitude0: AudioGraphNodePort,
    pub envelope_type0: AudioGraphNodePort,
    pub envelope_start_level0: AudioGraphNodePort,
    pub envelope_length0: AudioGraphNodePort,
    pub reverb1: AudioGraphNodePort,
    pub amplitude1: AudioGraphNodePort,
    pub envelope_type1: AudioGraphNodePort,
    pub envelope_start_level1: AudioGraphNodePort,
    pub envelope_length1: AudioGraphNodePort,
    pub max_reverb_length: f32,
    pub reverb_plugin: SoundGraphPluginRef,
}

pub trait IrReverbNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb0(&self) -> &AudioGraphNodePort;
    fn reverb0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude0(&self) -> &AudioGraphNodePort;
    fn amplitude0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn envelope_type0(&self) -> &AudioGraphNodePort;
    fn envelope_type0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn envelope_start_level0(&self) -> &AudioGraphNodePort;
    fn envelope_start_level0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn envelope_length0(&self) -> &AudioGraphNodePort;
    fn envelope_length0_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb1(&self) -> &AudioGraphNodePort;
    fn reverb1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude1(&self) -> &AudioGraphNodePort;
    fn amplitude1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn envelope_type1(&self) -> &AudioGraphNodePort;
    fn envelope_type1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn envelope_start_level1(&self) -> &AudioGraphNodePort;
    fn envelope_start_level1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn envelope_length1(&self) -> &AudioGraphNodePort;
    fn envelope_length1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_reverb_length(&self) -> &f32;
    fn max_reverb_length_mut(&mut self) -> &mut f32;
    fn reverb_plugin(&self) -> &SoundGraphPluginRef;
    fn reverb_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl IrReverbNodeDataTrait for IrReverbNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn reverb0(&self) -> &AudioGraphNodePort {
        &self.reverb0
    }
    fn reverb0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb0
    }
    fn amplitude0(&self) -> &AudioGraphNodePort {
        &self.amplitude0
    }
    fn amplitude0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude0
    }
    fn envelope_type0(&self) -> &AudioGraphNodePort {
        &self.envelope_type0
    }
    fn envelope_type0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.envelope_type0
    }
    fn envelope_start_level0(&self) -> &AudioGraphNodePort {
        &self.envelope_start_level0
    }
    fn envelope_start_level0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.envelope_start_level0
    }
    fn envelope_length0(&self) -> &AudioGraphNodePort {
        &self.envelope_length0
    }
    fn envelope_length0_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.envelope_length0
    }
    fn reverb1(&self) -> &AudioGraphNodePort {
        &self.reverb1
    }
    fn reverb1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb1
    }
    fn amplitude1(&self) -> &AudioGraphNodePort {
        &self.amplitude1
    }
    fn amplitude1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude1
    }
    fn envelope_type1(&self) -> &AudioGraphNodePort {
        &self.envelope_type1
    }
    fn envelope_type1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.envelope_type1
    }
    fn envelope_start_level1(&self) -> &AudioGraphNodePort {
        &self.envelope_start_level1
    }
    fn envelope_start_level1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.envelope_start_level1
    }
    fn envelope_length1(&self) -> &AudioGraphNodePort {
        &self.envelope_length1
    }
    fn envelope_length1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.envelope_length1
    }
    fn max_reverb_length(&self) -> &f32 {
        &self.max_reverb_length
    }
    fn max_reverb_length_mut(&mut self) -> &mut f32 {
        &mut self.max_reverb_length
    }
    fn reverb_plugin(&self) -> &SoundGraphPluginRef {
        &self.reverb_plugin
    }
    fn reverb_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.reverb_plugin
    }
}

impl AudioGraphNodeDataTrait for IrReverbNodeData {
}

impl super::core::DataContainerTrait for IrReverbNodeData {
}

pub static IRREVERBNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<IrReverbNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, out),
            },
            FieldInfoData {
                name: "Reverb0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, reverb0),
            },
            FieldInfoData {
                name: "Amplitude0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, amplitude0),
            },
            FieldInfoData {
                name: "EnvelopeType0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, envelope_type0),
            },
            FieldInfoData {
                name: "EnvelopeStartLevel0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, envelope_start_level0),
            },
            FieldInfoData {
                name: "EnvelopeLength0",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, envelope_length0),
            },
            FieldInfoData {
                name: "Reverb1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, reverb1),
            },
            FieldInfoData {
                name: "Amplitude1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, amplitude1),
            },
            FieldInfoData {
                name: "EnvelopeType1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, envelope_type1),
            },
            FieldInfoData {
                name: "EnvelopeStartLevel1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, envelope_start_level1),
            },
            FieldInfoData {
                name: "EnvelopeLength1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(IrReverbNodeData, envelope_length1),
            },
            FieldInfoData {
                name: "MaxReverbLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(IrReverbNodeData, max_reverb_length),
            },
            FieldInfoData {
                name: "ReverbPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(IrReverbNodeData, reverb_plugin),
            },
        ],
    }),
    array_type: Some(IRREVERBNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for IrReverbNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        IRREVERBNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static IRREVERBNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "IrReverbNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("IrReverbNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PlatformFoldDownNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait PlatformFoldDownNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl PlatformFoldDownNodeDataTrait for PlatformFoldDownNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for PlatformFoldDownNodeData {
}

impl super::core::DataContainerTrait for PlatformFoldDownNodeData {
}

pub static PLATFORMFOLDDOWNNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformFoldDownNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PlatformFoldDownNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PlatformFoldDownNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PlatformFoldDownNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(PlatformFoldDownNodeData, plugin),
            },
        ],
    }),
    array_type: Some(PLATFORMFOLDDOWNNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PlatformFoldDownNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PLATFORMFOLDDOWNNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PLATFORMFOLDDOWNNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PlatformFoldDownNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PlatformFoldDownNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FoldDownMode {
    #[default]
    FoldDownMode_None = 0,
    FoldDownMode_PC_5_1 = 1,
    FoldDownMode_PC_Stereo = 2,
    FoldDownMode_PC_Mono = 3,
    FoldDownMode_PS4_5_1 = 4,
    FoldDownMode_PS4_Stereo = 5,
    FoldDownMode_XB1_5_1 = 6,
    FoldDownMode_XB1_Stereo = 7,
}

pub static FOLDDOWNMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FoldDownMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FOLDDOWNMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FoldDownMode {
    fn type_info(&self) -> &'static TypeInfo {
        FOLDDOWNMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FOLDDOWNMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FoldDownMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FoldDownMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub distance: AudioGraphNodePort,
    pub velocity: AudioGraphNodePort,
    pub relative_velocity: AudioGraphNodePort,
    pub azimuth: AudioGraphNodePort,
    pub elevation_angle: AudioGraphNodePort,
    pub entries: Vec<Option<Arc<Mutex<dyn PhysicsEntryTrait>>>>,
}

pub trait PhysicsNodeDataTrait: AudioGraphNodeDataTrait {
    fn distance(&self) -> &AudioGraphNodePort;
    fn distance_mut(&mut self) -> &mut AudioGraphNodePort;
    fn velocity(&self) -> &AudioGraphNodePort;
    fn velocity_mut(&mut self) -> &mut AudioGraphNodePort;
    fn relative_velocity(&self) -> &AudioGraphNodePort;
    fn relative_velocity_mut(&mut self) -> &mut AudioGraphNodePort;
    fn azimuth(&self) -> &AudioGraphNodePort;
    fn azimuth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn elevation_angle(&self) -> &AudioGraphNodePort;
    fn elevation_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn PhysicsEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn PhysicsEntryTrait>>>>;
}

impl PhysicsNodeDataTrait for PhysicsNodeData {
    fn distance(&self) -> &AudioGraphNodePort {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.distance
    }
    fn velocity(&self) -> &AudioGraphNodePort {
        &self.velocity
    }
    fn velocity_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.velocity
    }
    fn relative_velocity(&self) -> &AudioGraphNodePort {
        &self.relative_velocity
    }
    fn relative_velocity_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.relative_velocity
    }
    fn azimuth(&self) -> &AudioGraphNodePort {
        &self.azimuth
    }
    fn azimuth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.azimuth
    }
    fn elevation_angle(&self) -> &AudioGraphNodePort {
        &self.elevation_angle
    }
    fn elevation_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.elevation_angle
    }
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn PhysicsEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn PhysicsEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for PhysicsNodeData {
}

impl super::core::DataContainerTrait for PhysicsNodeData {
}

pub static PHYSICSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsNodeData, distance),
            },
            FieldInfoData {
                name: "Velocity",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsNodeData, velocity),
            },
            FieldInfoData {
                name: "RelativeVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsNodeData, relative_velocity),
            },
            FieldInfoData {
                name: "Azimuth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsNodeData, azimuth),
            },
            FieldInfoData {
                name: "ElevationAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsNodeData, elevation_angle),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "PhysicsEntry-Array",
                rust_offset: offset_of!(PhysicsNodeData, entries),
            },
        ],
    }),
    array_type: Some(PHYSICSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PhysicsNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct Pan2dNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub output_channel_count: Pan2dOutputChannelCount,
    pub pan_angle: AudioGraphNodePort,
    pub pan_distance: AudioGraphNodePort,
    pub pan_size: AudioGraphNodePort,
    pub pan_twist: AudioGraphNodePort,
    pub center_amplitude: AudioGraphNodePort,
    pub main_amplitude: AudioGraphNodePort,
    pub lfe_amplitude: AudioGraphNodePort,
    pub version: Pan2dNodeVersion,
}

pub trait Pan2dNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn output_channel_count(&self) -> &Pan2dOutputChannelCount;
    fn output_channel_count_mut(&mut self) -> &mut Pan2dOutputChannelCount;
    fn pan_angle(&self) -> &AudioGraphNodePort;
    fn pan_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn pan_distance(&self) -> &AudioGraphNodePort;
    fn pan_distance_mut(&mut self) -> &mut AudioGraphNodePort;
    fn pan_size(&self) -> &AudioGraphNodePort;
    fn pan_size_mut(&mut self) -> &mut AudioGraphNodePort;
    fn pan_twist(&self) -> &AudioGraphNodePort;
    fn pan_twist_mut(&mut self) -> &mut AudioGraphNodePort;
    fn center_amplitude(&self) -> &AudioGraphNodePort;
    fn center_amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn main_amplitude(&self) -> &AudioGraphNodePort;
    fn main_amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn lfe_amplitude(&self) -> &AudioGraphNodePort;
    fn lfe_amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn version(&self) -> &Pan2dNodeVersion;
    fn version_mut(&mut self) -> &mut Pan2dNodeVersion;
}

impl Pan2dNodeDataTrait for Pan2dNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn output_channel_count(&self) -> &Pan2dOutputChannelCount {
        &self.output_channel_count
    }
    fn output_channel_count_mut(&mut self) -> &mut Pan2dOutputChannelCount {
        &mut self.output_channel_count
    }
    fn pan_angle(&self) -> &AudioGraphNodePort {
        &self.pan_angle
    }
    fn pan_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pan_angle
    }
    fn pan_distance(&self) -> &AudioGraphNodePort {
        &self.pan_distance
    }
    fn pan_distance_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pan_distance
    }
    fn pan_size(&self) -> &AudioGraphNodePort {
        &self.pan_size
    }
    fn pan_size_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pan_size
    }
    fn pan_twist(&self) -> &AudioGraphNodePort {
        &self.pan_twist
    }
    fn pan_twist_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pan_twist
    }
    fn center_amplitude(&self) -> &AudioGraphNodePort {
        &self.center_amplitude
    }
    fn center_amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.center_amplitude
    }
    fn main_amplitude(&self) -> &AudioGraphNodePort {
        &self.main_amplitude
    }
    fn main_amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.main_amplitude
    }
    fn lfe_amplitude(&self) -> &AudioGraphNodePort {
        &self.lfe_amplitude
    }
    fn lfe_amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.lfe_amplitude
    }
    fn version(&self) -> &Pan2dNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut Pan2dNodeVersion {
        &mut self.version
    }
}

impl AudioGraphNodeDataTrait for Pan2dNodeData {
}

impl super::core::DataContainerTrait for Pan2dNodeData {
}

pub static PAN2DNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<Pan2dNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(Pan2dNodeData, plugin),
            },
            FieldInfoData {
                name: "OutputChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Pan2dOutputChannelCount",
                rust_offset: offset_of!(Pan2dNodeData, output_channel_count),
            },
            FieldInfoData {
                name: "PanAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, pan_angle),
            },
            FieldInfoData {
                name: "PanDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, pan_distance),
            },
            FieldInfoData {
                name: "PanSize",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, pan_size),
            },
            FieldInfoData {
                name: "PanTwist",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, pan_twist),
            },
            FieldInfoData {
                name: "CenterAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, center_amplitude),
            },
            FieldInfoData {
                name: "MainAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, main_amplitude),
            },
            FieldInfoData {
                name: "LfeAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(Pan2dNodeData, lfe_amplitude),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "Pan2dNodeVersion",
                rust_offset: offset_of!(Pan2dNodeData, version),
            },
        ],
    }),
    array_type: Some(PAN2DNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for Pan2dNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PAN2DNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PAN2DNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Pan2dNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Pan2dNodeVersion {
    #[default]
    Pan2dNodeVersion_2010_2 = 0,
    Pan2dNodeVersion_2016_1 = 1,
}

pub static PAN2DNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PAN2DNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Pan2dNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        PAN2DNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PAN2DNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Pan2dNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum Pan2dOutputChannelCount {
    #[default]
    Pan2dOutputChannelCount_Two = 0,
    Pan2dOutputChannelCount_Four = 1,
    Pan2dOutputChannelCount_Six = 2,
    Pan2dOutputChannelCount_Eight = 3,
}

pub static PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dOutputChannelCount",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PAN2DOUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for Pan2dOutputChannelCount {
    fn type_info(&self) -> &'static TypeInfo {
        PAN2DOUTPUTCHANNELCOUNT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PAN2DOUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "Pan2dOutputChannelCount-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("Pan2dOutputChannelCount"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PhysicsEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub distance: AudioGraphNodePort,
    pub azimuth: AudioGraphNodePort,
    pub elevation_angle: AudioGraphNodePort,
    pub output: Option<Arc<Mutex<dyn OutputNodeDataTrait>>>,
}

pub trait PhysicsEntryTrait: AudioGraphNodePortGroupTrait {
    fn distance(&self) -> &AudioGraphNodePort;
    fn distance_mut(&mut self) -> &mut AudioGraphNodePort;
    fn azimuth(&self) -> &AudioGraphNodePort;
    fn azimuth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn elevation_angle(&self) -> &AudioGraphNodePort;
    fn elevation_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn output_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
}

impl PhysicsEntryTrait for PhysicsEntry {
    fn distance(&self) -> &AudioGraphNodePort {
        &self.distance
    }
    fn distance_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.distance
    }
    fn azimuth(&self) -> &AudioGraphNodePort {
        &self.azimuth
    }
    fn azimuth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.azimuth
    }
    fn elevation_angle(&self) -> &AudioGraphNodePort {
        &self.elevation_angle
    }
    fn elevation_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.elevation_angle
    }
    fn output(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &self.output
    }
    fn output_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &mut self.output
    }
}

impl AudioGraphNodePortGroupTrait for PhysicsEntry {
}

impl super::core::DataContainerTrait for PhysicsEntry {
}

pub static PHYSICSENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PhysicsEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Distance",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsEntry, distance),
            },
            FieldInfoData {
                name: "Azimuth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsEntry, azimuth),
            },
            FieldInfoData {
                name: "ElevationAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PhysicsEntry, elevation_angle),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputNodeData",
                rust_offset: offset_of!(PhysicsEntry, output),
            },
        ],
    }),
    array_type: Some(PHYSICSENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PhysicsEntry {
    fn type_info(&self) -> &'static TypeInfo {
        PHYSICSENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PHYSICSENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PhysicsEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PhysicsEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct PeakingIir2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub q: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait PeakingIir2NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn q(&self) -> &AudioGraphNodePort;
    fn q_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl PeakingIir2NodeDataTrait for PeakingIir2NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn q(&self) -> &AudioGraphNodePort {
        &self.q
    }
    fn q_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.q
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for PeakingIir2NodeData {
}

impl super::core::DataContainerTrait for PeakingIir2NodeData {
}

pub static PEAKINGIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PeakingIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<PeakingIir2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PeakingIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PeakingIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PeakingIir2NodeData, amplitude),
            },
            FieldInfoData {
                name: "Q",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PeakingIir2NodeData, q),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(PeakingIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(PeakingIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(PEAKINGIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for PeakingIir2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        PEAKINGIIR2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static PEAKINGIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PeakingIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PeakingIir2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OrientationNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub listener_angular_velocity: AudioGraphNodePort,
    pub entries: Vec<Option<Arc<Mutex<dyn OrientationNodeEntryTrait>>>>,
}

pub trait OrientationNodeDataTrait: AudioGraphNodeDataTrait {
    fn listener_angular_velocity(&self) -> &AudioGraphNodePort;
    fn listener_angular_velocity_mut(&mut self) -> &mut AudioGraphNodePort;
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn OrientationNodeEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn OrientationNodeEntryTrait>>>>;
}

impl OrientationNodeDataTrait for OrientationNodeData {
    fn listener_angular_velocity(&self) -> &AudioGraphNodePort {
        &self.listener_angular_velocity
    }
    fn listener_angular_velocity_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_angular_velocity
    }
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn OrientationNodeEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn OrientationNodeEntryTrait>>>> {
        &mut self.entries
    }
}

impl AudioGraphNodeDataTrait for OrientationNodeData {
}

impl super::core::DataContainerTrait for OrientationNodeData {
}

pub static ORIENTATIONNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrientationNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ListenerAngularVelocity",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeData, listener_angular_velocity),
            },
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "OrientationNodeEntry-Array",
                rust_offset: offset_of!(OrientationNodeData, entries),
            },
        ],
    }),
    array_type: Some(ORIENTATIONNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrientationNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        ORIENTATIONNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ORIENTATIONNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrientationNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OrientationNodeEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub listener_relative_yaw: AudioGraphNodePort,
    pub listener_relative_pitch: AudioGraphNodePort,
    pub listener_relative_roll: AudioGraphNodePort,
    pub listener_relative_angle: AudioGraphNodePort,
    pub listener_fov_relative_angle: AudioGraphNodePort,
    pub towards_listener_angle: AudioGraphNodePort,
    pub output: Option<Arc<Mutex<dyn OutputNodeDataTrait>>>,
}

pub trait OrientationNodeEntryTrait: AudioGraphNodePortGroupTrait {
    fn listener_relative_yaw(&self) -> &AudioGraphNodePort;
    fn listener_relative_yaw_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_relative_pitch(&self) -> &AudioGraphNodePort;
    fn listener_relative_pitch_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_relative_roll(&self) -> &AudioGraphNodePort;
    fn listener_relative_roll_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_relative_angle(&self) -> &AudioGraphNodePort;
    fn listener_relative_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_fov_relative_angle(&self) -> &AudioGraphNodePort;
    fn listener_fov_relative_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn towards_listener_angle(&self) -> &AudioGraphNodePort;
    fn towards_listener_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn output_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
}

impl OrientationNodeEntryTrait for OrientationNodeEntry {
    fn listener_relative_yaw(&self) -> &AudioGraphNodePort {
        &self.listener_relative_yaw
    }
    fn listener_relative_yaw_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_relative_yaw
    }
    fn listener_relative_pitch(&self) -> &AudioGraphNodePort {
        &self.listener_relative_pitch
    }
    fn listener_relative_pitch_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_relative_pitch
    }
    fn listener_relative_roll(&self) -> &AudioGraphNodePort {
        &self.listener_relative_roll
    }
    fn listener_relative_roll_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_relative_roll
    }
    fn listener_relative_angle(&self) -> &AudioGraphNodePort {
        &self.listener_relative_angle
    }
    fn listener_relative_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_relative_angle
    }
    fn listener_fov_relative_angle(&self) -> &AudioGraphNodePort {
        &self.listener_fov_relative_angle
    }
    fn listener_fov_relative_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_fov_relative_angle
    }
    fn towards_listener_angle(&self) -> &AudioGraphNodePort {
        &self.towards_listener_angle
    }
    fn towards_listener_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.towards_listener_angle
    }
    fn output(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &self.output
    }
    fn output_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &mut self.output
    }
}

impl AudioGraphNodePortGroupTrait for OrientationNodeEntry {
}

impl super::core::DataContainerTrait for OrientationNodeEntry {
}

pub static ORIENTATIONNODEENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OrientationNodeEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ListenerRelativeYaw",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_yaw),
            },
            FieldInfoData {
                name: "ListenerRelativePitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_pitch),
            },
            FieldInfoData {
                name: "ListenerRelativeRoll",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_roll),
            },
            FieldInfoData {
                name: "ListenerRelativeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeEntry, listener_relative_angle),
            },
            FieldInfoData {
                name: "ListenerFovRelativeAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeEntry, listener_fov_relative_angle),
            },
            FieldInfoData {
                name: "TowardsListenerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OrientationNodeEntry, towards_listener_angle),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputNodeData",
                rust_offset: offset_of!(OrientationNodeEntry, output),
            },
        ],
    }),
    array_type: Some(ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OrientationNodeEntry {
    fn type_info(&self) -> &'static TypeInfo {
        ORIENTATIONNODEENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ORIENTATIONNODEENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OrientationNodeEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OrientationNodeEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectOutputNodeConfigData {
    pub _glacier_base: OutputNodeConfigData,
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub inner_angle: f32,
    pub outer_angle: f32,
    pub h_f_damping_angle: f32,
    pub listener_outside_gain: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub reverb_gain: f32,
    pub object_patch: Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>,
    pub size: f32,
}

pub trait ObjectOutputNodeConfigDataTrait: OutputNodeConfigDataTrait {
    fn direction(&self) -> &super::core::Vec3;
    fn direction_mut(&mut self) -> &mut super::core::Vec3;
    fn outside_gain(&self) -> &f32;
    fn outside_gain_mut(&mut self) -> &mut f32;
    fn bleed_min_distance(&self) -> &f32;
    fn bleed_min_distance_mut(&mut self) -> &mut f32;
    fn bleed_max_distance(&self) -> &f32;
    fn bleed_max_distance_mut(&mut self) -> &mut f32;
    fn inner_angle(&self) -> &f32;
    fn inner_angle_mut(&mut self) -> &mut f32;
    fn outer_angle(&self) -> &f32;
    fn outer_angle_mut(&mut self) -> &mut f32;
    fn h_f_damping_angle(&self) -> &f32;
    fn h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn listener_outside_gain(&self) -> &f32;
    fn listener_outside_gain_mut(&mut self) -> &mut f32;
    fn listener_h_f_damping_angle(&self) -> &f32;
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_gain(&self) -> &f32;
    fn reverb_gain_mut(&mut self) -> &mut f32;
    fn object_patch(&self) -> &Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>;
    fn object_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>;
    fn size(&self) -> &f32;
    fn size_mut(&mut self) -> &mut f32;
}

impl ObjectOutputNodeConfigDataTrait for ObjectOutputNodeConfigData {
    fn direction(&self) -> &super::core::Vec3 {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.direction
    }
    fn outside_gain(&self) -> &f32 {
        &self.outside_gain
    }
    fn outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.outside_gain
    }
    fn bleed_min_distance(&self) -> &f32 {
        &self.bleed_min_distance
    }
    fn bleed_min_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_min_distance
    }
    fn bleed_max_distance(&self) -> &f32 {
        &self.bleed_max_distance
    }
    fn bleed_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_max_distance
    }
    fn inner_angle(&self) -> &f32 {
        &self.inner_angle
    }
    fn inner_angle_mut(&mut self) -> &mut f32 {
        &mut self.inner_angle
    }
    fn outer_angle(&self) -> &f32 {
        &self.outer_angle
    }
    fn outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.outer_angle
    }
    fn h_f_damping_angle(&self) -> &f32 {
        &self.h_f_damping_angle
    }
    fn h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_angle
    }
    fn listener_outside_gain(&self) -> &f32 {
        &self.listener_outside_gain
    }
    fn listener_outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.listener_outside_gain
    }
    fn listener_h_f_damping_angle(&self) -> &f32 {
        &self.listener_h_f_damping_angle
    }
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.listener_h_f_damping_angle
    }
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.reverb_attenuation_curve
    }
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.reverb_attenuation_curve
    }
    fn reverb_gain(&self) -> &f32 {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut f32 {
        &mut self.reverb_gain
    }
    fn object_patch(&self) -> &Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>> {
        &self.object_patch
    }
    fn object_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>> {
        &mut self.object_patch
    }
    fn size(&self) -> &f32 {
        &self.size
    }
    fn size_mut(&mut self) -> &mut f32 {
        &mut self.size
    }
}

impl OutputNodeConfigDataTrait for ObjectOutputNodeConfigData {
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn h_f_damping_distance(&self) -> &f32 {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &f32 {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
}

impl AudioGraphNodeConfigDataTrait for ObjectOutputNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for ObjectOutputNodeConfigData {
}

pub static OBJECTOUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectOutputNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, outside_gain),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, bleed_max_distance),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, outer_angle),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, listener_outside_gain),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, reverb_gain),
            },
            FieldInfoData {
                name: "ObjectPatch",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusPatchAsset",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, object_patch),
            },
            FieldInfoData {
                name: "Size",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeConfigData, size),
            },
        ],
    }),
    array_type: Some(OBJECTOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectOutputNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTOUTPUTNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectOutputNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectOutputNodeData {
    pub _glacier_base: OutputNodeData,
    pub position_x: AudioGraphNodePort,
    pub position_y: AudioGraphNodePort,
    pub position_z: AudioGraphNodePort,
    pub inner_angle: AudioGraphNodePort,
    pub outer_angle: AudioGraphNodePort,
    pub size: AudioGraphNodePort,
    pub object_patch: Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>,
    pub source_positioning: PanSourcePositioning,
    pub channel_based_speaker_angles: bool,
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub listener_inner_angle: AudioGraphNodePort,
    pub listener_outer_angle: AudioGraphNodePort,
    pub listener_outside_gain: f32,
    pub h_f_damping_angle: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub reverb_gain: AudioGraphNodePort,
    pub reverb_mode: OutputReverbMode,
    pub reverb_send: Option<Arc<Mutex<dyn SoundBusDataTrait>>>,
    pub reverb_send_plugin: SoundGraphPluginRef,
    pub pan_plugin: SoundGraphPluginRef,
    pub object_send_plugin: SoundGraphPluginRef,
}

pub trait ObjectOutputNodeDataTrait: OutputNodeDataTrait {
    fn position_x(&self) -> &AudioGraphNodePort;
    fn position_x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn position_y(&self) -> &AudioGraphNodePort;
    fn position_y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn position_z(&self) -> &AudioGraphNodePort;
    fn position_z_mut(&mut self) -> &mut AudioGraphNodePort;
    fn inner_angle(&self) -> &AudioGraphNodePort;
    fn inner_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn outer_angle(&self) -> &AudioGraphNodePort;
    fn outer_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn size(&self) -> &AudioGraphNodePort;
    fn size_mut(&mut self) -> &mut AudioGraphNodePort;
    fn object_patch(&self) -> &Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>;
    fn object_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>;
    fn source_positioning(&self) -> &PanSourcePositioning;
    fn source_positioning_mut(&mut self) -> &mut PanSourcePositioning;
    fn channel_based_speaker_angles(&self) -> &bool;
    fn channel_based_speaker_angles_mut(&mut self) -> &mut bool;
    fn direction(&self) -> &super::core::Vec3;
    fn direction_mut(&mut self) -> &mut super::core::Vec3;
    fn outside_gain(&self) -> &f32;
    fn outside_gain_mut(&mut self) -> &mut f32;
    fn bleed_min_distance(&self) -> &f32;
    fn bleed_min_distance_mut(&mut self) -> &mut f32;
    fn bleed_max_distance(&self) -> &f32;
    fn bleed_max_distance_mut(&mut self) -> &mut f32;
    fn listener_inner_angle(&self) -> &AudioGraphNodePort;
    fn listener_inner_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_outer_angle(&self) -> &AudioGraphNodePort;
    fn listener_outer_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_outside_gain(&self) -> &f32;
    fn listener_outside_gain_mut(&mut self) -> &mut f32;
    fn h_f_damping_angle(&self) -> &f32;
    fn h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn listener_h_f_damping_angle(&self) -> &f32;
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_gain(&self) -> &AudioGraphNodePort;
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_mode(&self) -> &OutputReverbMode;
    fn reverb_mode_mut(&mut self) -> &mut OutputReverbMode;
    fn reverb_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn reverb_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn reverb_send_plugin(&self) -> &SoundGraphPluginRef;
    fn reverb_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn pan_plugin(&self) -> &SoundGraphPluginRef;
    fn pan_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn object_send_plugin(&self) -> &SoundGraphPluginRef;
    fn object_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl ObjectOutputNodeDataTrait for ObjectOutputNodeData {
    fn position_x(&self) -> &AudioGraphNodePort {
        &self.position_x
    }
    fn position_x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position_x
    }
    fn position_y(&self) -> &AudioGraphNodePort {
        &self.position_y
    }
    fn position_y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position_y
    }
    fn position_z(&self) -> &AudioGraphNodePort {
        &self.position_z
    }
    fn position_z_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position_z
    }
    fn inner_angle(&self) -> &AudioGraphNodePort {
        &self.inner_angle
    }
    fn inner_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.inner_angle
    }
    fn outer_angle(&self) -> &AudioGraphNodePort {
        &self.outer_angle
    }
    fn outer_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.outer_angle
    }
    fn size(&self) -> &AudioGraphNodePort {
        &self.size
    }
    fn size_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.size
    }
    fn object_patch(&self) -> &Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>> {
        &self.object_patch
    }
    fn object_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>> {
        &mut self.object_patch
    }
    fn source_positioning(&self) -> &PanSourcePositioning {
        &self.source_positioning
    }
    fn source_positioning_mut(&mut self) -> &mut PanSourcePositioning {
        &mut self.source_positioning
    }
    fn channel_based_speaker_angles(&self) -> &bool {
        &self.channel_based_speaker_angles
    }
    fn channel_based_speaker_angles_mut(&mut self) -> &mut bool {
        &mut self.channel_based_speaker_angles
    }
    fn direction(&self) -> &super::core::Vec3 {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.direction
    }
    fn outside_gain(&self) -> &f32 {
        &self.outside_gain
    }
    fn outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.outside_gain
    }
    fn bleed_min_distance(&self) -> &f32 {
        &self.bleed_min_distance
    }
    fn bleed_min_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_min_distance
    }
    fn bleed_max_distance(&self) -> &f32 {
        &self.bleed_max_distance
    }
    fn bleed_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_max_distance
    }
    fn listener_inner_angle(&self) -> &AudioGraphNodePort {
        &self.listener_inner_angle
    }
    fn listener_inner_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_inner_angle
    }
    fn listener_outer_angle(&self) -> &AudioGraphNodePort {
        &self.listener_outer_angle
    }
    fn listener_outer_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_outer_angle
    }
    fn listener_outside_gain(&self) -> &f32 {
        &self.listener_outside_gain
    }
    fn listener_outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.listener_outside_gain
    }
    fn h_f_damping_angle(&self) -> &f32 {
        &self.h_f_damping_angle
    }
    fn h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_angle
    }
    fn listener_h_f_damping_angle(&self) -> &f32 {
        &self.listener_h_f_damping_angle
    }
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.listener_h_f_damping_angle
    }
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.reverb_attenuation_curve
    }
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.reverb_attenuation_curve
    }
    fn reverb_gain(&self) -> &AudioGraphNodePort {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb_gain
    }
    fn reverb_mode(&self) -> &OutputReverbMode {
        &self.reverb_mode
    }
    fn reverb_mode_mut(&mut self) -> &mut OutputReverbMode {
        &mut self.reverb_mode
    }
    fn reverb_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &self.reverb_send
    }
    fn reverb_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &mut self.reverb_send
    }
    fn reverb_send_plugin(&self) -> &SoundGraphPluginRef {
        &self.reverb_send_plugin
    }
    fn reverb_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.reverb_send_plugin
    }
    fn pan_plugin(&self) -> &SoundGraphPluginRef {
        &self.pan_plugin
    }
    fn pan_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pan_plugin
    }
    fn object_send_plugin(&self) -> &SoundGraphPluginRef {
        &self.object_send_plugin
    }
    fn object_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.object_send_plugin
    }
}

impl OutputNodeDataTrait for ObjectOutputNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        self._glacier_base.r#in()
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.r#in_mut()
    }
    fn bypass_headroom(&self) -> &AudioGraphNodePort {
        self._glacier_base.bypass_headroom()
    }
    fn bypass_headroom_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.bypass_headroom_mut()
    }
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn solo(&self) -> &bool {
        self._glacier_base.solo()
    }
    fn solo_mut(&mut self) -> &mut bool {
        self._glacier_base.solo_mut()
    }
    fn h_f_damping_distance(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn h_f_damping_filter(&self) -> &LowPassFilterType {
        self._glacier_base.h_f_damping_filter()
    }
    fn h_f_damping_filter_mut(&mut self) -> &mut LowPassFilterType {
        self._glacier_base.h_f_damping_filter_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn main_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send()
    }
    fn main_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn transform_source(&self) -> &OutputTransformSource {
        self._glacier_base.transform_source()
    }
    fn transform_source_mut(&mut self) -> &mut OutputTransformSource {
        self._glacier_base.transform_source_mut()
    }
    fn output_name(&self) -> &String {
        self._glacier_base.output_name()
    }
    fn output_name_mut(&mut self) -> &mut String {
        self._glacier_base.output_name_mut()
    }
    fn output_name_hash(&self) -> &u32 {
        self._glacier_base.output_name_hash()
    }
    fn output_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.output_name_hash_mut()
    }
    fn low_pass_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin()
    }
    fn low_pass_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin_mut()
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.vu_plugin()
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.vu_plugin_mut()
    }
    fn main_send_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.main_send_plugin()
    }
    fn main_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.main_send_plugin_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
    fn version(&self) -> &OutputNodeVersion {
        self._glacier_base.version()
    }
    fn version_mut(&mut self) -> &mut OutputNodeVersion {
        self._glacier_base.version_mut()
    }
}

impl AudioGraphNodeDataTrait for ObjectOutputNodeData {
}

impl super::core::DataContainerTrait for ObjectOutputNodeData {
}

pub static OBJECTOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectOutputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PositionX",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, position_x),
            },
            FieldInfoData {
                name: "PositionY",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, position_y),
            },
            FieldInfoData {
                name: "PositionZ",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, position_z),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, outer_angle),
            },
            FieldInfoData {
                name: "Size",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, size),
            },
            FieldInfoData {
                name: "ObjectPatch",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusPatchAsset",
                rust_offset: offset_of!(ObjectOutputNodeData, object_patch),
            },
            FieldInfoData {
                name: "SourcePositioning",
                flags: MemberInfoFlags::new(0),
                field_type: "PanSourcePositioning",
                rust_offset: offset_of!(ObjectOutputNodeData, source_positioning),
            },
            FieldInfoData {
                name: "ChannelBasedSpeakerAngles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ObjectOutputNodeData, channel_based_speaker_angles),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ObjectOutputNodeData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeData, outside_gain),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeData, bleed_max_distance),
            },
            FieldInfoData {
                name: "ListenerInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, listener_inner_angle),
            },
            FieldInfoData {
                name: "ListenerOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, listener_outer_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeData, listener_outside_gain),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectOutputNodeData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "ReverbMode",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputReverbMode",
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_mode),
            },
            FieldInfoData {
                name: "ReverbSend",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusData",
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_send),
            },
            FieldInfoData {
                name: "ReverbSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ObjectOutputNodeData, reverb_send_plugin),
            },
            FieldInfoData {
                name: "PanPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ObjectOutputNodeData, pan_plugin),
            },
            FieldInfoData {
                name: "ObjectSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ObjectOutputNodeData, object_send_plugin),
            },
        ],
    }),
    array_type: Some(OBJECTOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ObjectOutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTOUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectOutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConeOutputNodeConfigData {
    pub _glacier_base: OutputNodeConfigData,
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub pan_size: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub inner_angle: f32,
    pub outer_angle: f32,
    pub h_f_damping_angle: f32,
    pub listener_outside_gain: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub reverb_gain: f32,
}

pub trait ConeOutputNodeConfigDataTrait: OutputNodeConfigDataTrait {
    fn direction(&self) -> &super::core::Vec3;
    fn direction_mut(&mut self) -> &mut super::core::Vec3;
    fn outside_gain(&self) -> &f32;
    fn outside_gain_mut(&mut self) -> &mut f32;
    fn pan_size(&self) -> &f32;
    fn pan_size_mut(&mut self) -> &mut f32;
    fn bleed_min_distance(&self) -> &f32;
    fn bleed_min_distance_mut(&mut self) -> &mut f32;
    fn bleed_max_distance(&self) -> &f32;
    fn bleed_max_distance_mut(&mut self) -> &mut f32;
    fn inner_angle(&self) -> &f32;
    fn inner_angle_mut(&mut self) -> &mut f32;
    fn outer_angle(&self) -> &f32;
    fn outer_angle_mut(&mut self) -> &mut f32;
    fn h_f_damping_angle(&self) -> &f32;
    fn h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn listener_outside_gain(&self) -> &f32;
    fn listener_outside_gain_mut(&mut self) -> &mut f32;
    fn listener_h_f_damping_angle(&self) -> &f32;
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_gain(&self) -> &f32;
    fn reverb_gain_mut(&mut self) -> &mut f32;
}

impl ConeOutputNodeConfigDataTrait for ConeOutputNodeConfigData {
    fn direction(&self) -> &super::core::Vec3 {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.direction
    }
    fn outside_gain(&self) -> &f32 {
        &self.outside_gain
    }
    fn outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.outside_gain
    }
    fn pan_size(&self) -> &f32 {
        &self.pan_size
    }
    fn pan_size_mut(&mut self) -> &mut f32 {
        &mut self.pan_size
    }
    fn bleed_min_distance(&self) -> &f32 {
        &self.bleed_min_distance
    }
    fn bleed_min_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_min_distance
    }
    fn bleed_max_distance(&self) -> &f32 {
        &self.bleed_max_distance
    }
    fn bleed_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_max_distance
    }
    fn inner_angle(&self) -> &f32 {
        &self.inner_angle
    }
    fn inner_angle_mut(&mut self) -> &mut f32 {
        &mut self.inner_angle
    }
    fn outer_angle(&self) -> &f32 {
        &self.outer_angle
    }
    fn outer_angle_mut(&mut self) -> &mut f32 {
        &mut self.outer_angle
    }
    fn h_f_damping_angle(&self) -> &f32 {
        &self.h_f_damping_angle
    }
    fn h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_angle
    }
    fn listener_outside_gain(&self) -> &f32 {
        &self.listener_outside_gain
    }
    fn listener_outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.listener_outside_gain
    }
    fn listener_h_f_damping_angle(&self) -> &f32 {
        &self.listener_h_f_damping_angle
    }
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.listener_h_f_damping_angle
    }
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.reverb_attenuation_curve
    }
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.reverb_attenuation_curve
    }
    fn reverb_gain(&self) -> &f32 {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut f32 {
        &mut self.reverb_gain
    }
}

impl OutputNodeConfigDataTrait for ConeOutputNodeConfigData {
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn h_f_damping_distance(&self) -> &f32 {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &f32 {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
}

impl AudioGraphNodeConfigDataTrait for ConeOutputNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for ConeOutputNodeConfigData {
}

pub static CONEOUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConeOutputNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConeOutputNodeConfigData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, outside_gain),
            },
            FieldInfoData {
                name: "PanSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, pan_size),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, bleed_max_distance),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, outer_angle),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, listener_outside_gain),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(ConeOutputNodeConfigData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeConfigData, reverb_gain),
            },
        ],
    }),
    array_type: Some(CONEOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ConeOutputNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        CONEOUTPUTNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONEOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConeOutputNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ConeOutputNodeData {
    pub _glacier_base: OutputNodeData,
    pub position_x: AudioGraphNodePort,
    pub position_y: AudioGraphNodePort,
    pub position_z: AudioGraphNodePort,
    pub inner_angle: AudioGraphNodePort,
    pub outer_angle: AudioGraphNodePort,
    pub direction: super::core::Vec3,
    pub outside_gain: f32,
    pub pan_size: f32,
    pub bleed_min_distance: f32,
    pub bleed_max_distance: f32,
    pub listener_inner_angle: AudioGraphNodePort,
    pub listener_outer_angle: AudioGraphNodePort,
    pub listener_outside_gain: f32,
    pub center_level: AudioGraphNodePort,
    pub lfe_level: AudioGraphNodePort,
    pub source_positioning: PanSourcePositioning,
    pub channel_based_speaker_angles: bool,
    pub h_f_damping_angle: f32,
    pub listener_h_f_damping_angle: f32,
    pub reverb_attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub reverb_gain: AudioGraphNodePort,
    pub reverb_mode: OutputReverbMode,
    pub reverb_send: Option<Arc<Mutex<dyn SoundBusDataTrait>>>,
    pub pan_plugin: SoundGraphPluginRef,
    pub reverb_send_plugin: SoundGraphPluginRef,
}

pub trait ConeOutputNodeDataTrait: OutputNodeDataTrait {
    fn position_x(&self) -> &AudioGraphNodePort;
    fn position_x_mut(&mut self) -> &mut AudioGraphNodePort;
    fn position_y(&self) -> &AudioGraphNodePort;
    fn position_y_mut(&mut self) -> &mut AudioGraphNodePort;
    fn position_z(&self) -> &AudioGraphNodePort;
    fn position_z_mut(&mut self) -> &mut AudioGraphNodePort;
    fn inner_angle(&self) -> &AudioGraphNodePort;
    fn inner_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn outer_angle(&self) -> &AudioGraphNodePort;
    fn outer_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn direction(&self) -> &super::core::Vec3;
    fn direction_mut(&mut self) -> &mut super::core::Vec3;
    fn outside_gain(&self) -> &f32;
    fn outside_gain_mut(&mut self) -> &mut f32;
    fn pan_size(&self) -> &f32;
    fn pan_size_mut(&mut self) -> &mut f32;
    fn bleed_min_distance(&self) -> &f32;
    fn bleed_min_distance_mut(&mut self) -> &mut f32;
    fn bleed_max_distance(&self) -> &f32;
    fn bleed_max_distance_mut(&mut self) -> &mut f32;
    fn listener_inner_angle(&self) -> &AudioGraphNodePort;
    fn listener_inner_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_outer_angle(&self) -> &AudioGraphNodePort;
    fn listener_outer_angle_mut(&mut self) -> &mut AudioGraphNodePort;
    fn listener_outside_gain(&self) -> &f32;
    fn listener_outside_gain_mut(&mut self) -> &mut f32;
    fn center_level(&self) -> &AudioGraphNodePort;
    fn center_level_mut(&mut self) -> &mut AudioGraphNodePort;
    fn lfe_level(&self) -> &AudioGraphNodePort;
    fn lfe_level_mut(&mut self) -> &mut AudioGraphNodePort;
    fn source_positioning(&self) -> &PanSourcePositioning;
    fn source_positioning_mut(&mut self) -> &mut PanSourcePositioning;
    fn channel_based_speaker_angles(&self) -> &bool;
    fn channel_based_speaker_angles_mut(&mut self) -> &mut bool;
    fn h_f_damping_angle(&self) -> &f32;
    fn h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn listener_h_f_damping_angle(&self) -> &f32;
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32;
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_gain(&self) -> &AudioGraphNodePort;
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_mode(&self) -> &OutputReverbMode;
    fn reverb_mode_mut(&mut self) -> &mut OutputReverbMode;
    fn reverb_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn reverb_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn pan_plugin(&self) -> &SoundGraphPluginRef;
    fn pan_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn reverb_send_plugin(&self) -> &SoundGraphPluginRef;
    fn reverb_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl ConeOutputNodeDataTrait for ConeOutputNodeData {
    fn position_x(&self) -> &AudioGraphNodePort {
        &self.position_x
    }
    fn position_x_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position_x
    }
    fn position_y(&self) -> &AudioGraphNodePort {
        &self.position_y
    }
    fn position_y_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position_y
    }
    fn position_z(&self) -> &AudioGraphNodePort {
        &self.position_z
    }
    fn position_z_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.position_z
    }
    fn inner_angle(&self) -> &AudioGraphNodePort {
        &self.inner_angle
    }
    fn inner_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.inner_angle
    }
    fn outer_angle(&self) -> &AudioGraphNodePort {
        &self.outer_angle
    }
    fn outer_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.outer_angle
    }
    fn direction(&self) -> &super::core::Vec3 {
        &self.direction
    }
    fn direction_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.direction
    }
    fn outside_gain(&self) -> &f32 {
        &self.outside_gain
    }
    fn outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.outside_gain
    }
    fn pan_size(&self) -> &f32 {
        &self.pan_size
    }
    fn pan_size_mut(&mut self) -> &mut f32 {
        &mut self.pan_size
    }
    fn bleed_min_distance(&self) -> &f32 {
        &self.bleed_min_distance
    }
    fn bleed_min_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_min_distance
    }
    fn bleed_max_distance(&self) -> &f32 {
        &self.bleed_max_distance
    }
    fn bleed_max_distance_mut(&mut self) -> &mut f32 {
        &mut self.bleed_max_distance
    }
    fn listener_inner_angle(&self) -> &AudioGraphNodePort {
        &self.listener_inner_angle
    }
    fn listener_inner_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_inner_angle
    }
    fn listener_outer_angle(&self) -> &AudioGraphNodePort {
        &self.listener_outer_angle
    }
    fn listener_outer_angle_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.listener_outer_angle
    }
    fn listener_outside_gain(&self) -> &f32 {
        &self.listener_outside_gain
    }
    fn listener_outside_gain_mut(&mut self) -> &mut f32 {
        &mut self.listener_outside_gain
    }
    fn center_level(&self) -> &AudioGraphNodePort {
        &self.center_level
    }
    fn center_level_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.center_level
    }
    fn lfe_level(&self) -> &AudioGraphNodePort {
        &self.lfe_level
    }
    fn lfe_level_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.lfe_level
    }
    fn source_positioning(&self) -> &PanSourcePositioning {
        &self.source_positioning
    }
    fn source_positioning_mut(&mut self) -> &mut PanSourcePositioning {
        &mut self.source_positioning
    }
    fn channel_based_speaker_angles(&self) -> &bool {
        &self.channel_based_speaker_angles
    }
    fn channel_based_speaker_angles_mut(&mut self) -> &mut bool {
        &mut self.channel_based_speaker_angles
    }
    fn h_f_damping_angle(&self) -> &f32 {
        &self.h_f_damping_angle
    }
    fn h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_angle
    }
    fn listener_h_f_damping_angle(&self) -> &f32 {
        &self.listener_h_f_damping_angle
    }
    fn listener_h_f_damping_angle_mut(&mut self) -> &mut f32 {
        &mut self.listener_h_f_damping_angle
    }
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.reverb_attenuation_curve
    }
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.reverb_attenuation_curve
    }
    fn reverb_gain(&self) -> &AudioGraphNodePort {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb_gain
    }
    fn reverb_mode(&self) -> &OutputReverbMode {
        &self.reverb_mode
    }
    fn reverb_mode_mut(&mut self) -> &mut OutputReverbMode {
        &mut self.reverb_mode
    }
    fn reverb_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &self.reverb_send
    }
    fn reverb_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &mut self.reverb_send
    }
    fn pan_plugin(&self) -> &SoundGraphPluginRef {
        &self.pan_plugin
    }
    fn pan_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pan_plugin
    }
    fn reverb_send_plugin(&self) -> &SoundGraphPluginRef {
        &self.reverb_send_plugin
    }
    fn reverb_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.reverb_send_plugin
    }
}

impl OutputNodeDataTrait for ConeOutputNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        self._glacier_base.r#in()
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.r#in_mut()
    }
    fn bypass_headroom(&self) -> &AudioGraphNodePort {
        self._glacier_base.bypass_headroom()
    }
    fn bypass_headroom_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.bypass_headroom_mut()
    }
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn solo(&self) -> &bool {
        self._glacier_base.solo()
    }
    fn solo_mut(&mut self) -> &mut bool {
        self._glacier_base.solo_mut()
    }
    fn h_f_damping_distance(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn h_f_damping_filter(&self) -> &LowPassFilterType {
        self._glacier_base.h_f_damping_filter()
    }
    fn h_f_damping_filter_mut(&mut self) -> &mut LowPassFilterType {
        self._glacier_base.h_f_damping_filter_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn main_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send()
    }
    fn main_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn transform_source(&self) -> &OutputTransformSource {
        self._glacier_base.transform_source()
    }
    fn transform_source_mut(&mut self) -> &mut OutputTransformSource {
        self._glacier_base.transform_source_mut()
    }
    fn output_name(&self) -> &String {
        self._glacier_base.output_name()
    }
    fn output_name_mut(&mut self) -> &mut String {
        self._glacier_base.output_name_mut()
    }
    fn output_name_hash(&self) -> &u32 {
        self._glacier_base.output_name_hash()
    }
    fn output_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.output_name_hash_mut()
    }
    fn low_pass_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin()
    }
    fn low_pass_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin_mut()
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.vu_plugin()
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.vu_plugin_mut()
    }
    fn main_send_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.main_send_plugin()
    }
    fn main_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.main_send_plugin_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
    fn version(&self) -> &OutputNodeVersion {
        self._glacier_base.version()
    }
    fn version_mut(&mut self) -> &mut OutputNodeVersion {
        self._glacier_base.version_mut()
    }
}

impl AudioGraphNodeDataTrait for ConeOutputNodeData {
}

impl super::core::DataContainerTrait for ConeOutputNodeData {
}

pub static CONEOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ConeOutputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "PositionX",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, position_x),
            },
            FieldInfoData {
                name: "PositionY",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, position_y),
            },
            FieldInfoData {
                name: "PositionZ",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, position_z),
            },
            FieldInfoData {
                name: "InnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, inner_angle),
            },
            FieldInfoData {
                name: "OuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, outer_angle),
            },
            FieldInfoData {
                name: "Direction",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(ConeOutputNodeData, direction),
            },
            FieldInfoData {
                name: "OutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, outside_gain),
            },
            FieldInfoData {
                name: "PanSize",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, pan_size),
            },
            FieldInfoData {
                name: "BleedMinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, bleed_min_distance),
            },
            FieldInfoData {
                name: "BleedMaxDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, bleed_max_distance),
            },
            FieldInfoData {
                name: "ListenerInnerAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, listener_inner_angle),
            },
            FieldInfoData {
                name: "ListenerOuterAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, listener_outer_angle),
            },
            FieldInfoData {
                name: "ListenerOutsideGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, listener_outside_gain),
            },
            FieldInfoData {
                name: "CenterLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, center_level),
            },
            FieldInfoData {
                name: "LfeLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, lfe_level),
            },
            FieldInfoData {
                name: "SourcePositioning",
                flags: MemberInfoFlags::new(0),
                field_type: "PanSourcePositioning",
                rust_offset: offset_of!(ConeOutputNodeData, source_positioning),
            },
            FieldInfoData {
                name: "ChannelBasedSpeakerAngles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(ConeOutputNodeData, channel_based_speaker_angles),
            },
            FieldInfoData {
                name: "HFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, h_f_damping_angle),
            },
            FieldInfoData {
                name: "ListenerHFDampingAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ConeOutputNodeData, listener_h_f_damping_angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(ConeOutputNodeData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ConeOutputNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "ReverbMode",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputReverbMode",
                rust_offset: offset_of!(ConeOutputNodeData, reverb_mode),
            },
            FieldInfoData {
                name: "ReverbSend",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusData",
                rust_offset: offset_of!(ConeOutputNodeData, reverb_send),
            },
            FieldInfoData {
                name: "PanPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ConeOutputNodeData, pan_plugin),
            },
            FieldInfoData {
                name: "ReverbSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ConeOutputNodeData, reverb_send_plugin),
            },
        ],
    }),
    array_type: Some(CONEOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for ConeOutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CONEOUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONEOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ConeOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ConeOutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FlatOutputNodeConfigData {
    pub _glacier_base: OutputNodeConfigData,
    pub is_world_aligned: bool,
    pub world_angle: f32,
    pub angle: f32,
    pub reverb_attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub reverb_gain: f32,
}

pub trait FlatOutputNodeConfigDataTrait: OutputNodeConfigDataTrait {
    fn is_world_aligned(&self) -> &bool;
    fn is_world_aligned_mut(&mut self) -> &mut bool;
    fn world_angle(&self) -> &f32;
    fn world_angle_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_gain(&self) -> &f32;
    fn reverb_gain_mut(&mut self) -> &mut f32;
}

impl FlatOutputNodeConfigDataTrait for FlatOutputNodeConfigData {
    fn is_world_aligned(&self) -> &bool {
        &self.is_world_aligned
    }
    fn is_world_aligned_mut(&mut self) -> &mut bool {
        &mut self.is_world_aligned
    }
    fn world_angle(&self) -> &f32 {
        &self.world_angle
    }
    fn world_angle_mut(&mut self) -> &mut f32 {
        &mut self.world_angle
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.reverb_attenuation_curve
    }
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.reverb_attenuation_curve
    }
    fn reverb_gain(&self) -> &f32 {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut f32 {
        &mut self.reverb_gain
    }
}

impl OutputNodeConfigDataTrait for FlatOutputNodeConfigData {
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn h_f_damping_distance(&self) -> &f32 {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &f32 {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
}

impl AudioGraphNodeConfigDataTrait for FlatOutputNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for FlatOutputNodeConfigData {
}

pub static FLATOUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FlatOutputNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsWorldAligned",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FlatOutputNodeConfigData, is_world_aligned),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlatOutputNodeConfigData, world_angle),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlatOutputNodeConfigData, angle),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FlatOutputNodeConfigData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlatOutputNodeConfigData, reverb_gain),
            },
        ],
    }),
    array_type: Some(FLATOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlatOutputNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        FLATOUTPUTNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLATOUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FlatOutputNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FlatOutputNodeData {
    pub _glacier_base: OutputNodeData,
    pub is_world_aligned: bool,
    pub world_angle: f32,
    pub angle: f32,
    pub angle_input: AudioGraphNodePort,
    pub reverb_attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub reverb_gain: AudioGraphNodePort,
    pub reverb_mode: OutputReverbMode,
    pub reverb_send: Option<Arc<Mutex<dyn SoundBusDataTrait>>>,
    pub center_level: AudioGraphNodePort,
    pub lfe_level: AudioGraphNodePort,
    pub source_positioning: PanSourcePositioning,
    pub channel_based_speaker_angles: bool,
    pub pan_plugin: SoundGraphPluginRef,
    pub reverb_send_plugin: SoundGraphPluginRef,
}

pub trait FlatOutputNodeDataTrait: OutputNodeDataTrait {
    fn is_world_aligned(&self) -> &bool;
    fn is_world_aligned_mut(&mut self) -> &mut bool;
    fn world_angle(&self) -> &f32;
    fn world_angle_mut(&mut self) -> &mut f32;
    fn angle(&self) -> &f32;
    fn angle_mut(&mut self) -> &mut f32;
    fn angle_input(&self) -> &AudioGraphNodePort;
    fn angle_input_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn reverb_gain(&self) -> &AudioGraphNodePort;
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_mode(&self) -> &OutputReverbMode;
    fn reverb_mode_mut(&mut self) -> &mut OutputReverbMode;
    fn reverb_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn reverb_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn center_level(&self) -> &AudioGraphNodePort;
    fn center_level_mut(&mut self) -> &mut AudioGraphNodePort;
    fn lfe_level(&self) -> &AudioGraphNodePort;
    fn lfe_level_mut(&mut self) -> &mut AudioGraphNodePort;
    fn source_positioning(&self) -> &PanSourcePositioning;
    fn source_positioning_mut(&mut self) -> &mut PanSourcePositioning;
    fn channel_based_speaker_angles(&self) -> &bool;
    fn channel_based_speaker_angles_mut(&mut self) -> &mut bool;
    fn pan_plugin(&self) -> &SoundGraphPluginRef;
    fn pan_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn reverb_send_plugin(&self) -> &SoundGraphPluginRef;
    fn reverb_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl FlatOutputNodeDataTrait for FlatOutputNodeData {
    fn is_world_aligned(&self) -> &bool {
        &self.is_world_aligned
    }
    fn is_world_aligned_mut(&mut self) -> &mut bool {
        &mut self.is_world_aligned
    }
    fn world_angle(&self) -> &f32 {
        &self.world_angle
    }
    fn world_angle_mut(&mut self) -> &mut f32 {
        &mut self.world_angle
    }
    fn angle(&self) -> &f32 {
        &self.angle
    }
    fn angle_mut(&mut self) -> &mut f32 {
        &mut self.angle
    }
    fn angle_input(&self) -> &AudioGraphNodePort {
        &self.angle_input
    }
    fn angle_input_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.angle_input
    }
    fn reverb_attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.reverb_attenuation_curve
    }
    fn reverb_attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.reverb_attenuation_curve
    }
    fn reverb_gain(&self) -> &AudioGraphNodePort {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb_gain
    }
    fn reverb_mode(&self) -> &OutputReverbMode {
        &self.reverb_mode
    }
    fn reverb_mode_mut(&mut self) -> &mut OutputReverbMode {
        &mut self.reverb_mode
    }
    fn reverb_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &self.reverb_send
    }
    fn reverb_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &mut self.reverb_send
    }
    fn center_level(&self) -> &AudioGraphNodePort {
        &self.center_level
    }
    fn center_level_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.center_level
    }
    fn lfe_level(&self) -> &AudioGraphNodePort {
        &self.lfe_level
    }
    fn lfe_level_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.lfe_level
    }
    fn source_positioning(&self) -> &PanSourcePositioning {
        &self.source_positioning
    }
    fn source_positioning_mut(&mut self) -> &mut PanSourcePositioning {
        &mut self.source_positioning
    }
    fn channel_based_speaker_angles(&self) -> &bool {
        &self.channel_based_speaker_angles
    }
    fn channel_based_speaker_angles_mut(&mut self) -> &mut bool {
        &mut self.channel_based_speaker_angles
    }
    fn pan_plugin(&self) -> &SoundGraphPluginRef {
        &self.pan_plugin
    }
    fn pan_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pan_plugin
    }
    fn reverb_send_plugin(&self) -> &SoundGraphPluginRef {
        &self.reverb_send_plugin
    }
    fn reverb_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.reverb_send_plugin
    }
}

impl OutputNodeDataTrait for FlatOutputNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        self._glacier_base.r#in()
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.r#in_mut()
    }
    fn bypass_headroom(&self) -> &AudioGraphNodePort {
        self._glacier_base.bypass_headroom()
    }
    fn bypass_headroom_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.bypass_headroom_mut()
    }
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn solo(&self) -> &bool {
        self._glacier_base.solo()
    }
    fn solo_mut(&mut self) -> &mut bool {
        self._glacier_base.solo_mut()
    }
    fn h_f_damping_distance(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn h_f_damping_filter(&self) -> &LowPassFilterType {
        self._glacier_base.h_f_damping_filter()
    }
    fn h_f_damping_filter_mut(&mut self) -> &mut LowPassFilterType {
        self._glacier_base.h_f_damping_filter_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn main_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send()
    }
    fn main_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn transform_source(&self) -> &OutputTransformSource {
        self._glacier_base.transform_source()
    }
    fn transform_source_mut(&mut self) -> &mut OutputTransformSource {
        self._glacier_base.transform_source_mut()
    }
    fn output_name(&self) -> &String {
        self._glacier_base.output_name()
    }
    fn output_name_mut(&mut self) -> &mut String {
        self._glacier_base.output_name_mut()
    }
    fn output_name_hash(&self) -> &u32 {
        self._glacier_base.output_name_hash()
    }
    fn output_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.output_name_hash_mut()
    }
    fn low_pass_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin()
    }
    fn low_pass_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin_mut()
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.vu_plugin()
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.vu_plugin_mut()
    }
    fn main_send_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.main_send_plugin()
    }
    fn main_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.main_send_plugin_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
    fn version(&self) -> &OutputNodeVersion {
        self._glacier_base.version()
    }
    fn version_mut(&mut self) -> &mut OutputNodeVersion {
        self._glacier_base.version_mut()
    }
}

impl AudioGraphNodeDataTrait for FlatOutputNodeData {
}

impl super::core::DataContainerTrait for FlatOutputNodeData {
}

pub static FLATOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FlatOutputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "IsWorldAligned",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FlatOutputNodeData, is_world_aligned),
            },
            FieldInfoData {
                name: "WorldAngle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlatOutputNodeData, world_angle),
            },
            FieldInfoData {
                name: "Angle",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlatOutputNodeData, angle),
            },
            FieldInfoData {
                name: "AngleInput",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlatOutputNodeData, angle_input),
            },
            FieldInfoData {
                name: "ReverbAttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(FlatOutputNodeData, reverb_attenuation_curve),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlatOutputNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "ReverbMode",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputReverbMode",
                rust_offset: offset_of!(FlatOutputNodeData, reverb_mode),
            },
            FieldInfoData {
                name: "ReverbSend",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusData",
                rust_offset: offset_of!(FlatOutputNodeData, reverb_send),
            },
            FieldInfoData {
                name: "CenterLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlatOutputNodeData, center_level),
            },
            FieldInfoData {
                name: "LfeLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlatOutputNodeData, lfe_level),
            },
            FieldInfoData {
                name: "SourcePositioning",
                flags: MemberInfoFlags::new(0),
                field_type: "PanSourcePositioning",
                rust_offset: offset_of!(FlatOutputNodeData, source_positioning),
            },
            FieldInfoData {
                name: "ChannelBasedSpeakerAngles",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(FlatOutputNodeData, channel_based_speaker_angles),
            },
            FieldInfoData {
                name: "PanPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(FlatOutputNodeData, pan_plugin),
            },
            FieldInfoData {
                name: "ReverbSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(FlatOutputNodeData, reverb_send_plugin),
            },
        ],
    }),
    array_type: Some(FLATOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlatOutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        FLATOUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLATOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlatOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FlatOutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PanSourcePositioning {
    #[default]
    PanSourcePositioning_InputChannelBased = 0,
    PanSourcePositioning_FixedPosition = 1,
    PanSourcePositioning_InbetweenSpeaker = 2,
}

pub static PANSOURCEPOSITIONING_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanSourcePositioning",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PANSOURCEPOSITIONING_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PanSourcePositioning {
    fn type_info(&self) -> &'static TypeInfo {
        PANSOURCEPOSITIONING_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PANSOURCEPOSITIONING_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanSourcePositioning-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PanSourcePositioning"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum OutputReverbMode {
    #[default]
    OutputReverbMode_PostGain = 0,
    OutputReverbMode_PreGain = 1,
}

pub static OUTPUTREVERBMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputReverbMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(OUTPUTREVERBMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OutputReverbMode {
    fn type_info(&self) -> &'static TypeInfo {
        OUTPUTREVERBMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static OUTPUTREVERBMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputReverbMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputReverbMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DirectOutputNodeData {
    pub _glacier_base: OutputNodeData,
}

pub trait DirectOutputNodeDataTrait: OutputNodeDataTrait {
}

impl DirectOutputNodeDataTrait for DirectOutputNodeData {
}

impl OutputNodeDataTrait for DirectOutputNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        self._glacier_base.r#in()
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.r#in_mut()
    }
    fn bypass_headroom(&self) -> &AudioGraphNodePort {
        self._glacier_base.bypass_headroom()
    }
    fn bypass_headroom_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.bypass_headroom_mut()
    }
    fn min_distance(&self) -> &f32 {
        self._glacier_base.min_distance()
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        self._glacier_base.min_distance_mut()
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve()
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        self._glacier_base.attenuation_curve_mut()
    }
    fn solo(&self) -> &bool {
        self._glacier_base.solo()
    }
    fn solo_mut(&mut self) -> &mut bool {
        self._glacier_base.solo_mut()
    }
    fn h_f_damping_distance(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance()
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_distance_mut()
    }
    fn h_f_damping_obstruction(&self) -> &AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction()
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut AudioGraphNodePort {
        self._glacier_base.h_f_damping_obstruction_mut()
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        self._glacier_base.h_f_damping_occlusion()
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        self._glacier_base.h_f_damping_occlusion_mut()
    }
    fn h_f_damping_filter(&self) -> &LowPassFilterType {
        self._glacier_base.h_f_damping_filter()
    }
    fn h_f_damping_filter_mut(&mut self) -> &mut LowPassFilterType {
        self._glacier_base.h_f_damping_filter_mut()
    }
    fn gain(&self) -> &f32 {
        self._glacier_base.gain()
    }
    fn gain_mut(&mut self) -> &mut f32 {
        self._glacier_base.gain_mut()
    }
    fn main_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send()
    }
    fn main_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        self._glacier_base.main_send_mut()
    }
    fn enable_hdr(&self) -> &bool {
        self._glacier_base.enable_hdr()
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        self._glacier_base.enable_hdr_mut()
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        self._glacier_base.expected_peak_amplitude()
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        self._glacier_base.expected_peak_amplitude_mut()
    }
    fn transform_source(&self) -> &OutputTransformSource {
        self._glacier_base.transform_source()
    }
    fn transform_source_mut(&mut self) -> &mut OutputTransformSource {
        self._glacier_base.transform_source_mut()
    }
    fn output_name(&self) -> &String {
        self._glacier_base.output_name()
    }
    fn output_name_mut(&mut self) -> &mut String {
        self._glacier_base.output_name_mut()
    }
    fn output_name_hash(&self) -> &u32 {
        self._glacier_base.output_name_hash()
    }
    fn output_name_hash_mut(&mut self) -> &mut u32 {
        self._glacier_base.output_name_hash_mut()
    }
    fn low_pass_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin()
    }
    fn low_pass_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.low_pass_plugin_mut()
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.vu_plugin()
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.vu_plugin_mut()
    }
    fn main_send_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.main_send_plugin()
    }
    fn main_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.main_send_plugin_mut()
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group()
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        self._glacier_base.mix_group_mut()
    }
    fn version(&self) -> &OutputNodeVersion {
        self._glacier_base.version()
    }
    fn version_mut(&mut self) -> &mut OutputNodeVersion {
        self._glacier_base.version_mut()
    }
}

impl AudioGraphNodeDataTrait for DirectOutputNodeData {
}

impl super::core::DataContainerTrait for DirectOutputNodeData {
}

pub static DIRECTOUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DirectOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(OUTPUTNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DirectOutputNodeData as Default>::default())),
        },
        fields: &[
        ],
    }),
    array_type: Some(DIRECTOUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DirectOutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DIRECTOUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIRECTOUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DirectOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DirectOutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OutputNodeConfigData {
    pub _glacier_base: AudioGraphNodeConfigData,
    pub min_distance: f32,
    pub attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub h_f_damping_distance: f32,
    pub h_f_damping_obstruction: f32,
    pub h_f_damping_occlusion: f32,
    pub gain: f32,
    pub enable_hdr: bool,
    pub expected_peak_amplitude: f32,
    pub mix_group: Option<Arc<Mutex<dyn MixGroupTrait>>>,
}

pub trait OutputNodeConfigDataTrait: AudioGraphNodeConfigDataTrait {
    fn min_distance(&self) -> &f32;
    fn min_distance_mut(&mut self) -> &mut f32;
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn h_f_damping_distance(&self) -> &f32;
    fn h_f_damping_distance_mut(&mut self) -> &mut f32;
    fn h_f_damping_obstruction(&self) -> &f32;
    fn h_f_damping_obstruction_mut(&mut self) -> &mut f32;
    fn h_f_damping_occlusion(&self) -> &f32;
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32;
    fn gain(&self) -> &f32;
    fn gain_mut(&mut self) -> &mut f32;
    fn enable_hdr(&self) -> &bool;
    fn enable_hdr_mut(&mut self) -> &mut bool;
    fn expected_peak_amplitude(&self) -> &f32;
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32;
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>>;
}

impl OutputNodeConfigDataTrait for OutputNodeConfigData {
    fn min_distance(&self) -> &f32 {
        &self.min_distance
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_distance
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.attenuation_curve
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.attenuation_curve
    }
    fn h_f_damping_distance(&self) -> &f32 {
        &self.h_f_damping_distance
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_distance
    }
    fn h_f_damping_obstruction(&self) -> &f32 {
        &self.h_f_damping_obstruction
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_obstruction
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        &self.h_f_damping_occlusion
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_occlusion
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut f32 {
        &mut self.gain
    }
    fn enable_hdr(&self) -> &bool {
        &self.enable_hdr
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        &mut self.enable_hdr
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        &self.expected_peak_amplitude
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.expected_peak_amplitude
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &self.mix_group
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &mut self.mix_group
    }
}

impl AudioGraphNodeConfigDataTrait for OutputNodeConfigData {
    fn node(&self) -> &Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node()
    }
    fn node_mut(&mut self) -> &mut Option<Arc<Mutex<dyn AudioGraphNodeDataTrait>>> {
        self._glacier_base.node_mut()
    }
    fn configured_property_flags(&self) -> &u64 {
        self._glacier_base.configured_property_flags()
    }
    fn configured_property_flags_mut(&mut self) -> &mut u64 {
        self._glacier_base.configured_property_flags_mut()
    }
}

impl super::core::DataContainerTrait for OutputNodeConfigData {
}

pub static OUTPUTNODECONFIGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeConfigData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODECONFIGDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OutputNodeConfigData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeConfigData, min_distance),
            },
            FieldInfoData {
                name: "AttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(OutputNodeConfigData, attenuation_curve),
            },
            FieldInfoData {
                name: "HFDampingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeConfigData, h_f_damping_distance),
            },
            FieldInfoData {
                name: "HFDampingObstruction",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeConfigData, h_f_damping_obstruction),
            },
            FieldInfoData {
                name: "HFDampingOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeConfigData, h_f_damping_occlusion),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeConfigData, gain),
            },
            FieldInfoData {
                name: "EnableHdr",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutputNodeConfigData, enable_hdr),
            },
            FieldInfoData {
                name: "ExpectedPeakAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeConfigData, expected_peak_amplitude),
            },
            FieldInfoData {
                name: "MixGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "MixGroup",
                rust_offset: offset_of!(OutputNodeConfigData, mix_group),
            },
        ],
    }),
    array_type: Some(OUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OutputNodeConfigData {
    fn type_info(&self) -> &'static TypeInfo {
        OUTPUTNODECONFIGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OUTPUTNODECONFIGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeConfigData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputNodeConfigData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct OutputNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub bypass_headroom: AudioGraphNodePort,
    pub min_distance: f32,
    pub attenuation_curve: Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>,
    pub solo: bool,
    pub h_f_damping_distance: AudioGraphNodePort,
    pub h_f_damping_obstruction: AudioGraphNodePort,
    pub h_f_damping_occlusion: f32,
    pub h_f_damping_filter: LowPassFilterType,
    pub gain: f32,
    pub main_send: Option<Arc<Mutex<dyn SoundBusDataTrait>>>,
    pub enable_hdr: bool,
    pub expected_peak_amplitude: f32,
    pub transform_source: OutputTransformSource,
    pub output_name: String,
    pub output_name_hash: u32,
    pub low_pass_plugin: SoundGraphPluginRef,
    pub vu_plugin: SoundGraphPluginRef,
    pub main_send_plugin: SoundGraphPluginRef,
    pub mix_group: Option<Arc<Mutex<dyn MixGroupTrait>>>,
    pub version: OutputNodeVersion,
}

pub trait OutputNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn bypass_headroom(&self) -> &AudioGraphNodePort;
    fn bypass_headroom_mut(&mut self) -> &mut AudioGraphNodePort;
    fn min_distance(&self) -> &f32;
    fn min_distance_mut(&mut self) -> &mut f32;
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>>;
    fn solo(&self) -> &bool;
    fn solo_mut(&mut self) -> &mut bool;
    fn h_f_damping_distance(&self) -> &AudioGraphNodePort;
    fn h_f_damping_distance_mut(&mut self) -> &mut AudioGraphNodePort;
    fn h_f_damping_obstruction(&self) -> &AudioGraphNodePort;
    fn h_f_damping_obstruction_mut(&mut self) -> &mut AudioGraphNodePort;
    fn h_f_damping_occlusion(&self) -> &f32;
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32;
    fn h_f_damping_filter(&self) -> &LowPassFilterType;
    fn h_f_damping_filter_mut(&mut self) -> &mut LowPassFilterType;
    fn gain(&self) -> &f32;
    fn gain_mut(&mut self) -> &mut f32;
    fn main_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn main_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>>;
    fn enable_hdr(&self) -> &bool;
    fn enable_hdr_mut(&mut self) -> &mut bool;
    fn expected_peak_amplitude(&self) -> &f32;
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32;
    fn transform_source(&self) -> &OutputTransformSource;
    fn transform_source_mut(&mut self) -> &mut OutputTransformSource;
    fn output_name(&self) -> &String;
    fn output_name_mut(&mut self) -> &mut String;
    fn output_name_hash(&self) -> &u32;
    fn output_name_hash_mut(&mut self) -> &mut u32;
    fn low_pass_plugin(&self) -> &SoundGraphPluginRef;
    fn low_pass_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn vu_plugin(&self) -> &SoundGraphPluginRef;
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn main_send_plugin(&self) -> &SoundGraphPluginRef;
    fn main_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>>;
    fn version(&self) -> &OutputNodeVersion;
    fn version_mut(&mut self) -> &mut OutputNodeVersion;
}

impl OutputNodeDataTrait for OutputNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn bypass_headroom(&self) -> &AudioGraphNodePort {
        &self.bypass_headroom
    }
    fn bypass_headroom_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.bypass_headroom
    }
    fn min_distance(&self) -> &f32 {
        &self.min_distance
    }
    fn min_distance_mut(&mut self) -> &mut f32 {
        &mut self.min_distance
    }
    fn attenuation_curve(&self) -> &Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &self.attenuation_curve
    }
    fn attenuation_curve_mut(&mut self) -> &mut Option<Arc<Mutex<dyn super::core::FloatCurveTrait>>> {
        &mut self.attenuation_curve
    }
    fn solo(&self) -> &bool {
        &self.solo
    }
    fn solo_mut(&mut self) -> &mut bool {
        &mut self.solo
    }
    fn h_f_damping_distance(&self) -> &AudioGraphNodePort {
        &self.h_f_damping_distance
    }
    fn h_f_damping_distance_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.h_f_damping_distance
    }
    fn h_f_damping_obstruction(&self) -> &AudioGraphNodePort {
        &self.h_f_damping_obstruction
    }
    fn h_f_damping_obstruction_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.h_f_damping_obstruction
    }
    fn h_f_damping_occlusion(&self) -> &f32 {
        &self.h_f_damping_occlusion
    }
    fn h_f_damping_occlusion_mut(&mut self) -> &mut f32 {
        &mut self.h_f_damping_occlusion
    }
    fn h_f_damping_filter(&self) -> &LowPassFilterType {
        &self.h_f_damping_filter
    }
    fn h_f_damping_filter_mut(&mut self) -> &mut LowPassFilterType {
        &mut self.h_f_damping_filter
    }
    fn gain(&self) -> &f32 {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut f32 {
        &mut self.gain
    }
    fn main_send(&self) -> &Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &self.main_send
    }
    fn main_send_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusDataTrait>>> {
        &mut self.main_send
    }
    fn enable_hdr(&self) -> &bool {
        &self.enable_hdr
    }
    fn enable_hdr_mut(&mut self) -> &mut bool {
        &mut self.enable_hdr
    }
    fn expected_peak_amplitude(&self) -> &f32 {
        &self.expected_peak_amplitude
    }
    fn expected_peak_amplitude_mut(&mut self) -> &mut f32 {
        &mut self.expected_peak_amplitude
    }
    fn transform_source(&self) -> &OutputTransformSource {
        &self.transform_source
    }
    fn transform_source_mut(&mut self) -> &mut OutputTransformSource {
        &mut self.transform_source
    }
    fn output_name(&self) -> &String {
        &self.output_name
    }
    fn output_name_mut(&mut self) -> &mut String {
        &mut self.output_name
    }
    fn output_name_hash(&self) -> &u32 {
        &self.output_name_hash
    }
    fn output_name_hash_mut(&mut self) -> &mut u32 {
        &mut self.output_name_hash
    }
    fn low_pass_plugin(&self) -> &SoundGraphPluginRef {
        &self.low_pass_plugin
    }
    fn low_pass_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.low_pass_plugin
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        &self.vu_plugin
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.vu_plugin
    }
    fn main_send_plugin(&self) -> &SoundGraphPluginRef {
        &self.main_send_plugin
    }
    fn main_send_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.main_send_plugin
    }
    fn mix_group(&self) -> &Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &self.mix_group
    }
    fn mix_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn MixGroupTrait>>> {
        &mut self.mix_group
    }
    fn version(&self) -> &OutputNodeVersion {
        &self.version
    }
    fn version_mut(&mut self) -> &mut OutputNodeVersion {
        &mut self.version
    }
}

impl AudioGraphNodeDataTrait for OutputNodeData {
}

impl super::core::DataContainerTrait for OutputNodeData {
}

pub static OUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<OutputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OutputNodeData, r#in),
            },
            FieldInfoData {
                name: "BypassHeadroom",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OutputNodeData, bypass_headroom),
            },
            FieldInfoData {
                name: "MinDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeData, min_distance),
            },
            FieldInfoData {
                name: "AttenuationCurve",
                flags: MemberInfoFlags::new(0),
                field_type: "FloatCurve",
                rust_offset: offset_of!(OutputNodeData, attenuation_curve),
            },
            FieldInfoData {
                name: "Solo",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutputNodeData, solo),
            },
            FieldInfoData {
                name: "HFDampingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OutputNodeData, h_f_damping_distance),
            },
            FieldInfoData {
                name: "HFDampingObstruction",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(OutputNodeData, h_f_damping_obstruction),
            },
            FieldInfoData {
                name: "HFDampingOcclusion",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeData, h_f_damping_occlusion),
            },
            FieldInfoData {
                name: "HFDampingFilter",
                flags: MemberInfoFlags::new(0),
                field_type: "LowPassFilterType",
                rust_offset: offset_of!(OutputNodeData, h_f_damping_filter),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeData, gain),
            },
            FieldInfoData {
                name: "MainSend",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusData",
                rust_offset: offset_of!(OutputNodeData, main_send),
            },
            FieldInfoData {
                name: "EnableHdr",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(OutputNodeData, enable_hdr),
            },
            FieldInfoData {
                name: "ExpectedPeakAmplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(OutputNodeData, expected_peak_amplitude),
            },
            FieldInfoData {
                name: "TransformSource",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputTransformSource",
                rust_offset: offset_of!(OutputNodeData, transform_source),
            },
            FieldInfoData {
                name: "OutputName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(OutputNodeData, output_name),
            },
            FieldInfoData {
                name: "OutputNameHash",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(OutputNodeData, output_name_hash),
            },
            FieldInfoData {
                name: "LowPassPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(OutputNodeData, low_pass_plugin),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(OutputNodeData, vu_plugin),
            },
            FieldInfoData {
                name: "MainSendPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(OutputNodeData, main_send_plugin),
            },
            FieldInfoData {
                name: "MixGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "MixGroup",
                rust_offset: offset_of!(OutputNodeData, mix_group),
            },
            FieldInfoData {
                name: "Version",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputNodeVersion",
                rust_offset: offset_of!(OutputNodeData, version),
            },
        ],
    }),
    array_type: Some(OUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for OutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        OUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum OutputNodeVersion {
    #[default]
    OutputNodeVersion_2010_2 = 0,
    OutputNodeVersion_2016_1 = 1,
}

pub static OUTPUTNODEVERSION_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeVersion",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(OUTPUTNODEVERSION_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OutputNodeVersion {
    fn type_info(&self) -> &'static TypeInfo {
        OUTPUTNODEVERSION_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static OUTPUTNODEVERSION_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputNodeVersion-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputNodeVersion"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum LowPassFilterType {
    #[default]
    LowPassFilterType_None = 0,
    LowPassFilterType_IIR2 = 1,
    LowPassFilterType_Butterworth_Order1 = 2,
    LowPassFilterType_Butterworth_Order2 = 3,
    LowPassFilterType_Butterworth_Order3 = 4,
    LowPassFilterType_Butterworth_Order4 = 5,
}

pub static LOWPASSFILTERTYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFilterType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LOWPASSFILTERTYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LowPassFilterType {
    fn type_info(&self) -> &'static TypeInfo {
        LOWPASSFILTERTYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LOWPASSFILTERTYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFilterType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassFilterType"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum OutputTransformSource {
    #[default]
    OutputTransformSource_Sound = 0,
    OutputTransformSource_Listener = 1,
    OutputTransformSource_Output = 2,
}

pub static OUTPUTTRANSFORMSOURCE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputTransformSource",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(OUTPUTTRANSFORMSOURCE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for OutputTransformSource {
    fn type_info(&self) -> &'static TypeInfo {
        OUTPUTTRANSFORMSOURCE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static OUTPUTTRANSFORMSOURCE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "OutputTransformSource-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("OutputTransformSource"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectsNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub enable: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub is_object_audio_supported: AudioGraphNodePort,
    pub max_object_count: u32,
    pub bed_clamping_distance: f32,
    pub default_object_patch: Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>,
}

pub trait ObjectsNodeDataTrait: AudioGraphNodeDataTrait {
    fn enable(&self) -> &AudioGraphNodePort;
    fn enable_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn is_object_audio_supported(&self) -> &AudioGraphNodePort;
    fn is_object_audio_supported_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_object_count(&self) -> &u32;
    fn max_object_count_mut(&mut self) -> &mut u32;
    fn bed_clamping_distance(&self) -> &f32;
    fn bed_clamping_distance_mut(&mut self) -> &mut f32;
    fn default_object_patch(&self) -> &Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>;
    fn default_object_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>>;
}

impl ObjectsNodeDataTrait for ObjectsNodeData {
    fn enable(&self) -> &AudioGraphNodePort {
        &self.enable
    }
    fn enable_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.enable
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn is_object_audio_supported(&self) -> &AudioGraphNodePort {
        &self.is_object_audio_supported
    }
    fn is_object_audio_supported_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.is_object_audio_supported
    }
    fn max_object_count(&self) -> &u32 {
        &self.max_object_count
    }
    fn max_object_count_mut(&mut self) -> &mut u32 {
        &mut self.max_object_count
    }
    fn bed_clamping_distance(&self) -> &f32 {
        &self.bed_clamping_distance
    }
    fn bed_clamping_distance_mut(&mut self) -> &mut f32 {
        &mut self.bed_clamping_distance
    }
    fn default_object_patch(&self) -> &Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>> {
        &self.default_object_patch
    }
    fn default_object_patch_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundBusPatchAssetTrait>>> {
        &mut self.default_object_patch
    }
}

impl AudioGraphNodeDataTrait for ObjectsNodeData {
}

impl super::core::DataContainerTrait for ObjectsNodeData {
}

pub static OBJECTSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectsNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectsNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Enable",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectsNodeData, enable),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectsNodeData, amplitude),
            },
            FieldInfoData {
                name: "IsObjectAudioSupported",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectsNodeData, is_object_audio_supported),
            },
            FieldInfoData {
                name: "MaxObjectCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(ObjectsNodeData, max_object_count),
            },
            FieldInfoData {
                name: "BedClampingDistance",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ObjectsNodeData, bed_clamping_distance),
            },
            FieldInfoData {
                name: "DefaultObjectPatch",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundBusPatchAsset",
                rust_offset: offset_of!(ObjectsNodeData, default_object_patch),
            },
        ],
    }),
    array_type: Some(OBJECTSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectsNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTSNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectsNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectsNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ObjectNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub vu_plugin: SoundGraphPluginRef,
    pub object_plugin: SoundGraphPluginRef,
}

pub trait ObjectNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn vu_plugin(&self) -> &SoundGraphPluginRef;
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn object_plugin(&self) -> &SoundGraphPluginRef;
    fn object_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl ObjectNodeDataTrait for ObjectNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        &self.vu_plugin
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.vu_plugin
    }
    fn object_plugin(&self) -> &SoundGraphPluginRef {
        &self.object_plugin
    }
    fn object_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.object_plugin
    }
}

impl AudioGraphNodeDataTrait for ObjectNodeData {
}

impl super::core::DataContainerTrait for ObjectNodeData {
}

pub static OBJECTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ObjectNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ObjectNodeData, r#in),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ObjectNodeData, vu_plugin),
            },
            FieldInfoData {
                name: "ObjectPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ObjectNodeData, object_plugin),
            },
        ],
    }),
    array_type: Some(OBJECTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ObjectNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        OBJECTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static OBJECTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ObjectNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ObjectNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub entries: Vec<Option<Arc<Mutex<dyn MixerEntryTrait>>>>,
    pub out: AudioGraphNodePort,
}

pub trait MixerNodeDataTrait: AudioGraphNodeDataTrait {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerEntryTrait>>>>;
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerEntryTrait>>>>;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl MixerNodeDataTrait for MixerNodeData {
    fn entries(&self) -> &Vec<Option<Arc<Mutex<dyn MixerEntryTrait>>>> {
        &self.entries
    }
    fn entries_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MixerEntryTrait>>>> {
        &mut self.entries
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
}

impl AudioGraphNodeDataTrait for MixerNodeData {
}

impl super::core::DataContainerTrait for MixerNodeData {
}

pub static MIXERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Entries",
                flags: MemberInfoFlags::new(144),
                field_type: "MixerEntry-Array",
                rust_offset: offset_of!(MixerNodeData, entries),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerNodeData, out),
            },
        ],
    }),
    array_type: Some(MIXERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MixerEntry {
    pub _glacier_base: AudioGraphNodePortGroup,
    pub r#in: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait MixerEntryTrait: AudioGraphNodePortGroupTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl MixerEntryTrait for MixerEntry {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodePortGroupTrait for MixerEntry {
}

impl super::core::DataContainerTrait for MixerEntry {
}

pub static MIXERENTRY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntry",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEPORTGROUP_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MixerEntry as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerEntry, r#in),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MixerEntry, amplitude),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(MixerEntry, plugin),
            },
        ],
    }),
    array_type: Some(MIXERENTRY_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MixerEntry {
    fn type_info(&self) -> &'static TypeInfo {
        MIXERENTRY_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MIXERENTRY_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MixerEntry-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MixerEntry"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MatrixPannerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub front_left: AudioGraphNodePort,
    pub center: AudioGraphNodePort,
    pub front_right: AudioGraphNodePort,
    pub rear_left: AudioGraphNodePort,
    pub lfe: AudioGraphNodePort,
    pub rear_right: AudioGraphNodePort,
    pub far_rear_left: AudioGraphNodePort,
    pub far_rear_right: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub output_channel_count: MatrixPannerOutputChannelCount,
}

pub trait MatrixPannerNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn front_left(&self) -> &AudioGraphNodePort;
    fn front_left_mut(&mut self) -> &mut AudioGraphNodePort;
    fn center(&self) -> &AudioGraphNodePort;
    fn center_mut(&mut self) -> &mut AudioGraphNodePort;
    fn front_right(&self) -> &AudioGraphNodePort;
    fn front_right_mut(&mut self) -> &mut AudioGraphNodePort;
    fn rear_left(&self) -> &AudioGraphNodePort;
    fn rear_left_mut(&mut self) -> &mut AudioGraphNodePort;
    fn lfe(&self) -> &AudioGraphNodePort;
    fn lfe_mut(&mut self) -> &mut AudioGraphNodePort;
    fn rear_right(&self) -> &AudioGraphNodePort;
    fn rear_right_mut(&mut self) -> &mut AudioGraphNodePort;
    fn far_rear_left(&self) -> &AudioGraphNodePort;
    fn far_rear_left_mut(&mut self) -> &mut AudioGraphNodePort;
    fn far_rear_right(&self) -> &AudioGraphNodePort;
    fn far_rear_right_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output_channel_count(&self) -> &MatrixPannerOutputChannelCount;
    fn output_channel_count_mut(&mut self) -> &mut MatrixPannerOutputChannelCount;
}

impl MatrixPannerNodeDataTrait for MatrixPannerNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn front_left(&self) -> &AudioGraphNodePort {
        &self.front_left
    }
    fn front_left_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.front_left
    }
    fn center(&self) -> &AudioGraphNodePort {
        &self.center
    }
    fn center_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.center
    }
    fn front_right(&self) -> &AudioGraphNodePort {
        &self.front_right
    }
    fn front_right_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.front_right
    }
    fn rear_left(&self) -> &AudioGraphNodePort {
        &self.rear_left
    }
    fn rear_left_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.rear_left
    }
    fn lfe(&self) -> &AudioGraphNodePort {
        &self.lfe
    }
    fn lfe_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.lfe
    }
    fn rear_right(&self) -> &AudioGraphNodePort {
        &self.rear_right
    }
    fn rear_right_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.rear_right
    }
    fn far_rear_left(&self) -> &AudioGraphNodePort {
        &self.far_rear_left
    }
    fn far_rear_left_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.far_rear_left
    }
    fn far_rear_right(&self) -> &AudioGraphNodePort {
        &self.far_rear_right
    }
    fn far_rear_right_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.far_rear_right
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn output_channel_count(&self) -> &MatrixPannerOutputChannelCount {
        &self.output_channel_count
    }
    fn output_channel_count_mut(&mut self) -> &mut MatrixPannerOutputChannelCount {
        &mut self.output_channel_count
    }
}

impl AudioGraphNodeDataTrait for MatrixPannerNodeData {
}

impl super::core::DataContainerTrait for MatrixPannerNodeData {
}

pub static MATRIXPANNERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MatrixPannerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, r#in),
            },
            FieldInfoData {
                name: "FrontLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, front_left),
            },
            FieldInfoData {
                name: "Center",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, center),
            },
            FieldInfoData {
                name: "FrontRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, front_right),
            },
            FieldInfoData {
                name: "RearLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, rear_left),
            },
            FieldInfoData {
                name: "Lfe",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, lfe),
            },
            FieldInfoData {
                name: "RearRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, rear_right),
            },
            FieldInfoData {
                name: "FarRearLeft",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, far_rear_left),
            },
            FieldInfoData {
                name: "FarRearRight",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, far_rear_right),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MatrixPannerNodeData, out),
            },
            FieldInfoData {
                name: "OutputChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "MatrixPannerOutputChannelCount",
                rust_offset: offset_of!(MatrixPannerNodeData, output_channel_count),
            },
        ],
    }),
    array_type: Some(MATRIXPANNERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MatrixPannerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MATRIXPANNERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MATRIXPANNERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MatrixPannerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum MatrixPannerOutputChannelCount {
    #[default]
    MatrixPannerOutputChannelCount_Two = 0,
    MatrixPannerOutputChannelCount_Four = 1,
    MatrixPannerOutputChannelCount_Six = 2,
    MatrixPannerOutputChannelCount_Eight = 3,
}

pub static MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerOutputChannelCount",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(MATRIXPANNEROUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for MatrixPannerOutputChannelCount {
    fn type_info(&self) -> &'static TypeInfo {
        MATRIXPANNEROUTPUTCHANNELCOUNT_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static MATRIXPANNEROUTPUTCHANNELCOUNT_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MatrixPannerOutputChannelCount-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MatrixPannerOutputChannelCount"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct MasterUnitNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub settings_index: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub master_gain: AudioGraphNodePort,
    pub master_lfe_gain: AudioGraphNodePort,
    pub master_dialog_gain: AudioGraphNodePort,
    pub main_mix_gain: AudioGraphNodePort,
    pub post_effects_gain: AudioGraphNodePort,
    pub reverb_gain: AudioGraphNodePort,
    pub fade_time: AudioGraphNodePort,
    pub high_pass_freq: AudioGraphNodePort,
    pub low_shelf_freq: AudioGraphNodePort,
    pub low_shelf_gain: AudioGraphNodePort,
    pub high_shelf_freq: AudioGraphNodePort,
    pub high_shelf_gain: AudioGraphNodePort,
    pub comp_threshold: AudioGraphNodePort,
    pub comp_ratio: AudioGraphNodePort,
    pub comp_attack: AudioGraphNodePort,
    pub comp_release: AudioGraphNodePort,
    pub dist_clip_level: AudioGraphNodePort,
    pub parallel_distortion_gain: AudioGraphNodePort,
    pub settings: Vec<Option<Arc<Mutex<dyn MasterUnitSettingsTrait>>>>,
}

pub trait MasterUnitNodeDataTrait: AudioGraphNodeDataTrait {
    fn settings_index(&self) -> &AudioGraphNodePort;
    fn settings_index_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn master_gain(&self) -> &AudioGraphNodePort;
    fn master_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn master_lfe_gain(&self) -> &AudioGraphNodePort;
    fn master_lfe_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn master_dialog_gain(&self) -> &AudioGraphNodePort;
    fn master_dialog_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn main_mix_gain(&self) -> &AudioGraphNodePort;
    fn main_mix_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn post_effects_gain(&self) -> &AudioGraphNodePort;
    fn post_effects_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn reverb_gain(&self) -> &AudioGraphNodePort;
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn fade_time(&self) -> &AudioGraphNodePort;
    fn fade_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn high_pass_freq(&self) -> &AudioGraphNodePort;
    fn high_pass_freq_mut(&mut self) -> &mut AudioGraphNodePort;
    fn low_shelf_freq(&self) -> &AudioGraphNodePort;
    fn low_shelf_freq_mut(&mut self) -> &mut AudioGraphNodePort;
    fn low_shelf_gain(&self) -> &AudioGraphNodePort;
    fn low_shelf_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn high_shelf_freq(&self) -> &AudioGraphNodePort;
    fn high_shelf_freq_mut(&mut self) -> &mut AudioGraphNodePort;
    fn high_shelf_gain(&self) -> &AudioGraphNodePort;
    fn high_shelf_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn comp_threshold(&self) -> &AudioGraphNodePort;
    fn comp_threshold_mut(&mut self) -> &mut AudioGraphNodePort;
    fn comp_ratio(&self) -> &AudioGraphNodePort;
    fn comp_ratio_mut(&mut self) -> &mut AudioGraphNodePort;
    fn comp_attack(&self) -> &AudioGraphNodePort;
    fn comp_attack_mut(&mut self) -> &mut AudioGraphNodePort;
    fn comp_release(&self) -> &AudioGraphNodePort;
    fn comp_release_mut(&mut self) -> &mut AudioGraphNodePort;
    fn dist_clip_level(&self) -> &AudioGraphNodePort;
    fn dist_clip_level_mut(&mut self) -> &mut AudioGraphNodePort;
    fn parallel_distortion_gain(&self) -> &AudioGraphNodePort;
    fn parallel_distortion_gain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn settings(&self) -> &Vec<Option<Arc<Mutex<dyn MasterUnitSettingsTrait>>>>;
    fn settings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MasterUnitSettingsTrait>>>>;
}

impl MasterUnitNodeDataTrait for MasterUnitNodeData {
    fn settings_index(&self) -> &AudioGraphNodePort {
        &self.settings_index
    }
    fn settings_index_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.settings_index
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn master_gain(&self) -> &AudioGraphNodePort {
        &self.master_gain
    }
    fn master_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.master_gain
    }
    fn master_lfe_gain(&self) -> &AudioGraphNodePort {
        &self.master_lfe_gain
    }
    fn master_lfe_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.master_lfe_gain
    }
    fn master_dialog_gain(&self) -> &AudioGraphNodePort {
        &self.master_dialog_gain
    }
    fn master_dialog_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.master_dialog_gain
    }
    fn main_mix_gain(&self) -> &AudioGraphNodePort {
        &self.main_mix_gain
    }
    fn main_mix_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.main_mix_gain
    }
    fn post_effects_gain(&self) -> &AudioGraphNodePort {
        &self.post_effects_gain
    }
    fn post_effects_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.post_effects_gain
    }
    fn reverb_gain(&self) -> &AudioGraphNodePort {
        &self.reverb_gain
    }
    fn reverb_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.reverb_gain
    }
    fn fade_time(&self) -> &AudioGraphNodePort {
        &self.fade_time
    }
    fn fade_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.fade_time
    }
    fn high_pass_freq(&self) -> &AudioGraphNodePort {
        &self.high_pass_freq
    }
    fn high_pass_freq_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.high_pass_freq
    }
    fn low_shelf_freq(&self) -> &AudioGraphNodePort {
        &self.low_shelf_freq
    }
    fn low_shelf_freq_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.low_shelf_freq
    }
    fn low_shelf_gain(&self) -> &AudioGraphNodePort {
        &self.low_shelf_gain
    }
    fn low_shelf_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.low_shelf_gain
    }
    fn high_shelf_freq(&self) -> &AudioGraphNodePort {
        &self.high_shelf_freq
    }
    fn high_shelf_freq_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.high_shelf_freq
    }
    fn high_shelf_gain(&self) -> &AudioGraphNodePort {
        &self.high_shelf_gain
    }
    fn high_shelf_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.high_shelf_gain
    }
    fn comp_threshold(&self) -> &AudioGraphNodePort {
        &self.comp_threshold
    }
    fn comp_threshold_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.comp_threshold
    }
    fn comp_ratio(&self) -> &AudioGraphNodePort {
        &self.comp_ratio
    }
    fn comp_ratio_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.comp_ratio
    }
    fn comp_attack(&self) -> &AudioGraphNodePort {
        &self.comp_attack
    }
    fn comp_attack_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.comp_attack
    }
    fn comp_release(&self) -> &AudioGraphNodePort {
        &self.comp_release
    }
    fn comp_release_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.comp_release
    }
    fn dist_clip_level(&self) -> &AudioGraphNodePort {
        &self.dist_clip_level
    }
    fn dist_clip_level_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.dist_clip_level
    }
    fn parallel_distortion_gain(&self) -> &AudioGraphNodePort {
        &self.parallel_distortion_gain
    }
    fn parallel_distortion_gain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.parallel_distortion_gain
    }
    fn settings(&self) -> &Vec<Option<Arc<Mutex<dyn MasterUnitSettingsTrait>>>> {
        &self.settings
    }
    fn settings_mut(&mut self) -> &mut Vec<Option<Arc<Mutex<dyn MasterUnitSettingsTrait>>>> {
        &mut self.settings
    }
}

impl AudioGraphNodeDataTrait for MasterUnitNodeData {
}

impl super::core::DataContainerTrait for MasterUnitNodeData {
}

pub static MASTERUNITNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<MasterUnitNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SettingsIndex",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, settings_index),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, amplitude),
            },
            FieldInfoData {
                name: "MasterGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, master_gain),
            },
            FieldInfoData {
                name: "MasterLfeGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, master_lfe_gain),
            },
            FieldInfoData {
                name: "MasterDialogGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, master_dialog_gain),
            },
            FieldInfoData {
                name: "MainMixGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, main_mix_gain),
            },
            FieldInfoData {
                name: "PostEffectsGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, post_effects_gain),
            },
            FieldInfoData {
                name: "ReverbGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, reverb_gain),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, fade_time),
            },
            FieldInfoData {
                name: "HighPassFreq",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, high_pass_freq),
            },
            FieldInfoData {
                name: "LowShelfFreq",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, low_shelf_freq),
            },
            FieldInfoData {
                name: "LowShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, low_shelf_gain),
            },
            FieldInfoData {
                name: "HighShelfFreq",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, high_shelf_freq),
            },
            FieldInfoData {
                name: "HighShelfGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, high_shelf_gain),
            },
            FieldInfoData {
                name: "CompThreshold",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, comp_threshold),
            },
            FieldInfoData {
                name: "CompRatio",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, comp_ratio),
            },
            FieldInfoData {
                name: "CompAttack",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, comp_attack),
            },
            FieldInfoData {
                name: "CompRelease",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, comp_release),
            },
            FieldInfoData {
                name: "DistClipLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, dist_clip_level),
            },
            FieldInfoData {
                name: "ParallelDistortionGain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(MasterUnitNodeData, parallel_distortion_gain),
            },
            FieldInfoData {
                name: "Settings",
                flags: MemberInfoFlags::new(144),
                field_type: "MasterUnitSettings-Array",
                rust_offset: offset_of!(MasterUnitNodeData, settings),
            },
        ],
    }),
    array_type: Some(MASTERUNITNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for MasterUnitNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        MASTERUNITNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static MASTERUNITNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "MasterUnitNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("MasterUnitNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LowShelfIir2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait LowShelfIir2NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl LowShelfIir2NodeDataTrait for LowShelfIir2NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for LowShelfIir2NodeData {
}

impl super::core::DataContainerTrait for LowShelfIir2NodeData {
}

pub static LOWSHELFIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowShelfIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LowShelfIir2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowShelfIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowShelfIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowShelfIir2NodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowShelfIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(LowShelfIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWSHELFIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowShelfIir2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LOWSHELFIIR2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOWSHELFIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowShelfIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowShelfIir2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LowPassIir2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait LowPassIir2NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl LowPassIir2NodeDataTrait for LowPassIir2NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for LowPassIir2NodeData {
}

impl super::core::DataContainerTrait for LowPassIir2NodeData {
}

pub static LOWPASSIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LowPassIir2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(LowPassIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWPASSIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowPassIir2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LOWPASSIIR2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOWPASSIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassIir2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LowPassFir64NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait LowPassFir64NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl LowPassFir64NodeDataTrait for LowPassFir64NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for LowPassFir64NodeData {
}

impl super::core::DataContainerTrait for LowPassFir64NodeData {
}

pub static LOWPASSFIR64NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFir64NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LowPassFir64NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassFir64NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassFir64NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassFir64NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(LowPassFir64NodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWPASSFIR64NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowPassFir64NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LOWPASSFIR64NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOWPASSFIR64NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassFir64NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassFir64NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LowPassButterworthNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub order: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait LowPassButterworthNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn order(&self) -> &AudioGraphNodePort;
    fn order_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl LowPassButterworthNodeDataTrait for LowPassButterworthNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn order(&self) -> &AudioGraphNodePort {
        &self.order
    }
    fn order_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.order
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for LowPassButterworthNodeData {
}

impl super::core::DataContainerTrait for LowPassButterworthNodeData {
}

pub static LOWPASSBUTTERWORTHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassButterworthNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LowPassButterworthNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassButterworthNodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassButterworthNodeData, frequency),
            },
            FieldInfoData {
                name: "Order",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassButterworthNodeData, order),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LowPassButterworthNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(LowPassButterworthNodeData, plugin),
            },
        ],
    }),
    array_type: Some(LOWPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LowPassButterworthNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LOWPASSBUTTERWORTHNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LOWPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LowPassButterworthNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LowPassButterworthNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct LimiterNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub sidechain: AudioGraphNodePort,
    pub threshold: AudioGraphNodePort,
    pub release_time: AudioGraphNodePort,
    pub use_sidechain: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub channel_mode: LimiterChannelMode,
    pub plugin: SoundGraphPluginRef,
}

pub trait LimiterNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn sidechain(&self) -> &AudioGraphNodePort;
    fn sidechain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn threshold(&self) -> &AudioGraphNodePort;
    fn threshold_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release_time(&self) -> &AudioGraphNodePort;
    fn release_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn use_sidechain(&self) -> &AudioGraphNodePort;
    fn use_sidechain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn channel_mode(&self) -> &LimiterChannelMode;
    fn channel_mode_mut(&mut self) -> &mut LimiterChannelMode;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl LimiterNodeDataTrait for LimiterNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn sidechain(&self) -> &AudioGraphNodePort {
        &self.sidechain
    }
    fn sidechain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.sidechain
    }
    fn threshold(&self) -> &AudioGraphNodePort {
        &self.threshold
    }
    fn threshold_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.threshold
    }
    fn release_time(&self) -> &AudioGraphNodePort {
        &self.release_time
    }
    fn release_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release_time
    }
    fn use_sidechain(&self) -> &AudioGraphNodePort {
        &self.use_sidechain
    }
    fn use_sidechain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.use_sidechain
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn channel_mode(&self) -> &LimiterChannelMode {
        &self.channel_mode
    }
    fn channel_mode_mut(&mut self) -> &mut LimiterChannelMode {
        &mut self.channel_mode
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for LimiterNodeData {
}

impl super::core::DataContainerTrait for LimiterNodeData {
}

pub static LIMITERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<LimiterNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LimiterNodeData, r#in),
            },
            FieldInfoData {
                name: "Sidechain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LimiterNodeData, sidechain),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LimiterNodeData, threshold),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LimiterNodeData, release_time),
            },
            FieldInfoData {
                name: "UseSidechain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LimiterNodeData, use_sidechain),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(LimiterNodeData, out),
            },
            FieldInfoData {
                name: "ChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: "LimiterChannelMode",
                rust_offset: offset_of!(LimiterNodeData, channel_mode),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(LimiterNodeData, plugin),
            },
        ],
    }),
    array_type: Some(LIMITERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for LimiterNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        LIMITERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static LIMITERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LimiterNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum LimiterChannelMode {
    #[default]
    LimiterChannelMode_Independent = 0,
    LimiterChannelMode_Grouped = 1,
}

pub static LIMITERCHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(LIMITERCHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for LimiterChannelMode {
    fn type_info(&self) -> &'static TypeInfo {
        LIMITERCHANNELMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static LIMITERCHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "LimiterChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("LimiterChannelMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HighShelfIir2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait HighShelfIir2NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl HighShelfIir2NodeDataTrait for HighShelfIir2NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for HighShelfIir2NodeData {
}

impl super::core::DataContainerTrait for HighShelfIir2NodeData {
}

pub static HIGHSHELFIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighShelfIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighShelfIir2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighShelfIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighShelfIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighShelfIir2NodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighShelfIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(HighShelfIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHSHELFIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighShelfIir2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHSHELFIIR2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIGHSHELFIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighShelfIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighShelfIir2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HighPassIir2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait HighPassIir2NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl HighPassIir2NodeDataTrait for HighPassIir2NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for HighPassIir2NodeData {
}

impl super::core::DataContainerTrait for HighPassIir2NodeData {
}

pub static HIGHPASSIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighPassIir2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(HighPassIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHPASSIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighPassIir2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHPASSIIR2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIGHPASSIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighPassIir2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HighPassFir64NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait HighPassFir64NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl HighPassFir64NodeDataTrait for HighPassFir64NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for HighPassFir64NodeData {
}

impl super::core::DataContainerTrait for HighPassFir64NodeData {
}

pub static HIGHPASSFIR64NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassFir64NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighPassFir64NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassFir64NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassFir64NodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassFir64NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(HighPassFir64NodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHPASSFIR64NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighPassFir64NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHPASSFIR64NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIGHPASSFIR64NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassFir64NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighPassFir64NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct HighPassButterworthNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub order: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait HighPassButterworthNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn order(&self) -> &AudioGraphNodePort;
    fn order_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl HighPassButterworthNodeDataTrait for HighPassButterworthNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn order(&self) -> &AudioGraphNodePort {
        &self.order
    }
    fn order_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.order
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for HighPassButterworthNodeData {
}

impl super::core::DataContainerTrait for HighPassButterworthNodeData {
}

pub static HIGHPASSBUTTERWORTHNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassButterworthNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<HighPassButterworthNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassButterworthNodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassButterworthNodeData, frequency),
            },
            FieldInfoData {
                name: "Order",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassButterworthNodeData, order),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(HighPassButterworthNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(HighPassButterworthNodeData, plugin),
            },
        ],
    }),
    array_type: Some(HIGHPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for HighPassButterworthNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        HIGHPASSBUTTERWORTHNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static HIGHPASSBUTTERWORTHNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "HighPassButterworthNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("HighPassButterworthNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct SinePlayerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub channel_count: u32,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait SinePlayerNodeDataTrait: AudioGraphNodeDataTrait {
    fn channel_count(&self) -> &u32;
    fn channel_count_mut(&mut self) -> &mut u32;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl SinePlayerNodeDataTrait for SinePlayerNodeData {
    fn channel_count(&self) -> &u32 {
        &self.channel_count
    }
    fn channel_count_mut(&mut self) -> &mut u32 {
        &mut self.channel_count
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for SinePlayerNodeData {
}

impl super::core::DataContainerTrait for SinePlayerNodeData {
}

pub static SINEPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SinePlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<SinePlayerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ChannelCount",
                flags: MemberInfoFlags::new(0),
                field_type: "Uint32",
                rust_offset: offset_of!(SinePlayerNodeData, channel_count),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SinePlayerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SinePlayerNodeData, stop),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SinePlayerNodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(SinePlayerNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(SinePlayerNodeData, plugin),
            },
        ],
    }),
    array_type: Some(SINEPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for SinePlayerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        SINEPLAYERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static SINEPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "SinePlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("SinePlayerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GainFaderNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub start_time: AudioGraphNodePort,
    pub fade_time: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub fade_type: GainFaderFadeType,
    pub plugin: SoundGraphPluginRef,
}

pub trait GainFaderNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn start_time(&self) -> &AudioGraphNodePort;
    fn start_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn fade_time(&self) -> &AudioGraphNodePort;
    fn fade_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn fade_type(&self) -> &GainFaderFadeType;
    fn fade_type_mut(&mut self) -> &mut GainFaderFadeType;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl GainFaderNodeDataTrait for GainFaderNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn start_time(&self) -> &AudioGraphNodePort {
        &self.start_time
    }
    fn start_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start_time
    }
    fn fade_time(&self) -> &AudioGraphNodePort {
        &self.fade_time
    }
    fn fade_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.fade_time
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn fade_type(&self) -> &GainFaderFadeType {
        &self.fade_type
    }
    fn fade_type_mut(&mut self) -> &mut GainFaderFadeType {
        &mut self.fade_type
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for GainFaderNodeData {
}

impl super::core::DataContainerTrait for GainFaderNodeData {
}

pub static GAINFADERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GainFaderNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainFaderNodeData, r#in),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainFaderNodeData, start),
            },
            FieldInfoData {
                name: "StartTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainFaderNodeData, start_time),
            },
            FieldInfoData {
                name: "FadeTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainFaderNodeData, fade_time),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainFaderNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainFaderNodeData, out),
            },
            FieldInfoData {
                name: "FadeType",
                flags: MemberInfoFlags::new(0),
                field_type: "GainFaderFadeType",
                rust_offset: offset_of!(GainFaderNodeData, fade_type),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(GainFaderNodeData, plugin),
            },
        ],
    }),
    array_type: Some(GAINFADERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GainFaderNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        GAINFADERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAINFADERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("GainFaderNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum GainFaderFadeType {
    #[default]
    GainFaderFadeType_LinearAmplitude = 0,
    GainFaderFadeType_LinearPower = 1,
    GainFaderFadeType_SineAmplitude = 2,
}

pub static GAINFADERFADETYPE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderFadeType",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(GAINFADERFADETYPE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for GainFaderFadeType {
    fn type_info(&self) -> &'static TypeInfo {
        GAINFADERFADETYPE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static GAINFADERFADETYPE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainFaderFadeType-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("GainFaderFadeType"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct GainNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait GainNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl GainNodeDataTrait for GainNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for GainNodeData {
}

impl super::core::DataContainerTrait for GainNodeData {
}

pub static GAINNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<GainNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainNodeData, r#in),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(GainNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(GainNodeData, plugin),
            },
        ],
    }),
    array_type: Some(GAINNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for GainNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        GAINNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static GAINNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "GainNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("GainNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FrequencyShiftSsbNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub filter: FrequencyShiftSsbFilter,
    pub plugin: SoundGraphPluginRef,
}

pub trait FrequencyShiftSsbNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn filter(&self) -> &FrequencyShiftSsbFilter;
    fn filter_mut(&mut self) -> &mut FrequencyShiftSsbFilter;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl FrequencyShiftSsbNodeDataTrait for FrequencyShiftSsbNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn filter(&self) -> &FrequencyShiftSsbFilter {
        &self.filter
    }
    fn filter_mut(&mut self) -> &mut FrequencyShiftSsbFilter {
        &mut self.filter
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for FrequencyShiftSsbNodeData {
}

impl super::core::DataContainerTrait for FrequencyShiftSsbNodeData {
}

pub static FREQUENCYSHIFTSSBNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FrequencyShiftSsbNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, frequency),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, out),
            },
            FieldInfoData {
                name: "Filter",
                flags: MemberInfoFlags::new(0),
                field_type: "FrequencyShiftSsbFilter",
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, filter),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(FrequencyShiftSsbNodeData, plugin),
            },
        ],
    }),
    array_type: Some(FREQUENCYSHIFTSSBNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FrequencyShiftSsbNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        FREQUENCYSHIFTSSBNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FREQUENCYSHIFTSSBNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FrequencyShiftSsbNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum FrequencyShiftSsbFilter {
    #[default]
    FrequencyShiftSsbFilter_None = 0,
    FrequencyShiftSsbFilter_Fir64 = 1,
}

pub static FREQUENCYSHIFTSSBFILTER_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbFilter",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(FREQUENCYSHIFTSSBFILTER_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for FrequencyShiftSsbFilter {
    fn type_info(&self) -> &'static TypeInfo {
        FREQUENCYSHIFTSSBFILTER_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static FREQUENCYSHIFTSSBFILTER_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FrequencyShiftSsbFilter-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FrequencyShiftSsbFilter"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct FlangerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub max_delay: f32,
    pub max_modulation_depth: f32,
    pub delay_time: AudioGraphNodePort,
    pub modulation_depth: AudioGraphNodePort,
    pub modulation_frequency: AudioGraphNodePort,
}

pub trait FlangerNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn max_delay(&self) -> &f32;
    fn max_delay_mut(&mut self) -> &mut f32;
    fn max_modulation_depth(&self) -> &f32;
    fn max_modulation_depth_mut(&mut self) -> &mut f32;
    fn delay_time(&self) -> &AudioGraphNodePort;
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn modulation_depth(&self) -> &AudioGraphNodePort;
    fn modulation_depth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn modulation_frequency(&self) -> &AudioGraphNodePort;
    fn modulation_frequency_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl FlangerNodeDataTrait for FlangerNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn max_delay(&self) -> &f32 {
        &self.max_delay
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        &mut self.max_delay
    }
    fn max_modulation_depth(&self) -> &f32 {
        &self.max_modulation_depth
    }
    fn max_modulation_depth_mut(&mut self) -> &mut f32 {
        &mut self.max_modulation_depth
    }
    fn delay_time(&self) -> &AudioGraphNodePort {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay_time
    }
    fn modulation_depth(&self) -> &AudioGraphNodePort {
        &self.modulation_depth
    }
    fn modulation_depth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.modulation_depth
    }
    fn modulation_frequency(&self) -> &AudioGraphNodePort {
        &self.modulation_frequency
    }
    fn modulation_frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.modulation_frequency
    }
}

impl AudioGraphNodeDataTrait for FlangerNodeData {
}

impl super::core::DataContainerTrait for FlangerNodeData {
}

pub static FLANGERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlangerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<FlangerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlangerNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlangerNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(FlangerNodeData, plugin),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlangerNodeData, max_delay),
            },
            FieldInfoData {
                name: "MaxModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(FlangerNodeData, max_modulation_depth),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlangerNodeData, delay_time),
            },
            FieldInfoData {
                name: "ModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlangerNodeData, modulation_depth),
            },
            FieldInfoData {
                name: "ModulationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(FlangerNodeData, modulation_frequency),
            },
        ],
    }),
    array_type: Some(FLANGERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for FlangerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        FLANGERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static FLANGERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "FlangerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("FlangerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct EnvironmentNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub obstruction_value: AudioGraphNodePort,
    pub occlusion_factor: AudioGraphNodePort,
}

pub trait EnvironmentNodeDataTrait: AudioGraphNodeDataTrait {
    fn obstruction_value(&self) -> &AudioGraphNodePort;
    fn obstruction_value_mut(&mut self) -> &mut AudioGraphNodePort;
    fn occlusion_factor(&self) -> &AudioGraphNodePort;
    fn occlusion_factor_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl EnvironmentNodeDataTrait for EnvironmentNodeData {
    fn obstruction_value(&self) -> &AudioGraphNodePort {
        &self.obstruction_value
    }
    fn obstruction_value_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.obstruction_value
    }
    fn occlusion_factor(&self) -> &AudioGraphNodePort {
        &self.occlusion_factor
    }
    fn occlusion_factor_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.occlusion_factor
    }
}

impl AudioGraphNodeDataTrait for EnvironmentNodeData {
}

impl super::core::DataContainerTrait for EnvironmentNodeData {
}

pub static ENVIRONMENTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnvironmentNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<EnvironmentNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "ObstructionValue",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EnvironmentNodeData, obstruction_value),
            },
            FieldInfoData {
                name: "OcclusionFactor",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(EnvironmentNodeData, occlusion_factor),
            },
        ],
    }),
    array_type: Some(ENVIRONMENTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for EnvironmentNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        ENVIRONMENTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ENVIRONMENTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "EnvironmentNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("EnvironmentNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DivisibleLoopPlayerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub freeze_segment: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub wave: Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>,
    pub selection_group: Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>,
    pub external_wave: AudioGraphNodePort,
    pub plugins: Vec<DivisibleLoopPlayerPlugins>,
    pub cross_fade_length: f32,
    pub start_at_random_position: bool,
    pub divisible_loop_player_node_debug: Option<Arc<Mutex<dyn DivisibleLoopPlayerNodeDebugDataTrait>>>,
}

pub trait DivisibleLoopPlayerNodeDataTrait: AudioGraphNodeDataTrait {
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn freeze_segment(&self) -> &AudioGraphNodePort;
    fn freeze_segment_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>>;
    fn selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>;
    fn selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>>;
    fn external_wave(&self) -> &AudioGraphNodePort;
    fn external_wave_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugins(&self) -> &Vec<DivisibleLoopPlayerPlugins>;
    fn plugins_mut(&mut self) -> &mut Vec<DivisibleLoopPlayerPlugins>;
    fn cross_fade_length(&self) -> &f32;
    fn cross_fade_length_mut(&mut self) -> &mut f32;
    fn start_at_random_position(&self) -> &bool;
    fn start_at_random_position_mut(&mut self) -> &mut bool;
    fn divisible_loop_player_node_debug(&self) -> &Option<Arc<Mutex<dyn DivisibleLoopPlayerNodeDebugDataTrait>>>;
    fn divisible_loop_player_node_debug_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DivisibleLoopPlayerNodeDebugDataTrait>>>;
}

impl DivisibleLoopPlayerNodeDataTrait for DivisibleLoopPlayerNodeData {
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn freeze_segment(&self) -> &AudioGraphNodePort {
        &self.freeze_segment
    }
    fn freeze_segment_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.freeze_segment
    }
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn wave(&self) -> &Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &self.wave
    }
    fn wave_mut(&mut self) -> &mut Option<Arc<Mutex<dyn SoundWaveAssetBaseTrait>>> {
        &mut self.wave
    }
    fn selection_group(&self) -> &Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        &self.selection_group
    }
    fn selection_group_mut(&mut self) -> &mut Option<Arc<Mutex<dyn NewWaveSelectionGroupTrait>>> {
        &mut self.selection_group
    }
    fn external_wave(&self) -> &AudioGraphNodePort {
        &self.external_wave
    }
    fn external_wave_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.external_wave
    }
    fn plugins(&self) -> &Vec<DivisibleLoopPlayerPlugins> {
        &self.plugins
    }
    fn plugins_mut(&mut self) -> &mut Vec<DivisibleLoopPlayerPlugins> {
        &mut self.plugins
    }
    fn cross_fade_length(&self) -> &f32 {
        &self.cross_fade_length
    }
    fn cross_fade_length_mut(&mut self) -> &mut f32 {
        &mut self.cross_fade_length
    }
    fn start_at_random_position(&self) -> &bool {
        &self.start_at_random_position
    }
    fn start_at_random_position_mut(&mut self) -> &mut bool {
        &mut self.start_at_random_position
    }
    fn divisible_loop_player_node_debug(&self) -> &Option<Arc<Mutex<dyn DivisibleLoopPlayerNodeDebugDataTrait>>> {
        &self.divisible_loop_player_node_debug
    }
    fn divisible_loop_player_node_debug_mut(&mut self) -> &mut Option<Arc<Mutex<dyn DivisibleLoopPlayerNodeDebugDataTrait>>> {
        &mut self.divisible_loop_player_node_debug
    }
}

impl AudioGraphNodeDataTrait for DivisibleLoopPlayerNodeData {
}

impl super::core::DataContainerTrait for DivisibleLoopPlayerNodeData {
}

pub static DIVISIBLELOOPPLAYERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DivisibleLoopPlayerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, stop),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, amplitude),
            },
            FieldInfoData {
                name: "FreezeSegment",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, freeze_segment),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, output),
            },
            FieldInfoData {
                name: "Wave",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundWaveAssetBase",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, wave),
            },
            FieldInfoData {
                name: "SelectionGroup",
                flags: MemberInfoFlags::new(0),
                field_type: "NewWaveSelectionGroup",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, selection_group),
            },
            FieldInfoData {
                name: "ExternalWave",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, external_wave),
            },
            FieldInfoData {
                name: "Plugins",
                flags: MemberInfoFlags::new(144),
                field_type: "DivisibleLoopPlayerPlugins-Array",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, plugins),
            },
            FieldInfoData {
                name: "CrossFadeLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, cross_fade_length),
            },
            FieldInfoData {
                name: "StartAtRandomPosition",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, start_at_random_position),
            },
            FieldInfoData {
                name: "DivisibleLoopPlayerNodeDebug",
                flags: MemberInfoFlags::new(0),
                field_type: "DivisibleLoopPlayerNodeDebugData",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeData, divisible_loop_player_node_debug),
            },
        ],
    }),
    array_type: Some(DIVISIBLELOOPPLAYERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DivisibleLoopPlayerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DIVISIBLELOOPPLAYERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIVISIBLELOOPPLAYERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DivisibleLoopPlayerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DivisibleLoopPlayerPlugins {
    pub snd_player: SoundGraphPluginRef,
    pub pause: SoundGraphPluginRef,
    pub gain: SoundGraphPluginRef,
    pub gain_fader: SoundGraphPluginRef,
}

pub trait DivisibleLoopPlayerPluginsTrait: TypeObject {
    fn snd_player(&self) -> &SoundGraphPluginRef;
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn pause(&self) -> &SoundGraphPluginRef;
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain(&self) -> &SoundGraphPluginRef;
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain_fader(&self) -> &SoundGraphPluginRef;
    fn gain_fader_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl DivisibleLoopPlayerPluginsTrait for DivisibleLoopPlayerPlugins {
    fn snd_player(&self) -> &SoundGraphPluginRef {
        &self.snd_player
    }
    fn snd_player_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.snd_player
    }
    fn pause(&self) -> &SoundGraphPluginRef {
        &self.pause
    }
    fn pause_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pause
    }
    fn gain(&self) -> &SoundGraphPluginRef {
        &self.gain
    }
    fn gain_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain
    }
    fn gain_fader(&self) -> &SoundGraphPluginRef {
        &self.gain_fader
    }
    fn gain_fader_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain_fader
    }
}

pub static DIVISIBLELOOPPLAYERPLUGINS_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerPlugins",
    flags: MemberInfoFlags::new(36937),
    module: "Audio",
    data: TypeInfoData::ValueType(ValueTypeInfoData {
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DivisibleLoopPlayerPlugins as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "SndPlayer",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, snd_player),
            },
            FieldInfoData {
                name: "Pause",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, pause),
            },
            FieldInfoData {
                name: "Gain",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, gain),
            },
            FieldInfoData {
                name: "GainFader",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DivisibleLoopPlayerPlugins, gain_fader),
            },
        ],
    }),
    array_type: Some(DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for DivisibleLoopPlayerPlugins {
    fn type_info(&self) -> &'static TypeInfo {
        DIVISIBLELOOPPLAYERPLUGINS_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static DIVISIBLELOOPPLAYERPLUGINS_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerPlugins-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DivisibleLoopPlayerPlugins"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DivisibleLoopPlayerNodeDebugData {
    pub _glacier_base: super::core::DataContainer,
    pub enable_debug: bool,
    pub debug_input_connections: bool,
    pub debug_text_x_pos: i32,
    pub debug_text_y_pos: i32,
    pub event_display_time: f32,
    pub divisible_loop_player_debug_info_color: super::core::Vec3,
    pub properties_debug_info_color: super::core::Vec3,
    pub events_debug_info_color: super::core::Vec3,
    pub external_wave_debug_info_color: super::core::Vec3,
    pub mute_sampler: bool,
}

pub trait DivisibleLoopPlayerNodeDebugDataTrait: super::core::DataContainerTrait {
    fn enable_debug(&self) -> &bool;
    fn enable_debug_mut(&mut self) -> &mut bool;
    fn debug_input_connections(&self) -> &bool;
    fn debug_input_connections_mut(&mut self) -> &mut bool;
    fn debug_text_x_pos(&self) -> &i32;
    fn debug_text_x_pos_mut(&mut self) -> &mut i32;
    fn debug_text_y_pos(&self) -> &i32;
    fn debug_text_y_pos_mut(&mut self) -> &mut i32;
    fn event_display_time(&self) -> &f32;
    fn event_display_time_mut(&mut self) -> &mut f32;
    fn divisible_loop_player_debug_info_color(&self) -> &super::core::Vec3;
    fn divisible_loop_player_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn properties_debug_info_color(&self) -> &super::core::Vec3;
    fn properties_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn events_debug_info_color(&self) -> &super::core::Vec3;
    fn events_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn external_wave_debug_info_color(&self) -> &super::core::Vec3;
    fn external_wave_debug_info_color_mut(&mut self) -> &mut super::core::Vec3;
    fn mute_sampler(&self) -> &bool;
    fn mute_sampler_mut(&mut self) -> &mut bool;
}

impl DivisibleLoopPlayerNodeDebugDataTrait for DivisibleLoopPlayerNodeDebugData {
    fn enable_debug(&self) -> &bool {
        &self.enable_debug
    }
    fn enable_debug_mut(&mut self) -> &mut bool {
        &mut self.enable_debug
    }
    fn debug_input_connections(&self) -> &bool {
        &self.debug_input_connections
    }
    fn debug_input_connections_mut(&mut self) -> &mut bool {
        &mut self.debug_input_connections
    }
    fn debug_text_x_pos(&self) -> &i32 {
        &self.debug_text_x_pos
    }
    fn debug_text_x_pos_mut(&mut self) -> &mut i32 {
        &mut self.debug_text_x_pos
    }
    fn debug_text_y_pos(&self) -> &i32 {
        &self.debug_text_y_pos
    }
    fn debug_text_y_pos_mut(&mut self) -> &mut i32 {
        &mut self.debug_text_y_pos
    }
    fn event_display_time(&self) -> &f32 {
        &self.event_display_time
    }
    fn event_display_time_mut(&mut self) -> &mut f32 {
        &mut self.event_display_time
    }
    fn divisible_loop_player_debug_info_color(&self) -> &super::core::Vec3 {
        &self.divisible_loop_player_debug_info_color
    }
    fn divisible_loop_player_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.divisible_loop_player_debug_info_color
    }
    fn properties_debug_info_color(&self) -> &super::core::Vec3 {
        &self.properties_debug_info_color
    }
    fn properties_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.properties_debug_info_color
    }
    fn events_debug_info_color(&self) -> &super::core::Vec3 {
        &self.events_debug_info_color
    }
    fn events_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.events_debug_info_color
    }
    fn external_wave_debug_info_color(&self) -> &super::core::Vec3 {
        &self.external_wave_debug_info_color
    }
    fn external_wave_debug_info_color_mut(&mut self) -> &mut super::core::Vec3 {
        &mut self.external_wave_debug_info_color
    }
    fn mute_sampler(&self) -> &bool {
        &self.mute_sampler
    }
    fn mute_sampler_mut(&mut self) -> &mut bool {
        &mut self.mute_sampler
    }
}

impl super::core::DataContainerTrait for DivisibleLoopPlayerNodeDebugData {
}

pub static DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeDebugData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(super::core::DATACONTAINER_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DivisibleLoopPlayerNodeDebugData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "EnableDebug",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, enable_debug),
            },
            FieldInfoData {
                name: "DebugInputConnections",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, debug_input_connections),
            },
            FieldInfoData {
                name: "DebugTextXPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, debug_text_x_pos),
            },
            FieldInfoData {
                name: "DebugTextYPos",
                flags: MemberInfoFlags::new(0),
                field_type: "Int32",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, debug_text_y_pos),
            },
            FieldInfoData {
                name: "EventDisplayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, event_display_time),
            },
            FieldInfoData {
                name: "DivisibleLoopPlayerDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, divisible_loop_player_debug_info_color),
            },
            FieldInfoData {
                name: "PropertiesDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, properties_debug_info_color),
            },
            FieldInfoData {
                name: "EventsDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, events_debug_info_color),
            },
            FieldInfoData {
                name: "ExternalWaveDebugInfoColor",
                flags: MemberInfoFlags::new(0),
                field_type: "Vec3",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, external_wave_debug_info_color),
            },
            FieldInfoData {
                name: "MuteSampler",
                flags: MemberInfoFlags::new(0),
                field_type: "Boolean",
                rust_offset: offset_of!(DivisibleLoopPlayerNodeDebugData, mute_sampler),
            },
        ],
    }),
    array_type: Some(DIVISIBLELOOPPLAYERNODEDEBUGDATA_ARRAY_TYPE_INFO),
    alignment: 16,
};

impl TypeObject for DivisibleLoopPlayerNodeDebugData {
    fn type_info(&self) -> &'static TypeInfo {
        DIVISIBLELOOPPLAYERNODEDEBUGDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIVISIBLELOOPPLAYERNODEDEBUGDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DivisibleLoopPlayerNodeDebugData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DivisibleLoopPlayerNodeDebugData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ExpanderNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub sidechain: AudioGraphNodePort,
    pub threshold: AudioGraphNodePort,
    pub ratio: AudioGraphNodePort,
    pub attack_time: AudioGraphNodePort,
    pub release_time: AudioGraphNodePort,
    pub use_sidechain: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub channel_mode: ExpanderChannelMode,
    pub plugin: SoundGraphPluginRef,
}

pub trait ExpanderNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn sidechain(&self) -> &AudioGraphNodePort;
    fn sidechain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn threshold(&self) -> &AudioGraphNodePort;
    fn threshold_mut(&mut self) -> &mut AudioGraphNodePort;
    fn ratio(&self) -> &AudioGraphNodePort;
    fn ratio_mut(&mut self) -> &mut AudioGraphNodePort;
    fn attack_time(&self) -> &AudioGraphNodePort;
    fn attack_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release_time(&self) -> &AudioGraphNodePort;
    fn release_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn use_sidechain(&self) -> &AudioGraphNodePort;
    fn use_sidechain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn channel_mode(&self) -> &ExpanderChannelMode;
    fn channel_mode_mut(&mut self) -> &mut ExpanderChannelMode;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl ExpanderNodeDataTrait for ExpanderNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn sidechain(&self) -> &AudioGraphNodePort {
        &self.sidechain
    }
    fn sidechain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.sidechain
    }
    fn threshold(&self) -> &AudioGraphNodePort {
        &self.threshold
    }
    fn threshold_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.threshold
    }
    fn ratio(&self) -> &AudioGraphNodePort {
        &self.ratio
    }
    fn ratio_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.ratio
    }
    fn attack_time(&self) -> &AudioGraphNodePort {
        &self.attack_time
    }
    fn attack_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.attack_time
    }
    fn release_time(&self) -> &AudioGraphNodePort {
        &self.release_time
    }
    fn release_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release_time
    }
    fn use_sidechain(&self) -> &AudioGraphNodePort {
        &self.use_sidechain
    }
    fn use_sidechain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.use_sidechain
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn channel_mode(&self) -> &ExpanderChannelMode {
        &self.channel_mode
    }
    fn channel_mode_mut(&mut self) -> &mut ExpanderChannelMode {
        &mut self.channel_mode
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for ExpanderNodeData {
}

impl super::core::DataContainerTrait for ExpanderNodeData {
}

pub static EXPANDERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ExpanderNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, r#in),
            },
            FieldInfoData {
                name: "Sidechain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, sidechain),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, threshold),
            },
            FieldInfoData {
                name: "Ratio",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, ratio),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, release_time),
            },
            FieldInfoData {
                name: "UseSidechain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, use_sidechain),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ExpanderNodeData, out),
            },
            FieldInfoData {
                name: "ChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: "ExpanderChannelMode",
                rust_offset: offset_of!(ExpanderNodeData, channel_mode),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ExpanderNodeData, plugin),
            },
        ],
    }),
    array_type: Some(EXPANDERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ExpanderNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        EXPANDERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static EXPANDERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ExpanderNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum ExpanderChannelMode {
    #[default]
    ExpanderChannelMode_Independent = 0,
    ExpanderChannelMode_Grouped = 1,
}

pub static EXPANDERCHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(EXPANDERCHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for ExpanderChannelMode {
    fn type_info(&self) -> &'static TypeInfo {
        EXPANDERCHANNELMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static EXPANDERCHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ExpanderChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ExpanderChannelMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DistortionClipNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub clip_level: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait DistortionClipNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn clip_level(&self) -> &AudioGraphNodePort;
    fn clip_level_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl DistortionClipNodeDataTrait for DistortionClipNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn clip_level(&self) -> &AudioGraphNodePort {
        &self.clip_level
    }
    fn clip_level_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.clip_level
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for DistortionClipNodeData {
}

impl super::core::DataContainerTrait for DistortionClipNodeData {
}

pub static DISTORTIONCLIPNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistortionClipNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DistortionClipNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DistortionClipNodeData, r#in),
            },
            FieldInfoData {
                name: "ClipLevel",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DistortionClipNodeData, clip_level),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DistortionClipNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DistortionClipNodeData, plugin),
            },
        ],
    }),
    array_type: Some(DISTORTIONCLIPNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DistortionClipNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DISTORTIONCLIPNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DISTORTIONCLIPNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DistortionClipNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DistortionClipNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DialogSamplerNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub pitch: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub enable_subtitles: AudioGraphNodePort,
    pub r#continue: AudioGraphNodePort,
    pub output: AudioGraphNodePort,
    pub triggered: AudioGraphNodePort,
    pub finished: AudioGraphNodePort,
    pub snd_player_plugin: SoundGraphPluginRef,
    pub resample_plugin: SoundGraphPluginRef,
    pub pause_plugin: SoundGraphPluginRef,
    pub gain_plugin: SoundGraphPluginRef,
    pub tail_length: f32,
    pub pitch_source: Option<Arc<Mutex<dyn OutputNodeDataTrait>>>,
}

pub trait DialogSamplerNodeDataTrait: AudioGraphNodeDataTrait {
    fn pitch(&self) -> &AudioGraphNodePort;
    fn pitch_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn enable_subtitles(&self) -> &AudioGraphNodePort;
    fn enable_subtitles_mut(&mut self) -> &mut AudioGraphNodePort;
    fn r#continue(&self) -> &AudioGraphNodePort;
    fn r#continue_mut(&mut self) -> &mut AudioGraphNodePort;
    fn output(&self) -> &AudioGraphNodePort;
    fn output_mut(&mut self) -> &mut AudioGraphNodePort;
    fn triggered(&self) -> &AudioGraphNodePort;
    fn triggered_mut(&mut self) -> &mut AudioGraphNodePort;
    fn finished(&self) -> &AudioGraphNodePort;
    fn finished_mut(&mut self) -> &mut AudioGraphNodePort;
    fn snd_player_plugin(&self) -> &SoundGraphPluginRef;
    fn snd_player_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn resample_plugin(&self) -> &SoundGraphPluginRef;
    fn resample_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn pause_plugin(&self) -> &SoundGraphPluginRef;
    fn pause_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain_plugin(&self) -> &SoundGraphPluginRef;
    fn gain_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn tail_length(&self) -> &f32;
    fn tail_length_mut(&mut self) -> &mut f32;
    fn pitch_source(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
    fn pitch_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>>;
}

impl DialogSamplerNodeDataTrait for DialogSamplerNodeData {
    fn pitch(&self) -> &AudioGraphNodePort {
        &self.pitch
    }
    fn pitch_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.pitch
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn enable_subtitles(&self) -> &AudioGraphNodePort {
        &self.enable_subtitles
    }
    fn enable_subtitles_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.enable_subtitles
    }
    fn r#continue(&self) -> &AudioGraphNodePort {
        &self.r#continue
    }
    fn r#continue_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#continue
    }
    fn output(&self) -> &AudioGraphNodePort {
        &self.output
    }
    fn output_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.output
    }
    fn triggered(&self) -> &AudioGraphNodePort {
        &self.triggered
    }
    fn triggered_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.triggered
    }
    fn finished(&self) -> &AudioGraphNodePort {
        &self.finished
    }
    fn finished_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.finished
    }
    fn snd_player_plugin(&self) -> &SoundGraphPluginRef {
        &self.snd_player_plugin
    }
    fn snd_player_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.snd_player_plugin
    }
    fn resample_plugin(&self) -> &SoundGraphPluginRef {
        &self.resample_plugin
    }
    fn resample_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.resample_plugin
    }
    fn pause_plugin(&self) -> &SoundGraphPluginRef {
        &self.pause_plugin
    }
    fn pause_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.pause_plugin
    }
    fn gain_plugin(&self) -> &SoundGraphPluginRef {
        &self.gain_plugin
    }
    fn gain_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain_plugin
    }
    fn tail_length(&self) -> &f32 {
        &self.tail_length
    }
    fn tail_length_mut(&mut self) -> &mut f32 {
        &mut self.tail_length
    }
    fn pitch_source(&self) -> &Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &self.pitch_source
    }
    fn pitch_source_mut(&mut self) -> &mut Option<Arc<Mutex<dyn OutputNodeDataTrait>>> {
        &mut self.pitch_source
    }
}

impl AudioGraphNodeDataTrait for DialogSamplerNodeData {
}

impl super::core::DataContainerTrait for DialogSamplerNodeData {
}

pub static DIALOGSAMPLERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DialogSamplerNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DialogSamplerNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Pitch",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, pitch),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, amplitude),
            },
            FieldInfoData {
                name: "EnableSubtitles",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, enable_subtitles),
            },
            FieldInfoData {
                name: "Continue",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, r#continue),
            },
            FieldInfoData {
                name: "Output",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, output),
            },
            FieldInfoData {
                name: "Triggered",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, triggered),
            },
            FieldInfoData {
                name: "Finished",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DialogSamplerNodeData, finished),
            },
            FieldInfoData {
                name: "SndPlayerPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DialogSamplerNodeData, snd_player_plugin),
            },
            FieldInfoData {
                name: "ResamplePlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DialogSamplerNodeData, resample_plugin),
            },
            FieldInfoData {
                name: "PausePlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DialogSamplerNodeData, pause_plugin),
            },
            FieldInfoData {
                name: "GainPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DialogSamplerNodeData, gain_plugin),
            },
            FieldInfoData {
                name: "TailLength",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DialogSamplerNodeData, tail_length),
            },
            FieldInfoData {
                name: "PitchSource",
                flags: MemberInfoFlags::new(0),
                field_type: "OutputNodeData",
                rust_offset: offset_of!(DialogSamplerNodeData, pitch_source),
            },
        ],
    }),
    array_type: Some(DIALOGSAMPLERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DialogSamplerNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DIALOGSAMPLERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DIALOGSAMPLERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DialogSamplerNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DialogSamplerNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DelayNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub delay_time: AudioGraphNodePort,
    pub feedback: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub plugin: SoundGraphPluginRef,
}

pub trait DelayNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn delay_time(&self) -> &AudioGraphNodePort;
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn feedback(&self) -> &AudioGraphNodePort;
    fn feedback_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_delay_time(&self) -> &f32;
    fn max_delay_time_mut(&mut self) -> &mut f32;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl DelayNodeDataTrait for DelayNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn delay_time(&self) -> &AudioGraphNodePort {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay_time
    }
    fn feedback(&self) -> &AudioGraphNodePort {
        &self.feedback
    }
    fn feedback_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.feedback
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn max_delay_time(&self) -> &f32 {
        &self.max_delay_time
    }
    fn max_delay_time_mut(&mut self) -> &mut f32 {
        &mut self.max_delay_time
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for DelayNodeData {
}

impl super::core::DataContainerTrait for DelayNodeData {
}

pub static DELAYNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DelayNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DelayNodeData, r#in),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DelayNodeData, delay_time),
            },
            FieldInfoData {
                name: "Feedback",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DelayNodeData, feedback),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DelayNodeData, out),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(DelayNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DelayNodeData, plugin),
            },
        ],
    }),
    array_type: Some(DELAYNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DelayNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DELAYNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DELAYNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DelayNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DelayNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct DacNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub hrtf: AudioGraphNodePort,
    pub delay_plugin: SoundGraphPluginRef,
    pub vu_plugin: SoundGraphPluginRef,
    pub gain_plugin: SoundGraphPluginRef,
    pub dac_plugin: SoundGraphPluginRef,
}

pub trait DacNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn hrtf(&self) -> &AudioGraphNodePort;
    fn hrtf_mut(&mut self) -> &mut AudioGraphNodePort;
    fn delay_plugin(&self) -> &SoundGraphPluginRef;
    fn delay_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn vu_plugin(&self) -> &SoundGraphPluginRef;
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn gain_plugin(&self) -> &SoundGraphPluginRef;
    fn gain_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn dac_plugin(&self) -> &SoundGraphPluginRef;
    fn dac_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl DacNodeDataTrait for DacNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn hrtf(&self) -> &AudioGraphNodePort {
        &self.hrtf
    }
    fn hrtf_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.hrtf
    }
    fn delay_plugin(&self) -> &SoundGraphPluginRef {
        &self.delay_plugin
    }
    fn delay_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.delay_plugin
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        &self.vu_plugin
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.vu_plugin
    }
    fn gain_plugin(&self) -> &SoundGraphPluginRef {
        &self.gain_plugin
    }
    fn gain_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.gain_plugin
    }
    fn dac_plugin(&self) -> &SoundGraphPluginRef {
        &self.dac_plugin
    }
    fn dac_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.dac_plugin
    }
}

impl AudioGraphNodeDataTrait for DacNodeData {
}

impl super::core::DataContainerTrait for DacNodeData {
}

pub static DACNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DacNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<DacNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DacNodeData, r#in),
            },
            FieldInfoData {
                name: "Hrtf",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(DacNodeData, hrtf),
            },
            FieldInfoData {
                name: "DelayPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DacNodeData, delay_plugin),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DacNodeData, vu_plugin),
            },
            FieldInfoData {
                name: "GainPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DacNodeData, gain_plugin),
            },
            FieldInfoData {
                name: "DacPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(DacNodeData, dac_plugin),
            },
        ],
    }),
    array_type: Some(DACNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for DacNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        DACNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static DACNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "DacNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("DacNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CrossfaderNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub in1: AudioGraphNodePort,
    pub in2: AudioGraphNodePort,
    pub ctrl: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin1: SoundGraphPluginRef,
    pub plugin2: SoundGraphPluginRef,
}

pub trait CrossfaderNodeDataTrait: AudioGraphNodeDataTrait {
    fn in1(&self) -> &AudioGraphNodePort;
    fn in1_mut(&mut self) -> &mut AudioGraphNodePort;
    fn in2(&self) -> &AudioGraphNodePort;
    fn in2_mut(&mut self) -> &mut AudioGraphNodePort;
    fn ctrl(&self) -> &AudioGraphNodePort;
    fn ctrl_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin1(&self) -> &SoundGraphPluginRef;
    fn plugin1_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn plugin2(&self) -> &SoundGraphPluginRef;
    fn plugin2_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl CrossfaderNodeDataTrait for CrossfaderNodeData {
    fn in1(&self) -> &AudioGraphNodePort {
        &self.in1
    }
    fn in1_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.in1
    }
    fn in2(&self) -> &AudioGraphNodePort {
        &self.in2
    }
    fn in2_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.in2
    }
    fn ctrl(&self) -> &AudioGraphNodePort {
        &self.ctrl
    }
    fn ctrl_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.ctrl
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin1(&self) -> &SoundGraphPluginRef {
        &self.plugin1
    }
    fn plugin1_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin1
    }
    fn plugin2(&self) -> &SoundGraphPluginRef {
        &self.plugin2
    }
    fn plugin2_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin2
    }
}

impl AudioGraphNodeDataTrait for CrossfaderNodeData {
}

impl super::core::DataContainerTrait for CrossfaderNodeData {
}

pub static CROSSFADERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrossfaderNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CrossfaderNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In1",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CrossfaderNodeData, in1),
            },
            FieldInfoData {
                name: "In2",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CrossfaderNodeData, in2),
            },
            FieldInfoData {
                name: "Ctrl",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CrossfaderNodeData, ctrl),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CrossfaderNodeData, out),
            },
            FieldInfoData {
                name: "Plugin1",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(CrossfaderNodeData, plugin1),
            },
            FieldInfoData {
                name: "Plugin2",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(CrossfaderNodeData, plugin2),
            },
        ],
    }),
    array_type: Some(CROSSFADERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CrossfaderNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CROSSFADERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CROSSFADERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CrossfaderNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CrossfaderNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ControllerOutputNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub connected: AudioGraphNodePort,
    pub disconnected: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait ControllerOutputNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn connected(&self) -> &AudioGraphNodePort;
    fn connected_mut(&mut self) -> &mut AudioGraphNodePort;
    fn disconnected(&self) -> &AudioGraphNodePort;
    fn disconnected_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl ControllerOutputNodeDataTrait for ControllerOutputNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn connected(&self) -> &AudioGraphNodePort {
        &self.connected
    }
    fn connected_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.connected
    }
    fn disconnected(&self) -> &AudioGraphNodePort {
        &self.disconnected
    }
    fn disconnected_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.disconnected
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for ControllerOutputNodeData {
}

impl super::core::DataContainerTrait for ControllerOutputNodeData {
}

pub static CONTROLLEROUTPUTNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllerOutputNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ControllerOutputNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ControllerOutputNodeData, r#in),
            },
            FieldInfoData {
                name: "Connected",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ControllerOutputNodeData, connected),
            },
            FieldInfoData {
                name: "Disconnected",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ControllerOutputNodeData, disconnected),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ControllerOutputNodeData, plugin),
            },
        ],
    }),
    array_type: Some(CONTROLLEROUTPUTNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ControllerOutputNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CONTROLLEROUTPUTNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CONTROLLEROUTPUTNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ControllerOutputNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ControllerOutputNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct CompressorNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub sidechain: AudioGraphNodePort,
    pub threshold: AudioGraphNodePort,
    pub ratio: AudioGraphNodePort,
    pub attack_time: AudioGraphNodePort,
    pub release_time: AudioGraphNodePort,
    pub use_sidechain: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub channel_mode: CompressorChannelMode,
    pub plugin: SoundGraphPluginRef,
}

pub trait CompressorNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn sidechain(&self) -> &AudioGraphNodePort;
    fn sidechain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn threshold(&self) -> &AudioGraphNodePort;
    fn threshold_mut(&mut self) -> &mut AudioGraphNodePort;
    fn ratio(&self) -> &AudioGraphNodePort;
    fn ratio_mut(&mut self) -> &mut AudioGraphNodePort;
    fn attack_time(&self) -> &AudioGraphNodePort;
    fn attack_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn release_time(&self) -> &AudioGraphNodePort;
    fn release_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn use_sidechain(&self) -> &AudioGraphNodePort;
    fn use_sidechain_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn channel_mode(&self) -> &CompressorChannelMode;
    fn channel_mode_mut(&mut self) -> &mut CompressorChannelMode;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl CompressorNodeDataTrait for CompressorNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn sidechain(&self) -> &AudioGraphNodePort {
        &self.sidechain
    }
    fn sidechain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.sidechain
    }
    fn threshold(&self) -> &AudioGraphNodePort {
        &self.threshold
    }
    fn threshold_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.threshold
    }
    fn ratio(&self) -> &AudioGraphNodePort {
        &self.ratio
    }
    fn ratio_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.ratio
    }
    fn attack_time(&self) -> &AudioGraphNodePort {
        &self.attack_time
    }
    fn attack_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.attack_time
    }
    fn release_time(&self) -> &AudioGraphNodePort {
        &self.release_time
    }
    fn release_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.release_time
    }
    fn use_sidechain(&self) -> &AudioGraphNodePort {
        &self.use_sidechain
    }
    fn use_sidechain_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.use_sidechain
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn channel_mode(&self) -> &CompressorChannelMode {
        &self.channel_mode
    }
    fn channel_mode_mut(&mut self) -> &mut CompressorChannelMode {
        &mut self.channel_mode
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for CompressorNodeData {
}

impl super::core::DataContainerTrait for CompressorNodeData {
}

pub static COMPRESSORNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<CompressorNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, r#in),
            },
            FieldInfoData {
                name: "Sidechain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, sidechain),
            },
            FieldInfoData {
                name: "Threshold",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, threshold),
            },
            FieldInfoData {
                name: "Ratio",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, ratio),
            },
            FieldInfoData {
                name: "AttackTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, attack_time),
            },
            FieldInfoData {
                name: "ReleaseTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, release_time),
            },
            FieldInfoData {
                name: "UseSidechain",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, use_sidechain),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(CompressorNodeData, out),
            },
            FieldInfoData {
                name: "ChannelMode",
                flags: MemberInfoFlags::new(0),
                field_type: "CompressorChannelMode",
                rust_offset: offset_of!(CompressorNodeData, channel_mode),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(CompressorNodeData, plugin),
            },
        ],
    }),
    array_type: Some(COMPRESSORNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for CompressorNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        COMPRESSORNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static COMPRESSORNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CompressorNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum CompressorChannelMode {
    #[default]
    CompressorChannelMode_Independent = 0,
    CompressorChannelMode_Grouped = 1,
}

pub static COMPRESSORCHANNELMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorChannelMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(COMPRESSORCHANNELMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for CompressorChannelMode {
    fn type_info(&self) -> &'static TypeInfo {
        COMPRESSORCHANNELMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static COMPRESSORCHANNELMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "CompressorChannelMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("CompressorChannelMode"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct ChorusNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub max_delay: f32,
    pub max_modulation_depth: f32,
    pub tap_count: AudioGraphNodePort,
    pub delay_time: AudioGraphNodePort,
    pub modulation_depth: AudioGraphNodePort,
    pub modulation_frequency: AudioGraphNodePort,
}

pub trait ChorusNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn max_delay(&self) -> &f32;
    fn max_delay_mut(&mut self) -> &mut f32;
    fn max_modulation_depth(&self) -> &f32;
    fn max_modulation_depth_mut(&mut self) -> &mut f32;
    fn tap_count(&self) -> &AudioGraphNodePort;
    fn tap_count_mut(&mut self) -> &mut AudioGraphNodePort;
    fn delay_time(&self) -> &AudioGraphNodePort;
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn modulation_depth(&self) -> &AudioGraphNodePort;
    fn modulation_depth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn modulation_frequency(&self) -> &AudioGraphNodePort;
    fn modulation_frequency_mut(&mut self) -> &mut AudioGraphNodePort;
}

impl ChorusNodeDataTrait for ChorusNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn max_delay(&self) -> &f32 {
        &self.max_delay
    }
    fn max_delay_mut(&mut self) -> &mut f32 {
        &mut self.max_delay
    }
    fn max_modulation_depth(&self) -> &f32 {
        &self.max_modulation_depth
    }
    fn max_modulation_depth_mut(&mut self) -> &mut f32 {
        &mut self.max_modulation_depth
    }
    fn tap_count(&self) -> &AudioGraphNodePort {
        &self.tap_count
    }
    fn tap_count_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.tap_count
    }
    fn delay_time(&self) -> &AudioGraphNodePort {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay_time
    }
    fn modulation_depth(&self) -> &AudioGraphNodePort {
        &self.modulation_depth
    }
    fn modulation_depth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.modulation_depth
    }
    fn modulation_frequency(&self) -> &AudioGraphNodePort {
        &self.modulation_frequency
    }
    fn modulation_frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.modulation_frequency
    }
}

impl AudioGraphNodeDataTrait for ChorusNodeData {
}

impl super::core::DataContainerTrait for ChorusNodeData {
}

pub static CHORUSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChorusNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<ChorusNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ChorusNodeData, r#in),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ChorusNodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(ChorusNodeData, plugin),
            },
            FieldInfoData {
                name: "MaxDelay",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChorusNodeData, max_delay),
            },
            FieldInfoData {
                name: "MaxModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(ChorusNodeData, max_modulation_depth),
            },
            FieldInfoData {
                name: "TapCount",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ChorusNodeData, tap_count),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ChorusNodeData, delay_time),
            },
            FieldInfoData {
                name: "ModulationDepth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ChorusNodeData, modulation_depth),
            },
            FieldInfoData {
                name: "ModulationFrequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(ChorusNodeData, modulation_frequency),
            },
        ],
    }),
    array_type: Some(CHORUSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for ChorusNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        CHORUSNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static CHORUSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "ChorusNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("ChorusNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BusNodeData {
    pub _glacier_base: SoundBusData,
    pub out: AudioGraphNodePort,
    pub vu_plugin: SoundGraphPluginRef,
}

pub trait BusNodeDataTrait: SoundBusDataTrait {
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn vu_plugin(&self) -> &SoundGraphPluginRef;
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl BusNodeDataTrait for BusNodeData {
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn vu_plugin(&self) -> &SoundGraphPluginRef {
        &self.vu_plugin
    }
    fn vu_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.vu_plugin
    }
}

impl SoundBusDataTrait for BusNodeData {
    fn channel_count(&self) -> &u8 {
        self._glacier_base.channel_count()
    }
    fn channel_count_mut(&mut self) -> &mut u8 {
        self._glacier_base.channel_count_mut()
    }
    fn bus_name(&self) -> &String {
        self._glacier_base.bus_name()
    }
    fn bus_name_mut(&mut self) -> &mut String {
        self._glacier_base.bus_name_mut()
    }
    fn submix_plugin(&self) -> &SoundGraphPluginRef {
        self._glacier_base.submix_plugin()
    }
    fn submix_plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        self._glacier_base.submix_plugin_mut()
    }
}

impl AudioGraphNodeDataTrait for BusNodeData {
}

impl super::core::DataContainerTrait for BusNodeData {
}

pub static BUSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BusNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(SOUNDBUSDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BusNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BusNodeData, out),
            },
            FieldInfoData {
                name: "VuPlugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(BusNodeData, vu_plugin),
            },
        ],
    }),
    array_type: Some(BUSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BusNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        BUSNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BUSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BusNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BusNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BandPassIir2NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub bandwidth: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait BandPassIir2NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn bandwidth(&self) -> &AudioGraphNodePort;
    fn bandwidth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl BandPassIir2NodeDataTrait for BandPassIir2NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn bandwidth(&self) -> &AudioGraphNodePort {
        &self.bandwidth
    }
    fn bandwidth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.bandwidth
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for BandPassIir2NodeData {
}

impl super::core::DataContainerTrait for BandPassIir2NodeData {
}

pub static BANDPASSIIR2NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassIir2NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BandPassIir2NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassIir2NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassIir2NodeData, frequency),
            },
            FieldInfoData {
                name: "Bandwidth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassIir2NodeData, bandwidth),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassIir2NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(BandPassIir2NodeData, plugin),
            },
        ],
    }),
    array_type: Some(BANDPASSIIR2NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BandPassIir2NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        BANDPASSIIR2NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANDPASSIIR2NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassIir2NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BandPassIir2NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct BandPassFir64NodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub frequency: AudioGraphNodePort,
    pub bandwidth: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
}

pub trait BandPassFir64NodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn frequency(&self) -> &AudioGraphNodePort;
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort;
    fn bandwidth(&self) -> &AudioGraphNodePort;
    fn bandwidth_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl BandPassFir64NodeDataTrait for BandPassFir64NodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn frequency(&self) -> &AudioGraphNodePort {
        &self.frequency
    }
    fn frequency_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.frequency
    }
    fn bandwidth(&self) -> &AudioGraphNodePort {
        &self.bandwidth
    }
    fn bandwidth_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.bandwidth
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for BandPassFir64NodeData {
}

impl super::core::DataContainerTrait for BandPassFir64NodeData {
}

pub static BANDPASSFIR64NODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassFir64NodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<BandPassFir64NodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassFir64NodeData, r#in),
            },
            FieldInfoData {
                name: "Frequency",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassFir64NodeData, frequency),
            },
            FieldInfoData {
                name: "Bandwidth",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassFir64NodeData, bandwidth),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(BandPassFir64NodeData, out),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(BandPassFir64NodeData, plugin),
            },
        ],
    }),
    array_type: Some(BANDPASSFIR64NODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for BandPassFir64NodeData {
    fn type_info(&self) -> &'static TypeInfo {
        BANDPASSFIR64NODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static BANDPASSFIR64NODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "BandPassFir64NodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("BandPassFir64NodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AllPassNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub delay_time: AudioGraphNodePort,
    pub amplitude: AudioGraphNodePort,
    pub out: AudioGraphNodePort,
    pub max_delay_time: f32,
    pub plugin: SoundGraphPluginRef,
}

pub trait AllPassNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn delay_time(&self) -> &AudioGraphNodePort;
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort;
    fn amplitude(&self) -> &AudioGraphNodePort;
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort;
    fn out(&self) -> &AudioGraphNodePort;
    fn out_mut(&mut self) -> &mut AudioGraphNodePort;
    fn max_delay_time(&self) -> &f32;
    fn max_delay_time_mut(&mut self) -> &mut f32;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
}

impl AllPassNodeDataTrait for AllPassNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn delay_time(&self) -> &AudioGraphNodePort {
        &self.delay_time
    }
    fn delay_time_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.delay_time
    }
    fn amplitude(&self) -> &AudioGraphNodePort {
        &self.amplitude
    }
    fn amplitude_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.amplitude
    }
    fn out(&self) -> &AudioGraphNodePort {
        &self.out
    }
    fn out_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.out
    }
    fn max_delay_time(&self) -> &f32 {
        &self.max_delay_time
    }
    fn max_delay_time_mut(&mut self) -> &mut f32 {
        &mut self.max_delay_time
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
}

impl AudioGraphNodeDataTrait for AllPassNodeData {
}

impl super::core::DataContainerTrait for AllPassNodeData {
}

pub static ALLPASSNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllPassNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AllPassNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AllPassNodeData, r#in),
            },
            FieldInfoData {
                name: "DelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AllPassNodeData, delay_time),
            },
            FieldInfoData {
                name: "Amplitude",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AllPassNodeData, amplitude),
            },
            FieldInfoData {
                name: "Out",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AllPassNodeData, out),
            },
            FieldInfoData {
                name: "MaxDelayTime",
                flags: MemberInfoFlags::new(0),
                field_type: "Float32",
                rust_offset: offset_of!(AllPassNodeData, max_delay_time),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(AllPassNodeData, plugin),
            },
        ],
    }),
    array_type: Some(ALLPASSNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AllPassNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        ALLPASSNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static ALLPASSNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AllPassNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AllPassNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Clone, Debug, Default)]
pub struct AiffWriterNodeData {
    pub _glacier_base: AudioGraphNodeData,
    pub r#in: AudioGraphNodePort,
    pub start: AudioGraphNodePort,
    pub stop: AudioGraphNodePort,
    pub plugin: SoundGraphPluginRef,
    pub file_name: String,
}

pub trait AiffWriterNodeDataTrait: AudioGraphNodeDataTrait {
    fn r#in(&self) -> &AudioGraphNodePort;
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort;
    fn start(&self) -> &AudioGraphNodePort;
    fn start_mut(&mut self) -> &mut AudioGraphNodePort;
    fn stop(&self) -> &AudioGraphNodePort;
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort;
    fn plugin(&self) -> &SoundGraphPluginRef;
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef;
    fn file_name(&self) -> &String;
    fn file_name_mut(&mut self) -> &mut String;
}

impl AiffWriterNodeDataTrait for AiffWriterNodeData {
    fn r#in(&self) -> &AudioGraphNodePort {
        &self.r#in
    }
    fn r#in_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.r#in
    }
    fn start(&self) -> &AudioGraphNodePort {
        &self.start
    }
    fn start_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.start
    }
    fn stop(&self) -> &AudioGraphNodePort {
        &self.stop
    }
    fn stop_mut(&mut self) -> &mut AudioGraphNodePort {
        &mut self.stop
    }
    fn plugin(&self) -> &SoundGraphPluginRef {
        &self.plugin
    }
    fn plugin_mut(&mut self) -> &mut SoundGraphPluginRef {
        &mut self.plugin
    }
    fn file_name(&self) -> &String {
        &self.file_name
    }
    fn file_name_mut(&mut self) -> &mut String {
        &mut self.file_name
    }
}

impl AudioGraphNodeDataTrait for AiffWriterNodeData {
}

impl super::core::DataContainerTrait for AiffWriterNodeData {
}

pub static AIFFWRITERNODEDATA_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AiffWriterNodeData",
    flags: MemberInfoFlags::new(101),
    module: "Audio",
    data: TypeInfoData::Class(ClassInfoData {
        super_class: Some(AUDIOGRAPHNODEDATA_TYPE_INFO),
        functions: TypeFunctions {
            create: || Arc::new(Mutex::new(<AiffWriterNodeData as Default>::default())),
        },
        fields: &[
            FieldInfoData {
                name: "In",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AiffWriterNodeData, r#in),
            },
            FieldInfoData {
                name: "Start",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AiffWriterNodeData, start),
            },
            FieldInfoData {
                name: "Stop",
                flags: MemberInfoFlags::new(0),
                field_type: "AudioGraphNodePort",
                rust_offset: offset_of!(AiffWriterNodeData, stop),
            },
            FieldInfoData {
                name: "Plugin",
                flags: MemberInfoFlags::new(0),
                field_type: "SoundGraphPluginRef",
                rust_offset: offset_of!(AiffWriterNodeData, plugin),
            },
            FieldInfoData {
                name: "FileName",
                flags: MemberInfoFlags::new(0),
                field_type: "CString",
                rust_offset: offset_of!(AiffWriterNodeData, file_name),
            },
        ],
    }),
    array_type: Some(AIFFWRITERNODEDATA_ARRAY_TYPE_INFO),
    alignment: 8,
};

impl TypeObject for AiffWriterNodeData {
    fn type_info(&self) -> &'static TypeInfo {
        AIFFWRITERNODEDATA_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core()
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        self._glacier_base.data_container_core_mut()
    }
}


pub static AIFFWRITERNODEDATA_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "AiffWriterNodeData-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("AiffWriterNodeData"),
    array_type: None,
    alignment: 8,
};


#[derive(Hash, Clone, Copy, PartialEq, Default, Debug)]
#[repr(i64)]
#[allow(non_camel_case_types)]
pub enum PanNormalizationMode {
    #[default]
    PanNormalizationMode_One = 0,
    PanNormalizationMode_InputChannelCount = 1,
    PanNormalizationMode_SqrtInputChannelCount = 2,
}

pub static PANNORMALIZATIONMODE_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanNormalizationMode",
    flags: MemberInfoFlags::new(49429),
    module: "Audio",
    data: TypeInfoData::Enum,
    array_type: Some(PANNORMALIZATIONMODE_ARRAY_TYPE_INFO),
    alignment: 1,
};

impl TypeObject for PanNormalizationMode {
    fn type_info(&self) -> &'static TypeInfo {
        PANNORMALIZATIONMODE_TYPE_INFO
    }
    fn as_any(&self) -> &dyn Any {
        self
    }
    fn as_any_mut(&mut self) -> &mut dyn Any {
        self
    }
    fn data_container_core(&self) -> Option<&glacier_reflect::data_container::DataContainerCore> {
        None
    }
    fn data_container_core_mut(&mut self) -> Option<&mut glacier_reflect::data_container::DataContainerCore> {
        None
    }
}


pub static PANNORMALIZATIONMODE_ARRAY_TYPE_INFO: &'static TypeInfo = &TypeInfo {
    name: "PanNormalizationMode-Array",
    flags: MemberInfoFlags::new(145),
    module: "Audio",
    data: TypeInfoData::Array("PanNormalizationMode"),
    array_type: None,
    alignment: 8,
};


